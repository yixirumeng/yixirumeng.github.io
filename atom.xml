<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忆昔如梦的博客</title>
  
  <subtitle>前端知识分享，前端面试经验，工作相关总结</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yixirumeng.github.io/"/>
  <updated>2019-01-24T12:38:48.795Z</updated>
  <id>http://yixirumeng.github.io/</id>
  
  <author>
    <name>忆昔如梦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vuex源码分析六 ———— mapMutations</title>
    <link href="http://yixirumeng.github.io/2019/01/24/vuex-source-code-mapMutations/"/>
    <id>http://yixirumeng.github.io/2019/01/24/vuex-source-code-mapMutations/</id>
    <published>2019-01-24T12:34:41.000Z</published>
    <updated>2019-01-24T12:38:48.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vuex-source-code-mapMutations.jpg" alt=""></p><blockquote><p>说完了<code>actions</code>的Api，当然少不了<code>mutations</code>的Api————<code>mapMutations</code>，下面来看看其源码</p></blockquote><a id="more"></a><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p><code>mapMutations</code>与<code>mapActions</code>的原理很相似，只不过就是调用了<code>this.$store.commit</code>方法来修改<code>state</code></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapMutations = normalizeNamespace((<span class="keyword">namespace</span>, mutations) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    normalizeMap(mutations).forEach((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">        res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedMutation</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">            let commit = <span class="keyword">this</span>.$store.commit</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">namespace</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> module = getModuleByNamespace(<span class="keyword">this</span>.$store, <span class="string">'mapMutations'</span>, <span class="keyword">namespace</span>)</span><br><span class="line">                <span class="keyword">if</span> (!module) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                commit = module.context.commit</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">                ? val.apply(<span class="keyword">this</span>, [commit].concat(args))</span><br><span class="line">                : commit.apply(<span class="keyword">this</span>.$store, [val].concat(args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mapMutations在Vue组件中的应用"><a href="#mapMutations在Vue组件中的应用" class="headerlink" title="mapMutations在Vue组件中的应用"></a>mapMutations在Vue组件中的应用</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; num &#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    import </span><span class="template-variable">&#123; mapGetters, mapMutations &#125;</span><span class="xml"> from 'vuex'</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    export default </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">        computed: &#123;</span></span><br><span class="line"><span class="template-variable">            ...mapGetters(['num'])</span></span><br><span class="line"><span class="template-variable">        &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">        methods: </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">            ...mapMutations(['increment'])</span></span><br><span class="line"><span class="template-variable">        &#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>写法基本一致，当然传入的参数也可以是对象，也可以做其它名称的映射。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>mapMutations</code>没有特别想要说的，理解了<code>mapActions</code>也就明白了它的原理。</p><p>可以看出，这些方便操作的Api，其内部实现的原理还是要应用<code>Store</code>中定义的方法，只不过方便开发时的书写，来将其进一步封装。</p><h3 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h3><p>以上分了几个篇幅来讲解<code>Vuex</code>的源码，经过分析之后，理解其内部的思想，也可以看出它与<code>Redux</code>的区别。这样可以让我们在开发使用的时候，更加得心应手，以前只知道这样写，但是为什么却不得而知。而读过源码之后，即使在出现问题的时候，也可以很轻松的定位到问题所在。</p><h3 id="学到的知识"><a href="#学到的知识" class="headerlink" title="学到的知识"></a>学到的知识</h3><p>1、<code>class</code>类的使用，深入理解面向对象编程的思想。</p><p>2、加深理解数组、对象、字符串等类型操作的各种Api。</p><p>3、高阶函数的灵活运用，<code>Vuex</code>将高阶函数应用到了极致，看源码可知，很多地方都应用了高阶函数，使得整体更加完善，逻辑更加清晰。</p><p>4、工具函数、方法的拆分。</p><p>5、理解工具、框架的核心思想。</p><p>6、还是那句话，基础最最重要，基础打好，更方便开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vuex-source-code-mapMutations.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说完了&lt;code&gt;actions&lt;/code&gt;的Api，当然少不了&lt;code&gt;mutations&lt;/code&gt;的Api————&lt;code&gt;mapMutations&lt;/code&gt;，下面来看看其源码&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://yixirumeng.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vuex源码分析五 ———— mapActions</title>
    <link href="http://yixirumeng.github.io/2019/01/20/vuex-source-code-mapActions/"/>
    <id>http://yixirumeng.github.io/2019/01/20/vuex-source-code-mapActions/</id>
    <published>2019-01-20T05:08:56.000Z</published>
    <updated>2019-01-24T12:38:57.579Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vuex-source-code-mapActions.jpg" alt=""></p><blockquote><p>前两篇文章分析了获取状态的两个Api，这一篇分析一下派发<code>action</code>的Api————<code>mapActions</code></p></blockquote><a id="more"></a><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><p><code>mapActions</code>也可以以数组或者对象作为参数，其内部调用的依然是<code>this.$store.dispatch</code>来派发<code>action</code>，看下面这个函数有个主意点就是<code>...args</code>，它其实就是我们在开发时传给<code>mapActions</code>中方法的参数，也就是<code>this.increment(1)</code>中的这个1</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapActions = normalizeNamespace((<span class="keyword">namespace</span>, actions) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    normalizeMap(actions).forEach((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">        res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedAction</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">            let dispatch = <span class="keyword">this</span>.$store.dispatch</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">namespace</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> module = getModuleByNamespace(<span class="keyword">this</span>.$store, <span class="string">'mapActions'</span>, <span class="keyword">namespace</span>)</span><br><span class="line">                <span class="keyword">if</span> (!module) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                dispatch = module.context.dispatch</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">'function'</span></span><br><span class="line">                ? val.apply(<span class="keyword">this</span>, [dispatch].concat(args))</span><br><span class="line">                : dispatch.apply(<span class="keyword">this</span>.$store, [val].concat(args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mapActions在Vue组件中的应用"><a href="#mapActions在Vue组件中的应用" class="headerlink" title="mapActions在Vue组件中的应用"></a>mapActions在Vue组件中的应用</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; num &#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    import </span><span class="template-variable">&#123; mapGetters, mapActions &#125;</span><span class="xml"> from 'vuex'</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    export default </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">        computed: &#123;</span></span><br><span class="line"><span class="template-variable">            ...mapGetters(['num'])</span></span><br><span class="line"><span class="template-variable">        &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">        methods: </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">            ...mapActions(['increment'])</span></span><br><span class="line"><span class="template-variable">        &#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>用法跟之前分析的<code>mapState</code>、<code>mapGetters</code>类似，当然也可以传入对象进行映射，即<code>mapActions({add: &#39;increment&#39;})</code>，这样调用<code>add</code>方法也就相当于调用了<code>increment</code>方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>mapActions</code>的用法及原理上面已经说了，这里就不在阐述了。因为<code>action</code>支持异步操作，看过前面对<code>Store</code>的源码分析之后可以知道，<code>action</code>是可以合并的，同时<code>dispatch</code>返回的是<code>Promise</code>，所以在处理等待某个请求之后再执行下一个请求的这种操作时，可以使用以下的方式：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    <span class="regexp">//</span> ...</span><br><span class="line">    actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果应用<code>async/await</code>时的写法如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line">actions: &#123;</span><br><span class="line">    <span class="function"><span class="keyword">async</span> <span class="title">actionA</span> (<span class="params">&#123; commit &#125;</span>) </span>&#123;</span><br><span class="line">        commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">async</span> <span class="title">actionB</span> (<span class="params">&#123; dispatch, commit &#125;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">        commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结部分参考：<code>Vuex</code>官方文档，链接：<a href="https://vuex.vuejs.org/zh/guide/actions.html" target="_blank" rel="noopener">https://vuex.vuejs.org/zh/guide/actions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vuex-source-code-mapActions.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前两篇文章分析了获取状态的两个Api，这一篇分析一下派发&lt;code&gt;action&lt;/code&gt;的Api————&lt;code&gt;mapActions&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://yixirumeng.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vuex源码分析四 ———— mapGetters</title>
    <link href="http://yixirumeng.github.io/2019/01/17/vuex-source-code-mapGetters/"/>
    <id>http://yixirumeng.github.io/2019/01/17/vuex-source-code-mapGetters/</id>
    <published>2019-01-17T15:10:22.000Z</published>
    <updated>2019-01-24T12:38:53.357Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vuex-source-code-mapGetters.jpg" alt=""></p><blockquote><p>上一篇分析了获取<code>Vuex</code>中的<code>state</code>的Api————<code>mapState</code>，这一篇继续分析获取<code>getters</code>的Api————<code>mapGetters</code>，它其实与<code>mapState</code>类似，下面看一下源码。</p></blockquote><a id="more"></a><h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><p><code>mapGetters</code>的方法相较于<code>mapState</code>简单一些，因为调用了<code>normalizeMap</code>方法，所以也可以传入数组或对象，而下面定义的方法内部，最终应用<code>this.$store.getters</code>来获取最终需要的<code>getter</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapGetters = normalizeNamespace(<span class="function">(<span class="params"><span class="keyword">namespace</span>, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    normalizeMap(getters).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        val = <span class="keyword">namespace</span> + val</span><br><span class="line">        res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">namespace</span> &amp;&amp; !getModuleByNamespace(<span class="keyword">this</span>.$store, <span class="string">'mapGetters'</span>, <span class="keyword">namespace</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !(val <span class="keyword">in</span> <span class="keyword">this</span>.$store.getters)) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown getter: <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[val]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">        res[key].vuex = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mapGetters在Vue组件中的应用"><a href="#mapGetters在Vue组件中的应用" class="headerlink" title="mapGetters在Vue组件中的应用"></a>mapGetters在Vue组件中的应用</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; num &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    import &#123; mapGetters &#125; from 'vuex'</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    export default &#123;</span></span><br><span class="line"><span class="xml">        computed: &#123;</span></span><br><span class="line"><span class="xml">            ...mapGetters(['num'])</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        mounted()&#123;</span></span><br><span class="line"><span class="xml">            console.log(this.num)</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>它的使用方式与<code>mapState</code>类似，这里就不做详细的分析了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>mapGetters</code>的内部原理其实同样调用了<code>this.$store.getters</code>来获取最终需要的<code>getter</code>。平时开发中，还是主要应用<code>mapGetters</code>来获取状态，因为有些时候，需要合并多个<code>state</code>才能得到想要的数据，可能暂时用不到，但随着业务的增加，不可避免会用到，所以还是统一使用<code>mapGetters</code>更加方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vuex-source-code-mapGetters.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上一篇分析了获取&lt;code&gt;Vuex&lt;/code&gt;中的&lt;code&gt;state&lt;/code&gt;的Api————&lt;code&gt;mapState&lt;/code&gt;，这一篇继续分析获取&lt;code&gt;getters&lt;/code&gt;的Api————&lt;code&gt;mapGetters&lt;/code&gt;，它其实与&lt;code&gt;mapState&lt;/code&gt;类似，下面看一下源码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://yixirumeng.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vuex源码分析三 ———— mapState</title>
    <link href="http://yixirumeng.github.io/2019/01/14/vuex-source-code-mapState/"/>
    <id>http://yixirumeng.github.io/2019/01/14/vuex-source-code-mapState/</id>
    <published>2019-01-14T01:31:29.000Z</published>
    <updated>2019-01-24T12:38:44.532Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vuex-source-code-mapState.jpg" alt=""></p><blockquote><p>之前的两篇文章介绍了<code>Vuex</code>的内部过程以及实现原理，其暴露出来的方法基本上能满足日常的开发使用，但是如果都按着<code>this.$store</code>的这种写法，会很复杂。而<code>Vuex</code>也提供了很多简便操作的Api，下面的这几篇文章就分别分析一下每个Api的源码，并结合实例说明一下。</p></blockquote><a id="more"></a><p>这篇先介绍第一个Api————<code>mapState</code>，它主要是为了方便我们操作<code>state</code>而应用的。在分析源码之前，先要看几个公共方法，了解它们对分析这几个Api很重要（之后的几个Api都会用到这几个方法，如果忘了可以回头来看看）。</p><h3 id="normalizeNamespace"><a href="#normalizeNamespace" class="headerlink" title="normalizeNamespace"></a>normalizeNamespace</h3><p><code>normalizeNamespace</code>函数其实是个高阶函数，它以函数<code>fn</code>作为参数，然后返回一个函数，然后对返回的这个函数进行参数校验，如果第一个参数不是<code>string</code>类型，则将其设置为第二个参数<code>map</code>的值，本身成为空的字符串。如果是<code>string</code>类型，则进行一下拼接处理之后再使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params"><span class="keyword">namespace</span>, map</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">namespace</span> !== <span class="string">'string'</span>) &#123;</span><br><span class="line">            map = <span class="keyword">namespace</span></span><br><span class="line">            <span class="keyword">namespace</span> = <span class="string">''</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">namespace</span>.charAt(<span class="keyword">namespace</span>.length - <span class="number">1</span>) !== <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">namespace</span> += <span class="string">'/'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn(<span class="keyword">namespace</span>, map)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="normalizeMap"><a href="#normalizeMap" class="headerlink" title="normalizeMap"></a>normalizeMap</h3><p><code>normalizeMap</code>方法对传入的参数进行校验，如果是数组，则遍历这个数组，并将其每个元素处理为对象的形式；如果为<code>Object</code>，也会遍历，并组合成一个对象数组进行返回。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function normalizeMap (<span class="built_in">map</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">Array</span>.isArray(<span class="built_in">map</span>)</span><br><span class="line">        ? <span class="built_in">map</span>.<span class="built_in">map</span>(<span class="built_in">key</span> =&gt; (&#123; <span class="built_in">key</span>, val: <span class="built_in">key</span> &#125;))</span><br><span class="line">        : <span class="keyword">Object</span>.keys(<span class="built_in">map</span>).<span class="built_in">map</span>(<span class="built_in">key</span> =&gt; (&#123; <span class="built_in">key</span>, val: <span class="built_in">map</span>[<span class="built_in">key</span>] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getModuleByNamespace"><a href="#getModuleByNamespace" class="headerlink" title="getModuleByNamespace"></a>getModuleByNamespace</h3><p><code>getModuleByNamespace</code>方法主要就是对命名空间进行一下校验，可以暂时不用太过考虑这个方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getModuleByNamespace (store, helper, <span class="keyword">namespace</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">module</span> = store._modulesNamespaceMap[<span class="keyword">namespace</span>]</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">process</span>.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !<span class="keyword">module</span>) &#123;</span><br><span class="line">        console.error(`[vuex] <span class="keyword">module</span> <span class="keyword">namespace</span> <span class="keyword">not</span> found in $&#123;helper&#125;(): $&#123;<span class="keyword">namespace</span>&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上面这几个方法都是辅助函数，在Api中都会用到，不明白的时候可以翻上去看一下。</p><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><p>还记得上面的<code>normalizeNamespace</code>方法吗，它的参数是一个函数，也就是下面定义的这个函数，而平时我们在使用<code>mapState</code>的时候，传入的参数正是传入到<code>normalizeNamespace</code>返回的方法中。如果不考虑命名空间的话，<code>normalizeNamespace</code>返回的方法最终将处理完的参数传入到下面定义的这个函数中。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    所以，下面的namespace和states分别为空字符串和我们传入的参数</span><br><span class="line">*/</span><br><span class="line">const mapState = normalizeNamespace((namespace, states) =&gt; &#123;</span><br><span class="line">    const res = &#123;&#125;</span><br><span class="line">    /*</span><br><span class="line">        这里调用了一下normalizeMap方法，经过上面分析</span><br><span class="line">        它会对参数进行判断，然后转换成对象数组</span><br><span class="line">        接下来进行遍历，然后再判断参数是否为函数</span><br><span class="line">        并进行最终的返回</span><br><span class="line">    */</span><br><span class="line">    normalizeMap(states).<span class="keyword">for</span>Each((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">        res[key] = function mappedState () &#123;</span><br><span class="line">        let <span class="keyword">state</span> = this.<span class="variable">$store</span>.<span class="keyword">state</span></span><br><span class="line">        let getters = this.<span class="variable">$store</span>.getters</span><br><span class="line">        if (namespace) &#123;</span><br><span class="line">            const module = getModuleByNamespace(this.<span class="variable">$store</span>, 'mapState', namespace)</span><br><span class="line">            if (!module) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">state</span> = module.context.<span class="keyword">state</span></span><br><span class="line">            getters = module.context.getters</span><br><span class="line">        &#125;</span><br><span class="line">        return typeof val === 'function'</span><br><span class="line">            ? val.call(this, <span class="keyword">state</span>, getters)</span><br><span class="line">            : <span class="keyword">state</span>[val]</span><br><span class="line">        &#125;</span><br><span class="line">        res[key].vuex = true</span><br><span class="line">    &#125;)</span><br><span class="line">    // mark vuex getter <span class="keyword">for</span> devtools</span><br><span class="line">    return res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>根据上面的分析，在调用<code>mapState</code>时，可以传入数组或者是对象，因为内部会做处理，最终根据不同类型来导出不同的结果。而最终还是应用<code>this.$store</code>去获取对应的值。</p><h3 id="mapState在Vue组件中的应用"><a href="#mapState在Vue组件中的应用" class="headerlink" title="mapState在Vue组件中的应用"></a>mapState在Vue组件中的应用</h3><p>还是使用上一篇定义的<code>Vuex</code></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; num &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    import &#123; mapState &#125; from 'vuex'</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    export default &#123;</span></span><br><span class="line"><span class="xml">        computed: &#123;</span></span><br><span class="line"><span class="xml">            ...mapState(['num'])</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        mounted()&#123;</span></span><br><span class="line"><span class="xml">            console.log(this.num)</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>经过上面源码的分析可知，这里传入的参数是个数组，所以经过<code>normalizeMap</code>转换后得到的对象是<code>[{key: &#39;num&#39;, val: &#39;num&#39;}]</code>，遍历后进行判断，因为<code>val</code>不是<code>function</code>，所以直接调用<code>this.$store.state.num</code>，最终返回的是一个对象<code>{num: 1}</code>。上面的<code>computed</code>中应用了<code>...</code>结构，最终会把<code>num</code>放入到<code>computed</code>中。</p><p>在应用<code>mapState</code>的时候，也可以传入对象，即<code>mapState({num: &#39;num&#39;})</code>，如果想给参数换个名字可以是<code>mapState({ber: &#39;num&#39;})</code>，这样调用<code>this.ber</code>就可以获取到<code>num</code>的值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>mapState</code>方法主要为了方便我们在开发的时候进行操作，不用每次获取变量都要写<code>this.$store.state</code>，它可以接收数组或者对象作为参数，但观察其内部，依然是通过<code>this.$store.state</code>来操作，毕竟不能脱离定义的<code>Store</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vuex-source-code-mapState.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前的两篇文章介绍了&lt;code&gt;Vuex&lt;/code&gt;的内部过程以及实现原理，其暴露出来的方法基本上能满足日常的开发使用，但是如果都按着&lt;code&gt;this.$store&lt;/code&gt;的这种写法，会很复杂。而&lt;code&gt;Vuex&lt;/code&gt;也提供了很多简便操作的Api，下面的这几篇文章就分别分析一下每个Api的源码，并结合实例说明一下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://yixirumeng.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vuex源码分析二 ———— 结合实例分析Store</title>
    <link href="http://yixirumeng.github.io/2019/01/11/vuex-source-code-example/"/>
    <id>http://yixirumeng.github.io/2019/01/11/vuex-source-code-example/</id>
    <published>2019-01-11T12:17:03.000Z</published>
    <updated>2019-01-24T12:39:02.685Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vuex-source-code-example.jpg" alt=""></p><blockquote><p>上一篇详细分析了<code>Store</code>的源码以及其实例化的具体过程，这一篇结合具体例子来分析，进一步了解<code>Vuex</code>的具体过程</p></blockquote><a id="more"></a><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>先写一个整体的<code>Vuex</code>，下面的<code>Vue</code>组件都会用到</p><p>store.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import Vue <span class="keyword">from</span> 'vue'</span><br><span class="line">import Vuex <span class="keyword">from</span> 'vuex'</span><br><span class="line">import <span class="keyword">state</span> <span class="keyword">from</span> './<span class="keyword">state</span>'</span><br><span class="line">import getters <span class="keyword">from</span> './getters'</span><br><span class="line">import actions <span class="keyword">from</span> './actions'</span><br><span class="line">import mutations <span class="keyword">from</span> './mutations'</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    经过源码分析可知，实例化Store会对下面传入的属性</span><br><span class="line">    进行处理，将<span class="keyword">state</span>、getters挂载到组件上，而actions</span><br><span class="line">    和mutations内定义的方法会存入对应的数组中，当调用</span><br><span class="line">    dispatch时会去actions数组中找到对应的处理函数，</span><br><span class="line">    而commit会去mutations中找到对应的处理函数</span><br><span class="line">*/</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    <span class="keyword">state</span>,</span><br><span class="line">    getters,</span><br><span class="line">    actions,</span><br><span class="line">    mutations</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>state.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    这里<span class="keyword">state</span>也可以定义为function</span><br><span class="line">    源码中可以知道，会判断是否为函数，</span><br><span class="line">    如果为函数会默认执行</span><br><span class="line">*/</span><br><span class="line">const <span class="keyword">state</span> = &#123;</span><br><span class="line">    num: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">const <span class="keyword">state</span> = () =&gt; (&#123;num: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="keyword">state</span></span><br></pre></td></tr></table></figure><p>getters.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    根据源码可以知道，getters中的每个getter都可以接收四个参数</span><br><span class="line">    因为没定义命名空间，所以<span class="keyword">state</span>和rootState一样，而getters</span><br><span class="line">    和rootGetters一样</span><br><span class="line">*/</span><br><span class="line">const getters = &#123;</span><br><span class="line">    num: (<span class="keyword">state</span>, getters, rootState, rootGetters) =&gt; &#123;</span><br><span class="line">        return <span class="keyword">state</span>.num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> getters</span><br></pre></td></tr></table></figure><p>actions.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    根据源码可知，每个action都会接收到一个有六个属性的对象参数</span><br><span class="line">    可以分别进行操作，所以action可以commit一个或多个mutation</span><br><span class="line">    也可以dispatch其它action，当然也可以处理<span class="keyword">state</span>、getters</span><br><span class="line">    但是只能在mutation中进行更改</span><br><span class="line">    这里的payload则是传入到action中的数据</span><br><span class="line">*/</span><br><span class="line">const actions = &#123;</span><br><span class="line">    increment: (&#123;</span><br><span class="line">        dispatch, </span><br><span class="line">        commit, </span><br><span class="line">        getters, </span><br><span class="line">        <span class="keyword">state</span>, </span><br><span class="line">        rootGetters, </span><br><span class="line">        rootState&#125;, payload) =&gt; &#123;</span><br><span class="line">        commit('INCREMENT')</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> actions</span><br></pre></td></tr></table></figure><p>mutations.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    源码分析后可知，每个mutation都会接收两个参数</span><br><span class="line">    即<span class="keyword">state</span>和要传入的数据</span><br><span class="line">*/</span><br><span class="line">const mutations = &#123;</span><br><span class="line">    ['INCREMENT']: (<span class="keyword">state</span>, payload) =&gt; &#123;</span><br><span class="line">        <span class="keyword">state</span>.num ++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> mutations</span><br></pre></td></tr></table></figure><h3 id="Vue组件1"><a href="#Vue组件1" class="headerlink" title="Vue组件1"></a>Vue组件1</h3><p>根据分析，实例化<code>Store</code>会将<code>state</code>、<code>getters</code>挂载到组件实例上，所以下面<code>this.$store.state.num</code>会调用<code>Store</code>的<code>get</code>方法访问到<code>state</code>，而<code>this.$store.getters.num</code>会直接拿到对应的<code>getter</code></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;template&gt;</span></span><br><span class="line">    <span class="variable">&lt;div&gt;</span></span><br><span class="line">        <span class="variable">&lt;div&gt;</span>&#123;&#123; <span class="variable">$store</span>.<span class="keyword">state</span>.num &#125;&#125;&lt;/div&gt;</span><br><span class="line">        <span class="variable">&lt;div&gt;</span>&#123;&#123; <span class="variable">$store</span>.getters.num &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">&lt;script&gt;</span></span><br><span class="line">    export <span class="keyword">default</span> &#123;</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            console.<span class="keyword">log</span>(this.<span class="variable">$store</span>.<span class="keyword">state</span>.num)</span><br><span class="line">            console.<span class="keyword">log</span>(this.<span class="variable">$store</span>.getters.num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue组件2"><a href="#Vue组件2" class="headerlink" title="Vue组件2"></a>Vue组件2</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">/*</span></span><br><span class="line"><span class="xml">    这里因为是同步操作，可以直接commit mutation</span></span><br><span class="line"><span class="xml">    要更改state，只能调用mutation中的方法</span></span><br><span class="line"><span class="xml">*/</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; $store.state.num &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    export default &#123;</span></span><br><span class="line"><span class="xml">        methods: &#123;</span></span><br><span class="line"><span class="xml">            increment()&#123;</span></span><br><span class="line"><span class="xml">                this.$store.commit('INCREMENT')</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="Vue组件3"><a href="#Vue组件3" class="headerlink" title="Vue组件3"></a>Vue组件3</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">/*</span></span><br><span class="line"><span class="xml">    也可以先派发action，然后由action去commit mutation</span></span><br><span class="line"><span class="xml">    当有异步操作的时候，只能通过action去commit mutation</span></span><br><span class="line"><span class="xml">*/</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; $store.state.num &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    export default &#123;</span></span><br><span class="line"><span class="xml">        methods: &#123;</span></span><br><span class="line"><span class="xml">            increment()&#123;</span></span><br><span class="line"><span class="xml">                this.$store.dispatch('increment')</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当需要传递参数的时候，其写法是<code>this.$store.dispatch(&#39;increment&#39;, 3)</code>以及<code>this.$store.commit(&#39;INCREMENT&#39;, 3)</code>，这样就可以在<code>action</code>和<code>mutation</code>中拿到传来的数据了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据源码分析，又结合实际例子，可以很清晰的了解<code>Vuex</code>整个过程，以及每一步为什么要如此操作，其为什么会有这些参数。</p><p>之前分析过<code>Redux</code>，对比可以发现，<code>Vue</code>的<code>action</code>与<code>Redux</code>的<code>action</code>类似，而<code>mutation</code>则与<code>reducer</code>类似，所以副作用的操作都要放在<code>action</code>中，只有<code>mutation</code>、<code>reducer</code>是改变<code>state</code>的唯一途径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vuex-source-code-example.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上一篇详细分析了&lt;code&gt;Store&lt;/code&gt;的源码以及其实例化的具体过程，这一篇结合具体例子来分析，进一步了解&lt;code&gt;Vuex&lt;/code&gt;的具体过程&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://yixirumeng.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vuex源码分析一 ———— 初始化Store</title>
    <link href="http://yixirumeng.github.io/2019/01/05/vuex-source-code-Store/"/>
    <id>http://yixirumeng.github.io/2019/01/05/vuex-source-code-Store/</id>
    <published>2019-01-05T11:23:46.000Z</published>
    <updated>2019-01-24T12:38:36.185Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vuex-source-code-Store.jpg" alt=""></p><blockquote><p>前面的文章分析了<code>Redux</code>的源码和Api，作为前端三大框架的<code>Vue</code>当然也少不了状态管理工具——<code>Vuex</code>，下面的几篇文章就来对<code>Vuex</code>及其常用Api进行一下源码分析</p></blockquote><a id="more"></a><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>在平时开发使用<code>vuex</code>的时候，都会实例化一个<code>Store</code>，即<code>new Vuex.Store</code>，里面传入<code>state</code>、<code>getters</code>、<code>actions</code>，<code>mutations</code>等相关属性，正是在这个过程中，<code>vuex</code>会初始化<code>Store</code>，下面就来看一下<code>Store</code>这个类的源码（部分代码已删减，只保留核心功能），遇到调用的某个方法，请到下面查看对应的源码分析</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Store &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里的options就是传入的state、action等对象参数</span></span><br><span class="line"><span class="comment">            首先从中获取state，其可以为普通对象，也可以为一个函数</span></span><br><span class="line"><span class="comment">            如果是函数，则执行这个函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">let</span> &#123;</span><br><span class="line">            state = &#123;&#125;</span><br><span class="line">        &#125; = options</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> state === <span class="string">'function'</span>) &#123;</span><br><span class="line">            state = state() || &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            初始化一些属性，之所以用Object.create(null)不用&#123;&#125;</span></span><br><span class="line"><span class="comment">            是为了防止对象获取原型上的属性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">this</span>._committing = <span class="literal">false</span>    <span class="comment">//是否是正在commit状态</span></span><br><span class="line">        <span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ModuleCollection函数是来收集参数中的modules，也就是</span></span><br><span class="line"><span class="comment">            getters、actions、mutations等属性，具体可以看下面源码分析</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这一步的操作是改写dispatch、commit函数，开发时用到的方法</span></span><br><span class="line"><span class="comment">            正是在这里转换后的方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> store = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span> (<span class="params"><span class="keyword">type</span>, payload</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dispatch.call(store, <span class="keyword">type</span>, payload)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span> (<span class="params"><span class="keyword">type</span>, payload, options</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> commit.call(store, <span class="keyword">type</span>, payload, options)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里来加载上面获取到属性，可以查看下面installModule方法源码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里重新设置store</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        resetStoreVM(<span class="keyword">this</span>, state)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        get方法用来获取定义的state，也就是在开发时用到的</span></span><br><span class="line"><span class="comment">        this.$store.state...就是执行的这个方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">get</span> state () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._vm._data.$$state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        commit方法就是action要通知mutation时调用的方法</span></span><br><span class="line"><span class="comment">        其中unifyObjectStyle就是将type、payload、options</span></span><br><span class="line"><span class="comment">        等属性扁平化，使其成为一个plainObject</span></span><br><span class="line"><span class="comment">        最后在mutations中找到对应type的mutation，并将payload</span></span><br><span class="line"><span class="comment">        传入执行这个mutation</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    commit (_type, _payload, _options) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            payload,</span><br><span class="line">            options</span><br><span class="line">        &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> mutation = &#123; <span class="keyword">type</span>, payload &#125;</span><br><span class="line">        <span class="keyword">const</span> entry = <span class="keyword">this</span>._mutations[<span class="keyword">type</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">                handler(payload)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        dispatch是在派发一个action时执行的方法</span></span><br><span class="line"><span class="comment">        其原理跟commit方法基本类似，但是有个注意点，dispatch</span></span><br><span class="line"><span class="comment">        派发的可以不是一个action，可以是个数组，如果是数组</span></span><br><span class="line"><span class="comment">        则会遍历每一项，然后分别处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dispatch (_type, _payload) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            payload</span><br><span class="line">        &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> action = &#123; <span class="keyword">type</span>, payload &#125;</span><br><span class="line">        <span class="keyword">const</span> entry = <span class="keyword">this</span>._actions[<span class="keyword">type</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> entry.length &gt; <span class="number">1</span></span><br><span class="line">            ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</span><br><span class="line">            : entry[<span class="number">0</span>](payload)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        withCommit方法其实就是为了设置commit状态，起到一个开关作用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    _withCommit (fn) &#123;</span><br><span class="line">        <span class="keyword">const</span> committing = <span class="keyword">this</span>._committing</span><br><span class="line">        <span class="keyword">this</span>._committing = <span class="literal">true</span></span><br><span class="line">        fn()</span><br><span class="line">        <span class="keyword">this</span>._committing = committing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Store</code>类还是很简单的，其内部主要是做一些初始化的操作。下面来看看主要的函数源码：</p><h3 id="ModuleCollection"><a href="#ModuleCollection" class="headerlink" title="ModuleCollection"></a>ModuleCollection</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ModuleCollection类主要用来收集传入的属性</span></span><br><span class="line"><span class="comment">    在构造函数中调用register方法，根据上面的源码</span></span><br><span class="line"><span class="comment">    其中的rawRootModule就是options也就是传入的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (rawRootModule) &#123;</span><br><span class="line">        <span class="keyword">this</span>.register([], rawRootModule, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get (path) &#123;</span><br><span class="line">        <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params"><span class="built_in">module</span>, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>.getChild(key)</span><br><span class="line">        &#125;, <span class="keyword">this</span>.root)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getNamespace (path) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params">namespace, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">module</span> = <span class="built_in">module</span>.getChild(key)</span><br><span class="line">            <span class="keyword">return</span> namespace + (<span class="built_in">module</span>.namespaced ? key + <span class="string">'/'</span> : <span class="string">''</span>)</span><br><span class="line">        &#125;, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update (rawRootModule) &#123;</span><br><span class="line">        update([], <span class="keyword">this</span>.root, rawRootModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        register方法里实例化一个Module并将options传入</span></span><br><span class="line"><span class="comment">        同时设置一个属性，名为root执行实例化后的实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    register (path, rawModule, runtime = <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newModule = <span class="keyword">new</span> Module(rawModule, runtime)</span><br><span class="line">        <span class="keyword">this</span>.root = newModule</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Module类主要用来获取到options找那个的每个属性，并做处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (rawModule, runtime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.runtime = runtime</span><br><span class="line">        <span class="keyword">this</span>._children = Object.create(<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">this</span>._rawModule = rawModule</span><br><span class="line">        const rawState = rawModule.state</span><br><span class="line">        <span class="keyword">this</span>.state = (typeof rawState === <span class="string">'function'</span> ? rawState() : rawState) || &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> namespaced () &#123;</span><br><span class="line">        <span class="keyword">return</span> !!<span class="keyword">this</span>._rawModule.namespaced</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addChild (key, module) &#123;</span><br><span class="line">        <span class="keyword">this</span>._children[key] = module</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    removeChild (key) &#123;</span><br><span class="line">        delete <span class="keyword">this</span>._children[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getChild (key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._children[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update (rawModule) &#123;</span><br><span class="line">        <span class="keyword">this</span>._rawModule.namespaced = rawModule.namespaced</span><br><span class="line">        <span class="keyword">if</span> (rawModule.actions) &#123;</span><br><span class="line">            <span class="keyword">this</span>._rawModule.actions = rawModule.actions</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rawModule.mutations) &#123;</span><br><span class="line">            <span class="keyword">this</span>._rawModule.mutations = rawModule.mutations</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rawModule.getters) &#123;</span><br><span class="line">            <span class="keyword">this</span>._rawModule.getters = rawModule.getters</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forEachChild (fn) &#123;</span><br><span class="line">        forEachValue(<span class="keyword">this</span>._children, fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forEachGetter (fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._rawModule.getters) &#123;</span><br><span class="line">            forEachValue(<span class="keyword">this</span>._rawModule.getters, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forEachAction (fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._rawModule.actions) &#123;</span><br><span class="line">            forEachValue(<span class="keyword">this</span>._rawModule.actions, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forEachMutation (fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._rawModule.mutations) &#123;</span><br><span class="line">            forEachValue(<span class="keyword">this</span>._rawModule.mutations, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forEachValue"><a href="#forEachValue" class="headerlink" title="forEachValue"></a>forEachValue</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    forEachValue方法主要用来遍历对象，然后将对象的value、key作为参数</span></span><br><span class="line"><span class="comment">    传入到函数参数中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEachValue</span> (<span class="params">obj, fn</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> fn(obj[key], key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="installModule"><a href="#installModule" class="headerlink" title="installModule"></a>installModule</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    installModule方法主要用来安装传入的属性</span></span><br><span class="line"><span class="comment">    根据上面源码调用该方法的地方，传入的参数为</span></span><br><span class="line"><span class="comment">    installModule(this, state, [], this._modules.root)</span></span><br><span class="line"><span class="comment">    这里的this._modules.root正是在ModuleCollection中register方法中</span></span><br><span class="line"><span class="comment">    定义的，其值为Module实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span> (<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里先调用makeLocalContext方法获取到local值，主要是根据命名空间来获取</span></span><br><span class="line"><span class="comment">        除非较大的项目，平时较少用到命名空间，所以可以将local值看成就是store</span></span><br><span class="line"><span class="comment">        这里的namespace可以视为空字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> local = <span class="built_in">module</span>.context = makeLocalContext(store, <span class="keyword">namespace</span>, path)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        然后分别注册mutation、action、getter</span></span><br><span class="line"><span class="comment">        而forEachMutation、forEachAction、forEachGetter方法正是在module实例中</span></span><br><span class="line"><span class="comment">        定义的方法，而根据上面的分析，这里调用的registerMutation、registerAction、</span></span><br><span class="line"><span class="comment">        forEachGetter三个方法中传入的mutation、action、getter参数，正是在开发中</span></span><br><span class="line"><span class="comment">        定义的三个属性中对应的方法，也就是实际写的getters、actions、mutations中的</span></span><br><span class="line"><span class="comment">        每个方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> namespacedType = <span class="keyword">namespace</span> + key</span><br><span class="line">        registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">type</span> = action.root ? key : <span class="keyword">namespace</span> + key</span><br><span class="line">        <span class="keyword">const</span> handler = action.handler || action</span><br><span class="line">        registerAction(store, <span class="keyword">type</span>, handler, local)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> namespacedType = <span class="keyword">namespace</span> + key</span><br><span class="line">        registerGetter(store, namespacedType, getter, local)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="makeLocalContext"><a href="#makeLocalContext" class="headerlink" title="makeLocalContext"></a>makeLocalContext</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    makeLocalContext方法对store中的命名空间做了一层处理，如果设置了命名空间</span></span><br><span class="line"><span class="comment">    则会进一步向下获取，平时较少用到命名空间，所以可以把这步操作看成就是原始的store</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalContext</span> (<span class="params">store, <span class="keyword">namespace</span>, path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> noNamespace = <span class="keyword">namespace</span> === <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> local = &#123;</span><br><span class="line">        dispatch: noNamespace ? store.dispatch : <span class="function">(<span class="params">_type, _payload, _options</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">            <span class="keyword">const</span> &#123; payload, options &#125; = args</span><br><span class="line">            <span class="keyword">let</span> &#123; <span class="keyword">type</span> &#125; = args</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">                <span class="keyword">type</span> = <span class="keyword">namespace</span> + <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !store._actions[<span class="keyword">type</span>]) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown local action type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> store.dispatch(<span class="keyword">type</span>, payload)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        commit: noNamespace ? store.commit : <span class="function">(<span class="params">_type, _payload, _options</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">            <span class="keyword">const</span> &#123; payload, options &#125; = args</span><br><span class="line">            <span class="keyword">let</span> &#123; <span class="keyword">type</span> &#125; = args</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">                <span class="keyword">type</span> = <span class="keyword">namespace</span> + <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !store._mutations[<span class="keyword">type</span>]) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown local mutation type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            store.commit(<span class="keyword">type</span>, payload, options)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">        getters: &#123;</span><br><span class="line">            <span class="keyword">get</span>: noNamespace</span><br><span class="line">                ? <span class="function"><span class="params">()</span> =&gt;</span> store.getters</span><br><span class="line">                : <span class="function"><span class="params">()</span> =&gt;</span> makeLocalGetters(store, <span class="keyword">namespace</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        state: &#123;</span><br><span class="line">            <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> getNestedState(store.state, path)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> local</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerMutation、registerAction、registerGetter"><a href="#registerMutation、registerAction、registerGetter" class="headerlink" title="registerMutation、registerAction、registerGetter"></a>registerMutation、registerAction、registerGetter</h3><p>这三个方法是初始化的核心方法，是来处理我们自定义的三个队属性</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    registerMutation方法会在初始化属性_mutations中定义一个对应type的mutations</span><br><span class="line">    其初始为一个空数组，并把我们自定义的mutation转换成一个函数push到这个数组中</span><br><span class="line">*/</span><br><span class="line">function registerMutation (store, type, handler, local) &#123;</span><br><span class="line">    const entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line">    entry.push(function wrappedMutationHandler (payload) &#123;</span><br><span class="line">        /*</span><br><span class="line">            调用每个mutation传入了参数local.<span class="keyword">state</span>、payload</span><br><span class="line">            这样就是我们在写mutation时，可以在方法参数中获取到<span class="keyword">state</span>，以及要传过来</span><br><span class="line">            的数据</span><br><span class="line">        */</span><br><span class="line">        handler.call(store, local.<span class="keyword">state</span>, payload)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    registerMutation方法会在初始化属性_actions中定义一个对应type的actions</span><br><span class="line">    其初始为一个空数组，并把我们自定义的action转换成一个函数push到这个数组中</span><br><span class="line">    这里做了一个isPromise校验，这样也就使得我们在定义异步操作时，要放在action中</span><br><span class="line">*/</span><br><span class="line">function registerAction (store, type, handler, local) &#123;</span><br><span class="line">    const entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">    entry.push(function wrappedActionHandler (payload, cb) &#123;</span><br><span class="line">        /*</span><br><span class="line">            调用每个action时，传入了local.dispatch、local.commit、</span><br><span class="line">            local.getters、local.<span class="keyword">state</span>、store.getters、store.<span class="keyword">state</span>，</span><br><span class="line">            并重新进行命名这也就是我们在写action时，可以获取到对应的属性，</span><br><span class="line">            如果没有定义命名空间，则local.getters和store.getters一样，</span><br><span class="line">            local.<span class="keyword">state</span>和store.<span class="keyword">state</span>一样</span><br><span class="line">        */</span><br><span class="line">        let res = handler.call(store, &#123;</span><br><span class="line">            dispatch: local.dispatch,</span><br><span class="line">            commit: local.commit,</span><br><span class="line">            getters: local.getters,</span><br><span class="line">            <span class="keyword">state</span>: local.<span class="keyword">state</span>,</span><br><span class="line">            rootGetters: store.getters,</span><br><span class="line">            rootState: store.<span class="keyword">state</span></span><br><span class="line">        &#125;, payload, cb)</span><br><span class="line">        if (!isPromise(res)) &#123;</span><br><span class="line">            res = Promise.resolve(res)</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    registerGetter方法会根据对应的type找到getter，其值为一个方法，</span><br><span class="line">    最后调用rawGetter方法，也就是我们自定义的getter</span><br><span class="line">*/</span><br><span class="line">function registerGetter (store, type, rawGetter, local) &#123;</span><br><span class="line">    store._wrappedGetters[type] = function wrappedGetter (store) &#123;</span><br><span class="line">        /*</span><br><span class="line">            这里传入了local.<span class="keyword">state</span>、local.getters、store.<span class="keyword">state</span>、</span><br><span class="line">            store.getters四个参数，如果没有定义命名空间，</span><br><span class="line">            则local.getters和store.getters一样，</span><br><span class="line">            local.<span class="keyword">state</span>和store.<span class="keyword">state</span>一样</span><br><span class="line">            这里注意一下，上面是传入一个对象，而这里是作为单独参数</span><br><span class="line">            分别传入</span><br><span class="line">        */</span><br><span class="line">        return rawGetter(</span><br><span class="line">            local.<span class="keyword">state</span>, // local <span class="keyword">state</span></span><br><span class="line">            local.getters, // local getters</span><br><span class="line">            store.<span class="keyword">state</span>, // root <span class="keyword">state</span></span><br><span class="line">            store.getters // root getters</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resetStoreVM"><a href="#resetStoreVM" class="headerlink" title="resetStoreVM"></a>resetStoreVM</h3><p>resetStoreVM方法其实很简单，主要是将state、getters挂载到vue实例上，并且将旧的vm卸载，使用新的vm</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span> (<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldVm = store._vm</span><br><span class="line">    store.getters = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line">    <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">    forEachValue(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">        computed[key] = <span class="function"><span class="params">()</span> =&gt;</span> fn(store)</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">            <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> store._vm[key],</span><br><span class="line">            enumerable: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这一步的操作可以知道，我们在开发的过程中，即使没在</span></span><br><span class="line"><span class="comment">        computed中定义getter，也可以用this.$store.getter</span></span><br><span class="line"><span class="comment">        获取到自定义的getter</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            $$state: state</span><br><span class="line">        &#125;,</span><br><span class="line">        computed</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldVm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">            store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                oldVm._data.$$state = <span class="literal">null</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        Vue.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上面整体的源码分析，可以看出<code>Vuex</code>的内部逻辑并没有特别复杂，它会将我们自定义的<code>state</code>、<code>getters</code>、<code>actions</code>、<code>mutations</code>分别进行的处理，然后放入到<code>Store</code>中，而每次要做出相应的变化，都要调用<code>dispatch</code>、<code>commit</code>方法。</p><p>下一篇会结合具体实例来进一步分析一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vuex-source-code-Store.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前面的文章分析了&lt;code&gt;Redux&lt;/code&gt;的源码和Api，作为前端三大框架的&lt;code&gt;Vue&lt;/code&gt;当然也少不了状态管理工具——&lt;code&gt;Vuex&lt;/code&gt;，下面的几篇文章就来对&lt;code&gt;Vuex&lt;/code&gt;及其常用Api进行一下源码分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://yixirumeng.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>2018年个人总结</title>
    <link href="http://yixirumeng.github.io/2018/12/31/2018-summary/"/>
    <id>http://yixirumeng.github.io/2018/12/31/2018-summary/</id>
    <published>2018-12-31T11:13:27.000Z</published>
    <updated>2018-12-31T13:13:40.078Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/2018-summary.jpg" alt=""></p><blockquote><p>2018年的最后一天，对这一年的经历和收获做一下总结，为2018画上完美的句号。</p></blockquote><a id="more"></a><h2 id="2018这一年经历了很多事情，分成几个类别说说一下吧。"><a href="#2018这一年经历了很多事情，分成几个类别说说一下吧。" class="headerlink" title="2018这一年经历了很多事情，分成几个类别说说一下吧。"></a>2018这一年经历了很多事情，分成几个类别说说一下吧。</h2><h3 id="在冷嘲中成长"><a href="#在冷嘲中成长" class="headerlink" title="在冷嘲中成长"></a>在冷嘲中成长</h3><p>在之前公司的研发团队里，90%的同事都是java工程师，其中也包括领导，而我则是一名web前端工程师，这也就导致了前端这个职位并不会受到更多的重视，因为做java肯定也会写html、js，就算不会用vue、react等主流框架，jquery也一定会用，而css也有现成的UI框架，拿过来直接可以用，这难免会认为前端的工作很简单，而且也是可替代的，前端更多时候是去调一些不太好弄的样式。虽然项目都是前后端分离是开发，前端的工作已经复杂了很多，后台得到工作变得稍微轻松一些，但即使这样，前端依然没有“地位”。</p><p>做过前端开发的同学应该都知道，其实前端的工作真的不简单，并不是拿一些UI框架拼拼凑凑，用jqeury写一些ajax这么简单，需要用到的知识也很多、很复杂。</p><p>刚开始自己心里也很难受，但慢慢的明白了，难受并不能解决实际问题，让自己强大起来才会不被冷嘲，当某一天不管前端、后台、运维等等的知识都能拿起来，分配什么工作都能做，哪一方面都不是外行，不用去刻意表现什么，自然就会有人来找你。</p><p>说下来，我还要感谢之前的领导，让我成长了很多，让我真正感受到了职场的冷暖，也让我找到了应该努力的方向，只有不断学习、不断实践才能够提升自己、丰富自己，让自己强大。</p><h3 id="2018学习到知识"><a href="#2018学习到知识" class="headerlink" title="2018学习到知识"></a>2018学习到知识</h3><p>2018这一年，学习了很多知识，不管在工作中，还是平时，都让自己感觉很充实，以下简单总结一下：</p><p>1、深入学习了<code>vue</code>、<code>react</code>两个主流框架，尤其是<code>react</code>，因为目前的工作正在使用，并跟随主流学习了新的特性，将其应用到实际问题中。</p><p>2、深入学习了<code>redux</code>状态管理工具，以及相关的<code>reselect</code>、<code>redux-thunk</code>、<code>redux-actions</code>、<code>redux-saga</code>、<code>redux-promise</code>等中间件。</p><p>3、阅读并分析了<code>redux</code>、<code>redux-thunk</code>、<code>reselect</code>、<code>redux-actions</code>、<code>fastclick</code>的源码，并写了相应的博客（翻看之前的文章就能查阅），同时也阅读<code>vue</code>、<code>react</code>、<code>react-router4</code>的部分源码，因为框架本身也是很庞大的，所以还需要再进一步学习和分析。</p><p>4、巩固了很多基础知识，通过实际工作以及学习，明白了框架再多、新的东西再丰富都离不开基础，这往往也是最容易被忽视的，所以打好基础是重中之重。</p><p>5、学习了如前端缓存、代码优化、性能优化等等前端相关的知识。</p><p>6、学习了新的一门语言java，因为身边的后端都是java开发，再加上自己也很有兴趣，所以在学习前端的同时，也学习了<code>java基础</code>、<code>springmvc</code>、<code>springboot</code>、<code>mybatis</code>、<code>sql</code>、<code>redis</code>、<code>mysql</code>等<code>java</code>相关的知识，并用学到的知识做了项目。这里要非常感谢自己身边的同事，每次遇到问题都不厌其烦的教我，非常感谢！</p><p>7、学习了简单的运维知识，<code>nginx部署</code>、<code>nginx配置</code>、<code>tomcat部署</code>、<code>部分linux</code>，同时了解了<code>redis集群</code>、分布式等知识。</p><p>其实还有很多没有列举，但总之这一年的收获还是很丰富的。</p><h3 id="面试也是一种提升"><a href="#面试也是一种提升" class="headerlink" title="面试也是一种提升"></a>面试也是一种提升</h3><p>2018这一年，经历了10余次面试，每次面试可能还会有二面、三面。碰到的面试官都很优秀，也问到了很多我不是很了解的问题，让我知道了自身不足的地方，以及应该加强学习的地方。虽然最终因为各种原因没有在一起工作（只能选择一家公司嘛），但我还是要感谢这些面试官，让我发现不足，多多学习，进一步提升自己。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>在这一年中，共接手了两个大的项目（其实还有一些小的项目），第一个项目是用<code>vue</code>做的，第二个项目是用<code>react</code>做的，总体来说完成的可以，没有出现重大的问题，有一些小的bug是正常的，因为程序是不能0bug的。在这两个项目中，经历过很多问题，最终通过查阅资料、实践、交流都解决了，也已经上线到生产环境了。</p><p>工作中出现问题是难免的，不可能是一帆风顺的，当想办法解决这些问题的时候，也正是提升自己的时候，这也就是俗话说的，“提升自身往往是在不断填坑”。</p><h3 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h3><p>整体下来，2018对我来说是个收获之年，学习了很多很多知识、实践了很多项目、解决了很多问题，我觉得对我来说最大的收获是：<strong>不论到任何时候都要学习，不学习就是在让社会淘汰自己</strong>。在马上要到来的2019年，我还是会坚持自己的目标，不断学习、不断实践，让自己进步。</p><h3 id="2019目标"><a href="#2019目标" class="headerlink" title="2019目标"></a>2019目标</h3><p>对于2019年的目标，目前分为以下几方面：</p><p>1、继续巩固基础知识，阅读红宝石、犀牛书、es6等基础相关的书籍。</p><p>2、进一步深入学习<code>vue</code>、<code>react</code>等框架，并阅读其源码，理解内部原理、思想。</p><p>3、阅读在工作中常用工具的源码，明白底层实现原理，使得在应用中更加得心应手。</p><p>4、进一步学习小程序、<code>react-native</code>、<code>flutter</code>等知识，并做出相关的项目，学习与实践相配合。</p><p>5、深入学习<code>java</code>、<code>springboot</code>、<code>springcloud</code>、<code>redis</code>、<code>数据库</code>，并写出与web、小程序、app交互的后台，并学习分布式、微服务、集群、高可用、高并发等知识。</p><p>6、学习运维相关知识，<code>linux</code>、<code>nginx</code>、<code>redis</code>、<code>docker</code>、<code>kubernetes</code>、<code>ELK</code>、集群等知识</p><p>7、跟随主流，学习最新最前沿的技术。</p><p>8、与身边的人多交流、多沟通，相互分享，相互提升。</p><p>9、其实也是最最重要的一条，多散步锻炼，学习游泳，有一个好的身体才能写出好的程序，在学习的同时，也要学会休息，放松自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/2018-summary.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2018年的最后一天，对这一年的经历和收获做一下总结，为2018画上完美的句号。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="2018summary" scheme="http://yixirumeng.github.io/tags/2018summary/"/>
    
  </entry>
  
  <entry>
    <title>ES5、ES6分别实现继承，以及说明两者的区别（Javascript知识点总结二）</title>
    <link href="http://yixirumeng.github.io/2018/12/26/es5-and-es6-extends/"/>
    <id>http://yixirumeng.github.io/2018/12/26/es5-and-es6-extends/</id>
    <published>2018-12-26T11:23:18.000Z</published>
    <updated>2018-12-31T13:09:57.725Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/es5-and-es6-extends.jpg" alt=""></p><blockquote><p>ES5和ES6都可以实现继承，但是两者实现的方式是不一样的，下面分别用代码实现一下，并说明它们的区别</p></blockquote><a id="more"></a><h3 id="ES5实现继承的方式有多种，但是每种的含义都不一样"><a href="#ES5实现继承的方式有多种，但是每种的含义都不一样" class="headerlink" title="ES5实现继承的方式有多种，但是每种的含义都不一样"></a>ES5实现继承的方式有多种，但是每种的含义都不一样</h3><h4 id="一、原型链实现继承"><a href="#一、原型链实现继承" class="headerlink" title="一、原型链实现继承"></a>一、原型链实现继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">child.showAge()  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>实现原理：子类的原型对象指向父类的实例来实现继承，也就是重写子类的原型，但这种方式无法实现多继承</p><h4 id="二、call-apply方法改变函数上下文实现继承"><a href="#二、call-apply方法改变函数上下文实现继承" class="headerlink" title="二、call/apply方法改变函数上下文实现继承"></a>二、call/apply方法改变函数上下文实现继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">this</span>.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="comment">//Parent.apply(this, name)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.showCurrentAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        <span class="keyword">this</span>.showAge()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'Queen'</span>)</span><br><span class="line"></span><br><span class="line">child.showCurrentAge()                      <span class="comment">// Queen 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child.constructor === Child)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>实现原理：改变函数内部的函数上下文this，使它指向传入函数的具体对象，其实就是将父类的this指向子类。但这种方式不能继承父类的原型链</p><h4 id="三、结合以上两种方式，共同实现继承"><a href="#三、结合以上两种方式，共同实现继承" class="headerlink" title="三、结合以上两种方式，共同实现继承"></a>三、结合以上两种方式，共同实现继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.showSex = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.showInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">        <span class="keyword">this</span>.showName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'Queen'</span>)</span><br><span class="line"></span><br><span class="line">child.showInfo()    <span class="comment">//18  Queen</span></span><br><span class="line">child.showSex()     <span class="comment">//man</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line">Child.prototype.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'Queen'</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">child.showName()    <span class="comment">//Queen</span></span><br><span class="line">child.showAge()     <span class="comment">//18</span></span><br></pre></td></tr></table></figure><p>实现原理：这种方式是结合了以上两种的原理共同实现的，既可以实现多继承，也可以继承父类的原型链</p><h3 id="ES6实现继承"><a href="#ES6实现继承" class="headerlink" title="ES6实现继承"></a>ES6实现继承</h3><p>ES6实现继承的方式很简单，其定义了<code>extends</code>关键字，可以方便实现继承</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showName()&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    constructor(name, age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showAge()&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const child = <span class="keyword">new</span> <span class="type">Child</span>(<span class="symbol">'Quee</span>n', <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">child.showName()    <span class="comment">//Queen</span></span><br><span class="line">child.showAge()     <span class="comment">//18</span></span><br></pre></td></tr></table></figure><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>两者实现继承的方式和内部的原理是不一样的，引用阮大大的话：ES5实现继承是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上（<code>Parent.call(this)</code>）。ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上，所以必须调用<code>super</code>方法，然后子类的构造函数修改<code>this</code>。</p><p>这里有几点需要注意：</p><p>1、如果子类继承父类，但内部不写构造函数的话，构造函数是会被默认添加的，即：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果在子类中写了构造函数，则必须先调用<code>super</code>之后，才可以使用<code>this</code>，否则会报错。这是因为子类实例的构建，是基于父类实例，只有<code>super</code>方法才能调用到父类的实例，即：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor(x, y, color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、父类的静态方法，也会被子类继承，即：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    static hello() &#123;</span><br><span class="line">        console.log(<span class="symbol">'hello</span> world');</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>.hello()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>参考文章：<a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/class-extends</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/es5-and-es6-extends.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ES5和ES6都可以实现继承，但是两者实现的方式是不一样的，下面分别用代码实现一下，并说明它们的区别&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="javascript" scheme="http://yixirumeng.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript知识点总结一（持续更新...）</title>
    <link href="http://yixirumeng.github.io/2018/12/20/javascript-summary-of-knowledge-summary1/"/>
    <id>http://yixirumeng.github.io/2018/12/20/javascript-summary-of-knowledge-summary1/</id>
    <published>2018-12-20T13:33:58.000Z</published>
    <updated>2018-12-31T13:08:57.975Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/javascript-summary-of-knowledge-summary1.jpg" alt=""></p><blockquote><p>从这篇文章开始，将对js的知识点进行总结，主要是在日常开发与学习中遇到的知识，会对其进行解释说明，每篇包含几个知识点，如果知识点复杂会单独列出一篇。此类文章将不断更新。（因js过于强大，且每个人在开发时都会遇到各种各样的问题，这里写的更多是自己遇到过的，所以此类文章主要作为自己学习后的知识总结。）</p></blockquote><a id="more"></a><h3 id="一、以变量作为对象的key，其内部实现原理"><a href="#一、以变量作为对象的key，其内部实现原理" class="headerlink" title="一、以变量作为对象的key，其内部实现原理"></a>一、以变量作为对象的key，其内部实现原理</h3><p>以前在开发时，如果对象的key为变量，一般的写法为<code>obj[variable]</code>，es6之后可以直接在对象中用<code>[]</code>将变量包起来，即<code>{ [variable]: &#39;hello&#39; }</code>，这两种写法，其实是调用了<code>variable</code>的<code>toString</code>方法，将其转换为字符串后放入。所以，不管是基本类型还是引用类型，都是一样的。看几个例子：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="meta">arr</span>]: <span class="string">'hello number'</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(obj)</span><br><span class="line"></span><br><span class="line">这里得到的obj为：&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>: <span class="string">'hello number'</span> &#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; a: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    [<span class="meta">obj1</span>]: <span class="string">'hello object'</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(obj2)</span><br><span class="line"></span><br><span class="line">这里得到的obj2为：&#123; [<span class="keyword">object</span>,Object]: <span class="string">'hello object'</span> &#125;</span><br></pre></td></tr></table></figure><p>这里分别调用了数组和对象的<code>toString</code>方法来进行转换。</p><h3 id="二、原生JS实现数组的map方法"><a href="#二、原生JS实现数组的map方法" class="headerlink" title="二、原生JS实现数组的map方法"></a>二、原生JS实现数组的map方法</h3><p>数组的<code>map</code>方法包含接收两个参数，第一个为函数，其参数分别为当前项、当前项索引、当前项所属的数组，第二个为<code>this</code>的指向，一般不用传递。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.prototype.map1 = <span class="function"><span class="keyword">function</span></span>(callback, context)&#123;</span><br><span class="line">    const arr = <span class="built_in">this</span></span><br><span class="line">    let <span class="keyword">new</span><span class="type">Arr</span> = []</span><br><span class="line">    <span class="keyword">for</span>(let i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        let <span class="keyword">new</span><span class="type">Value</span> = callback.call(context, arr[i], i, arr)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Arr</span>.push(<span class="keyword">new</span><span class="type">Value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Arr</span></span><br><span class="line"><span class="type"></span>&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.map1(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)    <span class="comment">//[4, 5, 6, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">//[5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="三、reduce实现数组map方法"><a href="#三、reduce实现数组map方法" class="headerlink" title="三、reduce实现数组map方法"></a>三、reduce实现数组map方法</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.prototype.map2 = <span class="function"><span class="keyword">function</span></span>(callback, context)&#123;</span><br><span class="line">    const arr = <span class="built_in">this</span></span><br><span class="line">    const <span class="keyword">new</span><span class="type">Arr</span> = arr.reduce((total, currentValue, currentIndex) =&gt; &#123;</span><br><span class="line">        let <span class="keyword">new</span><span class="type">Value</span> = callback.call(context, currentValue, currentIndex, arr)</span><br><span class="line">        <span class="keyword">return</span> total.concat(<span class="keyword">new</span><span class="type">Value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Arr</span></span><br><span class="line"><span class="type"></span>&#125;</span><br></pre></td></tr></table></figure><p>例子跟上面一样的，这里都没做参数类型判断，基本原理都写出来了</p><h3 id="四、js的new操作符都做了什么"><a href="#四、js的new操作符都做了什么" class="headerlink" title="四、js的new操作符都做了什么"></a>四、js的new操作符都做了什么</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="keyword">Func</span><span class="params">()</span>&#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">func</span> = <span class="title">new</span> <span class="title">Func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><code>new</code>操作符会做以下几件事情：</p><p>1、创建一个空对象，即：<code>let obj = new Object()</code></p><p>2、将<code>obj</code>的<code>__proto__</code>指向<code>Func</code>的<code>prototype</code>，即：<code>obj.__proto__ = Func.prototype</code></p><p>3、让<code>Func</code>的<code>this</code>指向<code>obj</code>，并执行<code>Func</code>的函数体，即：<code>const result = Func.call(obj)</code></p><p>4、判断<code>result</code>的类型，如果是基本类型，就返回<code>obj</code>，如果是引用类型，就返回<code>result</code>，即：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(typeof result === <span class="string">'object'</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">result</span></span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">obj</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个注意点，如果<code>result</code>的类型是基本类型，那<code>func</code>的构造函数指向<code>Func</code>，但如果是引用类型，<code>func</code>的构造函数指向对应的引用类型函数，举例说明一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func1</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a</span><br><span class="line">    <span class="keyword">this</span>.b = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func1 = <span class="keyword">new</span> Func1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">则：func1.constructor === Func1</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func2</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a</span><br><span class="line">    <span class="keyword">this</span>.b = b</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a,</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func2 = <span class="keyword">new</span> Func2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">则：func2.constructor === <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>一般构造函数不写返回值，则默认的返回值为<code>undefined</code>，为基本类型。</p><h3 id="五、js事件流"><a href="#五、js事件流" class="headerlink" title="五、js事件流"></a>五、js事件流</h3><p>事件流描述的是从页面中接收事件的顺序，事件流包括下面几个阶段：</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><p><code>addEventListener</code>是指定事件处理程序的操作，这个方法接收3个参数：</p><p>1、要处理的事件名<br>2、作为事件处理程序的函数<br>3、一个布尔值。如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。默认值为false</p><p>如果不想要事件冒泡，可以对冒泡阻止，IE与非IE阻止冒泡的写法不一样，所以需要判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e &amp;&amp; e.stopPropagation)&#123;</span><br><span class="line">        e.stopProgapation()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/javascript-summary-of-knowledge-summary1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从这篇文章开始，将对js的知识点进行总结，主要是在日常开发与学习中遇到的知识，会对其进行解释说明，每篇包含几个知识点，如果知识点复杂会单独列出一篇。此类文章将不断更新。（因js过于强大，且每个人在开发时都会遇到各种各样的问题，这里写的更多是自己遇到过的，所以此类文章主要作为自己学习后的知识总结。）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="javascript" scheme="http://yixirumeng.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>reselect源码分析二 ———— createStructuredSelector</title>
    <link href="http://yixirumeng.github.io/2018/12/15/reselect-source-code-analysis-createStructuredSelector/"/>
    <id>http://yixirumeng.github.io/2018/12/15/reselect-source-code-analysis-createStructuredSelector/</id>
    <published>2018-12-15T15:02:46.000Z</published>
    <updated>2018-12-31T13:07:54.844Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/reselect-source-code-analysis-createStructuredSelector.jpg" alt=""></p><blockquote><p><code>reselect</code>除了上一篇文章介绍的两个常用Api，它还提供了一个Api————<code>createStructuredSelector</code>，这个Api可以将结果直接生产Object的形式，这样可以简化<code>mapStateToProps</code>内的代码，更方便操作。那现在就分析一下它的源码，并看一下实际例子。</p></blockquote><a id="more"></a><h3 id="createStructuredSelector"><a href="#createStructuredSelector" class="headerlink" title="createStructuredSelector"></a>createStructuredSelector</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    createStructuredSelector接收两个参数</span></span><br><span class="line"><span class="comment">        selectors：即要定义的所有selector的集合</span></span><br><span class="line"><span class="comment">        selectorCreator：要创建selector的方法，默认为createSelector</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStructuredSelector</span>(<span class="params">selectors, selectorCreator = createSelector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        先判断传入的selectors是否为object，如果不是会抛错</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> selectors !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">'createStructuredSelector expects first argument to be an object '</span> +</span><br><span class="line">            <span class="string">`where each property is a selector, instead received a <span class="subst">$&#123;<span class="keyword">typeof</span> selectors&#125;</span>`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        先获取到selectors中所有的key得到objectKeys</span></span><br><span class="line"><span class="comment">        然后调用selectorCreator也就是createSelector方法，</span></span><br><span class="line"><span class="comment">        遍历objectKeys获取到每个key对应的value，生成新的value数组</span></span><br><span class="line"><span class="comment">        用rest参数的方式传入生成值的函数中，采用数组的reduce方法</span></span><br><span class="line"><span class="comment">        逐步生成每个key对应的处理后的值，最终就可以得到的就是一个Object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> objectKeys = <span class="built_in">Object</span>.keys(selectors)</span><br><span class="line">    <span class="keyword">return</span> selectorCreator(</span><br><span class="line">        objectKeys.map(<span class="function"><span class="params">key</span> =&gt;</span> selectors[key]),</span><br><span class="line">        (...values) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">composition, value, index</span>) =&gt;</span> &#123;</span><br><span class="line">                composition[objectKeys[index]] = value</span><br><span class="line">                <span class="keyword">return</span> composition</span><br><span class="line">            &#125;, &#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createStructureSelector实例"><a href="#createStructureSelector实例" class="headerlink" title="createStructureSelector实例"></a>createStructureSelector实例</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//selector</span><br><span class="line">const getNum = <span class="keyword">state</span> =&gt; <span class="keyword">state</span>.num</span><br><span class="line">const getNumA = <span class="keyword">state</span> =&gt; <span class="keyword">state</span>.numA</span><br><span class="line">const getNumB = <span class="keyword">state</span> =&gt; <span class="keyword">state</span>.numB</span><br><span class="line">const numSelector = createStructureSelector(&#123;</span><br><span class="line">    num: getNum,</span><br><span class="line">    numA: getNumA,</span><br><span class="line">    numB: getNumB</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//mapStateToProps</span><br><span class="line">const mapStateToProps = <span class="keyword">state</span> =&gt; numSelector(<span class="keyword">state</span>)</span><br></pre></td></tr></table></figure><p>这是<code>createStructureSelector</code>应用比较简单的例子，根据上面的分析，其实就是对每一个key对应的value调用一下<code>createSelector</code>方法，然后再应用数组的<code>reduce</code>方法组合成一个执行完之后的Object返回，以前需要把值都写在<code>mapStateToProps</code>中，现在在<code>createStructureSelector</code>中写就可以，提升性能的同时简化操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>应用了两篇文章详细分析了<code>reselect</code>的源码，并结合相应的例子做了过程分析，整体看下来，<code>reselect</code>提高性能的方法主要是应用了闭包，将变量保存下来，下次还能再使用，然后再进行比较，以此减少更新时不必要的操作。其核心的方法是<code>defaultMemoize</code>，理解好它是关键，而其它的Api都是<code>createSelectorCreator</code>演变而来的，所以这两个方法是<code>reselect</code>的主要内容。</p><h3 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h3><p>总结一下阅读完<code>reselect</code>之后的收获：</p><p>1、灵活运用闭包，在合适的地方应用可以起到很重要的作用，但不可过度使用，闭包保存的变量会常驻内存，如果不能有效的清理，会造成内存泄漏。</p><p>2、应用好数组、对象的每个Api方法，如<code>every</code>，<code>reduce</code>，<code>Object.keys</code>，<code>map</code>等等，每一个方法在不同的操作时，都要合理运用，尤其是<code>reduce</code>，在之前分析的源码中，很多地方大量应用了这个方法，最直接的就是<code>compose</code>，它还用很多用法值得去实践。</p><p>3、<code>call</code>、<code>apply</code>、<code>bind</code>三个js中非常重要的方法，主要是改变this的执行，而每一个跟另外两个又有区别。</p><p>4、在上一次分析<code>redux-actions</code>源码的总结中也说了，数组的部分方法会改变原始数组，如<code>pop</code>、<code>push</code>、<code>shift</code>、<code>unshift</code>等，还要知道调用这些方法后的返回值。</p><p>以上大体总结了阅读后的理解，其实还有很多学到的地方，像高阶函数、<code>for</code>循环、<code>arguments</code>等等的。所以，读源码不止能理解框架的原理，还可以读懂设计思想，更可以巩固基础知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/reselect-source-code-analysis-createStructuredSelector.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;reselect&lt;/code&gt;除了上一篇文章介绍的两个常用Api，它还提供了一个Api————&lt;code&gt;createStructuredSelector&lt;/code&gt;，这个Api可以将结果直接生产Object的形式，这样可以简化&lt;code&gt;mapStateToProps&lt;/code&gt;内的代码，更方便操作。那现在就分析一下它的源码，并看一下实际例子。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="reselect" scheme="http://yixirumeng.github.io/tags/reselect/"/>
    
  </entry>
  
  <entry>
    <title>reselect源码分析一 ———— createSelector、createSelectorCreator</title>
    <link href="http://yixirumeng.github.io/2018/12/08/reselect-source-code-analysis-createSelector%E3%80%81createSelectorCreator/"/>
    <id>http://yixirumeng.github.io/2018/12/08/reselect-source-code-analysis-createSelector、createSelectorCreator/</id>
    <published>2018-12-08T14:17:47.000Z</published>
    <updated>2018-12-31T13:06:38.358Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/reselect-source-code-analysis-createSelector、createSelectorCreator.jpg" alt=""></p><blockquote><p>在平时开发的过程中，会应用react-redux这个中间件，但是每次更新时，不管redux中的state是否变化，都会重新更新mapStateToProps里面的值，这会造成大量冗余的操作。reselect作为redux性能优化的中间件已经在广泛使用，只有当redux中的state发生变化时，才会更新mapStateToProps中的值。下面来对其源码进行一下分析，看一下其内部是如何做到这方面性能优化的。</p></blockquote><a id="more"></a><p><code>reselect</code>常用的Api是<code>createSelector</code>，那就先来看一下它的源码：</p><h3 id="createSelector"><a href="#createSelector" class="headerlink" title="createSelector"></a>createSelector</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createSelector = createSelectorCreator(defaultMemoize)</span><br></pre></td></tr></table></figure><p><code>createSelector</code>的源码就这一行，它调用了<code>createSelectorCreator</code>方法并传入<code>defaultMemoize</code>作为参数。而<code>createSelectorCreator</code>也是<code>relect</code>的一个Api，所以<code>createSelector</code>是根据<code>createSelectorCreator</code>来的，那接下来就看一下<code>defaultMemoize</code>、<code>createSelectorCreator</code>的源码。</p><p>在看源码之前，需要先看两个工具函数，它们起着很重要的作用：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">defaultEqualityCheck</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">a</span> === b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很简单，就是对两个参数进行强比较。</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areArgumentsShallowlyEqual</span>(</span>equalityCheck, prev, <span class="keyword">next</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prev === <span class="literal">null</span> || <span class="keyword">next</span> === <span class="literal">null</span> || prev.length !== <span class="keyword">next</span>.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> length = prev.length</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!equalityCheck(prev[i], <span class="keyword">next</span>[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数也不复杂，其主要是遍历元素，然后调用<code>equalityCheck</code>方法，如果有一项不满足，就会马上退出。</p><h3 id="defaultMemoize"><a href="#defaultMemoize" class="headerlink" title="defaultMemoize"></a>defaultMemoize</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    defaultMemoize接收两个参数：</span></span><br><span class="line"><span class="comment">        func是要调用的方法</span></span><br><span class="line"><span class="comment">        equalityCheck就是对比前后两个数据的方法，默认值是defaultEqualityCheck</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultMemoize</span>(<span class="params">func, equalityCheck = defaultEqualityCheck</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        先声明了两个为null的变量，它们有很重要的作用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">let</span> lastArgs = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> lastResult = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里返回一个函数，调用了areArgumentsShallowlyEqual方法</span></span><br><span class="line"><span class="comment">        并将equalityCheck、lastArgs以及函数的arguments传入</span></span><br><span class="line"><span class="comment">        如果满足条件，则直接让传入的func调用arguments</span></span><br><span class="line"><span class="comment">        并把arguments赋值给lastArgs</span></span><br><span class="line"><span class="comment">        这里应用闭包的方式，将参数记录保存下来</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, <span class="built_in">arguments</span>)) &#123;</span><br><span class="line">            lastResult = func.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastArgs = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">return</span> lastResult</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defaultMemoize</code>是<code>reselect</code>的核心方法，通过上面的源码分析可以知道，每次使用时，都会把参数<code>arguments</code>通过闭包的方式保存起来，这样下次再调用时，可以获取到上次保存的值（也就是prevArguments），然后与本次的<code>arguments</code>（也就是nextArguments）做对比，只有变化的时候，才会再次调用传入的<code>func</code>方法。而这里的<code>arguments</code>其实就是在<code>mapStateToProps</code>中传入的参数</p><h3 id="createSelectorCreator"><a href="#createSelectorCreator" class="headerlink" title="createSelectorCreator"></a>createSelectorCreator</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    createSelectorCreator接收若干参数，但最主要的是memoize</span></span><br><span class="line"><span class="comment">    createSelector调用createSelectorCreator传入的参数是defaultMemoize</span></span><br><span class="line"><span class="comment">    所以这里的memoize就是defaultMemoize</span></span><br><span class="line"><span class="comment">    然后返回一个接收任意多个以函数为参数的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createSelectorCreator</span>(<span class="params">memoize, ...memoizeOptions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里先声明了要重新计算的次数，然后获取到传入的参数最后一项</span></span><br><span class="line"><span class="comment">            并对剩余的参数调用了getDependencies方法（不要忘记数组的pop</span></span><br><span class="line"><span class="comment">            方法会改变原始数组）</span></span><br><span class="line"><span class="comment">            这里的funcs就是在创建createSelector时传入的参数</span></span><br><span class="line"><span class="comment">            先去下面看看getDependencies方法</span></span><br><span class="line"><span class="comment">            通过分析可知，就是对参数做了校验</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">let</span> recomputations = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> resultFunc = funcs.pop()</span><br><span class="line">        <span class="keyword">const</span> dependencies = getDependencies(funcs)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里调用了memoize也就是defaultMemoize，并传入参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> memoizedResultFunc = memoize(</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                recomputations++</span><br><span class="line">                <span class="keyword">return</span> resultFunc.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            ...memoizeOptions</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            selector是最后的返回值，它同样会调用defaultMemoize方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> selector = memoize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> params = []</span><br><span class="line">            <span class="keyword">const</span> length = dependencies.length</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                这里除funcs最后一个参数外，都会以arguments作为参数传入</span></span><br><span class="line"><span class="comment">                并将执行后的结果放入到数组params中，最终再执行结果函数</span></span><br><span class="line"><span class="comment">                并以params为参数，仔细分析可知，这里的arguments就是在</span></span><br><span class="line"><span class="comment">                mapStateToProps传入的值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                params.push(dependencies[i].apply(<span class="literal">null</span>, <span class="built_in">arguments</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                所以这也就是在createSelector时，最后一个方法可以以前面</span></span><br><span class="line"><span class="comment">                方法的结果作为参数</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> memoizedResultFunc.apply(<span class="literal">null</span>, params)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里还定义的selector的其它一些属性，可以直接在开发中使用</span></span><br><span class="line"><span class="comment">            每个属性的value都对应上面定义的值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        selector.resultFunc = resultFunc</span><br><span class="line">        selector.dependencies = dependencies</span><br><span class="line">        selector.recomputations = <span class="function"><span class="params">()</span> =&gt;</span> recomputations</span><br><span class="line">        selector.resetRecomputations = <span class="function"><span class="params">()</span> =&gt;</span> recomputations = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> selector</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDependencies方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    getDependencies方法其实很简单，就是判断参数的每一项是否都是函数</span></span><br><span class="line"><span class="comment">    如果不是就会报错，如果都是函数，则直接把参数返回</span></span><br><span class="line"><span class="comment">    看了源码也可以知道，传入的参数可以是单个的参数，也可以是数组</span></span><br><span class="line"><span class="comment">    所以在平时写createSelector时，除了最后一个参数外，其余参数可以都放在数组里</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDependencies</span>(<span class="params">funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dependencies = <span class="built_in">Array</span>.isArray(funcs[<span class="number">0</span>]) ? funcs[<span class="number">0</span>] : funcs</span><br><span class="line">    <span class="keyword">if</span> (!dependencies.every(<span class="function"><span class="params">dep</span> =&gt;</span> <span class="keyword">typeof</span> dep === <span class="string">'function'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> dependencyTypes = dependencies.map(</span><br><span class="line">            dep =&gt; <span class="keyword">typeof</span> dep</span><br><span class="line">        ).join(<span class="string">', '</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">'Selector creators expect all input-selectors to be functions, '</span> +</span><br><span class="line">            <span class="string">`instead received the following types: [<span class="subst">$&#123;dependencyTypes&#125;</span>]`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dependencies</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="creatSelector实例"><a href="#creatSelector实例" class="headerlink" title="creatSelector实例"></a>creatSelector实例</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//selector</span><br><span class="line">const getNumA = <span class="keyword">state</span> =&gt; <span class="keyword">state</span>.numA</span><br><span class="line">const getNumB = <span class="keyword">state</span> =&gt; <span class="keyword">state</span>.numB</span><br><span class="line">const sumFn = (numA, numB) =&gt; numA + numB</span><br><span class="line">const numSum = createSelector(</span><br><span class="line">    getNumA,</span><br><span class="line">    getNumB,</span><br><span class="line">    sumFn</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//mapStateToProps</span><br><span class="line">const mapStateToProps = <span class="keyword">state</span> =&gt; (&#123; num: numSum(<span class="keyword">state</span>) &#125;)</span><br></pre></td></tr></table></figure><p>上面是非常简单的例子，来结合源码看一下过程：</p><p>1、根据分析，<code>getNumA</code>、<code>getNumB</code>、<code>sumFn</code>作为<code>createSelectorCreator</code>返回函数的参数<code>funcs</code>传入，先将<code>sumFn</code>取出，然后其他参数做是否为函数校验。</p><p>2、定义<code>memoizedResultFunc</code>，其值是经过<code>defaultMemoize</code>转换后的值，也就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    recomputations++</span><br><span class="line">    <span class="keyword">return</span> resultFunc.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> memoizedResultFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!areArgumentsShallowlyEqual(defaultEqualityCheck, lastArgs, <span class="built_in">arguments</span>)) &#123;</span><br><span class="line">        lastResult = func1.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastArgs = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">return</span> lastResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义<code>selector</code>，其值也是经过<code>defaultMemoize</code>转换后的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> params = []</span><br><span class="line">  <span class="keyword">const</span> length = dependencies.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    params.push(dependencies[i].apply(<span class="literal">null</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> memoizedResultFunc.apply(<span class="literal">null</span>, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selector = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!areArgumentsShallowlyEqual(defaultEqualityCheck, lastArgs, <span class="built_in">arguments</span>)) &#123;</span><br><span class="line">        lastResult = func2.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastArgs = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">return</span> lastResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、当在<code>mapStateToProps</code>中调用<code>numSum</code>方法并传入<code>state</code>时，会执行<code>selector</code>方法，所以<code>selector</code>中的<code>arguments</code>就是<code>state</code>，在<code>selector</code>内部会执行<code>func2</code>方法，同时用闭包的方式保存下来<code>arguments</code>，这样在<code>getNumA</code>、<code>getNumB</code>就会接收到<code>state</code>参数，将结果放入<code>params</code>数组中，执行<code>memoizedResultFunc</code>传入<code>params</code></p><p>5、<code>memoizedResultFunc</code>内的<code>arguments</code>就是传入的<code>params</code>，然后执行<code>func1</code>方法，也就以<code>params</code>为参数执行了<code>sumFn</code>，同样会用闭包保存下来<code>arguments</code>，最终得到的<code>num</code>就是<code>sumFn</code>执行后的结果</p><p>6、此时保存了两个<code>arguments</code>，一个是<code>state</code>，一个是<code>params</code>。只有当两个都发生变化的时候，<code>num</code>才会更新，否则就一直保持原来的值</p><h3 id="createSelectorCreator其它用法"><a href="#createSelectorCreator其它用法" class="headerlink" title="createSelectorCreator其它用法"></a>createSelectorCreator其它用法</h3><p>看完源码知道，<code>createSelector</code>是基于<code>createSelectorCreator</code>实现的，传入的参数是<code>defaultMemoize</code>，也就是<code>reselect</code>内部默认的方法。但<code>reselect</code>也允许自定义可配置的<code>selector</code>，也就是传入<code>createSelectorCreator</code>的参数可以自己选择，比如传入<code>lodash</code>、<code>underscore</code>中的比较、对比、缓存等方法，具体用法可以查看github文档，里面有详细介绍。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上面的分析，<code>createSelector</code>也就是<code>createSelectorCreator</code>内部最主要是应用了闭包的方式，保存了之前的参数值，然后当再次调用方法传入参数的时候，会将前后两次的值进行对比，只有在发生变化的时候，才会真正调用定义selector时的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/reselect-source-code-analysis-createSelector、createSelectorCreator.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在平时开发的过程中，会应用react-redux这个中间件，但是每次更新时，不管redux中的state是否变化，都会重新更新mapStateToProps里面的值，这会造成大量冗余的操作。reselect作为redux性能优化的中间件已经在广泛使用，只有当redux中的state发生变化时，才会更新mapStateToProps中的值。下面来对其源码进行一下分析，看一下其内部是如何做到这方面性能优化的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="reselect" scheme="http://yixirumeng.github.io/tags/reselect/"/>
    
  </entry>
  
  <entry>
    <title>redux-actions源码分析五 ———— combineActions</title>
    <link href="http://yixirumeng.github.io/2018/12/02/redux-actions-source-code-analysis-combineActions/"/>
    <id>http://yixirumeng.github.io/2018/12/02/redux-actions-source-code-analysis-combineActions/</id>
    <published>2018-12-02T03:32:12.000Z</published>
    <updated>2018-12-08T01:44:43.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-actions-source-code-analysis-combineActions.jpg" alt=""></p><blockquote><p>前面分析了redux-actions的四个Api，<code>combineActions</code>也是其很重要并且很常用的Api，之前写的不同type的处理函数都是分开写的，但是如果有关联的操作，还是需要分别写，而<code>combineActions</code>正好可以将它们结合起来，使得代码更加简便，下面对其源码进行分析一下</p></blockquote><a id="more"></a><h3 id="combineActions"><a href="#combineActions" class="headerlink" title="combineActions"></a>combineActions</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    isValidActionType会校验type是否为String、Function、Symbol类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValidActionType</span><span class="params">(type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isString(type) || isFunction(type) || isSymbol(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    isValidActionTypes会校验types数组是否为空</span></span><br><span class="line"><span class="comment">    如果不为空再分别调用isValidActionType方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValidActionTypes</span><span class="params">(types)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(types)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> types.every(isValidActionType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    combineActions接收任意个数的actionType</span></span><br><span class="line"><span class="comment">    先对其进行isValidActionTypes校验，不通过会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineActions</span><span class="params">(<span class="rest_arg">...actionsTypes</span>)</span> </span>&#123;</span><br><span class="line">    invariant(</span><br><span class="line">        isValidActionTypes(actionsTypes),</span><br><span class="line">        <span class="string">'Expected action types to be strings, symbols, or action creators'</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里会遍历actionsTypes的每一项，然后调用toString方法做字符串转换</span></span><br><span class="line"><span class="comment">        最终用'||'连接，生成一个大的字符串</span></span><br><span class="line"><span class="comment">        然后返回一个对象，key为toString，value为一个函数返回combinedActionType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里着重说一下为什么这么处理：</span></span><br><span class="line"><span class="comment">        还记得在分析handleAction这个Api的时候，刚开始会先按'||'切割，然后判断是否在其中</span></span><br><span class="line"><span class="comment">        const types = toString(type).split(ACTION_TYPE_DELIMITER);</span></span><br><span class="line"><span class="comment">        所以这里用了常量'||'进行连接</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> combinedActionType = actionsTypes</span><br><span class="line">        .map(toString)</span><br><span class="line">        .join(ACTION_TYPE_DELIMITER);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里为什么会返回一个key为toString的对象呢？</span></span><br><span class="line"><span class="comment">        请看下面的combineActions实例，里面会有详细解释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> &#123; toString: () =&gt; combinedActionType &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="combineActions实例"><a href="#combineActions实例" class="headerlink" title="combineActions实例"></a>combineActions实例</h3><p>看过redux-actions的文档，可以知道<code>combineActions</code>的用法</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    这是combineActions的正常用法，可以看到它会放入到handleActions第一参数Object中</span><br><span class="line">    如果正常以变量值作为Object的key，则会成为Object的属性</span><br><span class="line">    所以应用es6语法[]，这样就会把变量的值作为key</span><br><span class="line">    而[]正好调用的是内部变量的<span class="keyword">to</span>String方法，这也就说明了上面为什么返回的Object的</span><br><span class="line">    key是<span class="keyword">to</span>String，其value为函数，调用后直接能得到上面的combineActionType</span><br><span class="line">*/</span><br><span class="line">handleActions(&#123;</span><br><span class="line">    [combineActions(increment, decrement)]: (<span class="keyword">state</span>, payload) =&gt; &#123;</span><br><span class="line">        return &#123; ...<span class="keyword">state</span>, num: <span class="keyword">state</span>.num + payload.num &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123; num: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><p><code>combineActions</code>其它地方其实跟handleActions都很类似，但是数据处理函数会稍有不同，因为传入的值是需要满足所有map的，这就需要对payload有不同的要求，并不能像以前分开的一样，即使传入的相同得到的也是不同的结果</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以前写的reducer是根据type来区分的，而<code>combineActions</code>则是根据传入的数据进行区分的。相对来说，更适合将操作相似的reducer结合在一起，如果偏差很大，用起来会很麻烦，所以实际应用中如果不能分清哪些操作相似，还是尽量少用，因为可能需要对传入的数据进行转换。</p><h3 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h3><p>以上用了5篇文章分别从源码的角度并结合实例详细分析了redux-actions的Api，可以看出，我们平时开发应用广泛的<code>createActions</code>、<code>handleActions</code>都是基于<code>createAction</code>、<code>handleAction</code>进行实现的，只不过其内部做了很多处理，而且也支持了像Map、Array这些类型，但是他们终究还是要生成redux能够是别的action、reducer。但使用redux-actions后，可以简化开发时的书写，使得代码更加清晰易懂。</p><p>其实redux-actions还有另外一个Api，<code>createCurriedAction</code>，但其应用非常非常少，官方文档都没有具体说明用法，而且它也是基于其它库开发的，所以这里就先不做介绍了，能用好之前介绍的5个Api，足以开发正常应用了。</p><h3 id="读后收获"><a href="#读后收获" class="headerlink" title="读后收获"></a>读后收获</h3><p>读过redux-actions源码后，从中收获了很多，简单总结一下：</p><p>1、通过原型的方式可以判断出一个对象是否为扁平对象</p><p>2、通过以函数作为参数的方式来实现复杂的功能</p><p>3、函数还可以再返回函数，以此来达到高阶函数的效果</p><p>4、数组操作的Api中，有一些会改变原有数组，这一点一定要熟知</p><p>5、基本类型、引用类型的类型判断方式，以及其Api的操作方式，得到结果是什么样子的</p><p>6、es6语法中一些语法内部的实现，以及其底层应用了什么方法，比如上面说的以<code>[变量]</code>作为Object的key是调用了toString方法</p><p>7、理解中间件设计的中心思想，简化代码编写、易于理解、阅读清晰</p><p>8、阅读源码可以清晰的知道每个Api的正确使用方式，以及明白这样做最终结果是什么样子的。而不是看了文档只是照搬照抄，过于局限。</p><p>….</p><p>其实还有很多，就不再一一列举了，但有一点很重要，那就是js基础，任何框架、库都是基于基础的，所以打好基础是重中之重。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-actions-source-code-analysis-combineActions.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前面分析了redux-actions的四个Api，&lt;code&gt;combineActions&lt;/code&gt;也是其很重要并且很常用的Api，之前写的不同type的处理函数都是分开写的，但是如果有关联的操作，还是需要分别写，而&lt;code&gt;combineActions&lt;/code&gt;正好可以将它们结合起来，使得代码更加简便，下面对其源码进行分析一下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux-actions" scheme="http://yixirumeng.github.io/tags/redux-actions/"/>
    
  </entry>
  
  <entry>
    <title>redux-actions源码分析四 ———— handleActions</title>
    <link href="http://yixirumeng.github.io/2018/11/30/redux-actions-source-code-analysis-handleActions/"/>
    <id>http://yixirumeng.github.io/2018/11/30/redux-actions-source-code-analysis-handleActions/</id>
    <published>2018-11-30T11:41:18.000Z</published>
    <updated>2018-12-08T01:44:38.612Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-actions-source-code-analysis-handleActions.jpg" alt=""></p><blockquote><p>上一节末尾也总结了，<code>handleAction</code>只能针对单独type，如果type多了就会不方便应用，而<code>handleActions</code>正是来解决这一问题，它与<code>createActions</code>类似，下面就来对其源码进行一下分析</p></blockquote><a id="more"></a><h3 id="handleActions"><a href="#handleActions" class="headerlink" title="handleActions"></a>handleActions</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    handleActions接收三个参数，分别为：</span></span><br><span class="line"><span class="comment">        handlers：Object或Map类型，里面包含对每种type的处理</span></span><br><span class="line"><span class="comment">        defaultState：初始状态</span></span><br><span class="line"><span class="comment">        options：一般不需要传递，默认为&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">handleActions</span>(<span class="params">handlers, defaultState, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        handlers必须为扁平Object或者Map，否则会报错</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    invariant(</span><br><span class="line">        isPlainObject(handlers) || isMap(handlers),</span><br><span class="line">        <span class="string">'Expected handlers to be a plain object.'</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里调用flattenReducerMap方法</span></span><br><span class="line"><span class="comment">        请先移步到flattenReducerMap方法分析</span></span><br><span class="line"><span class="comment">        经过分析可知道，flattenedReducerMap得到的值就是扁平化的Object</span></span><br><span class="line"><span class="comment">        其key和value分别为type及其对应的数据处理方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> flattenedReducerMap = flattenReducerMap(handlers, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里遍历flattenedReducerMap，并对每一项分别调用handleActions方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> reducers = ownKeys(flattenedReducerMap).map(<span class="function"><span class="params">type</span> =&gt;</span></span><br><span class="line">        handleAction(<span class="keyword">type</span>, <span class="keyword">get</span>(<span class="keyword">type</span>, flattenedReducerMap), defaultState)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里的reduceReducers方法是引入的reduce-reducers插件</span></span><br><span class="line"><span class="comment">        其主要是将多个reducer合并，但其与redux的combinReducers有差别</span></span><br><span class="line"><span class="comment">        具体内容可以查看github文档</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> reducer = reduceReducers(...reducers, defaultState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        最终返回的还是一个普通的reducer函数，只不过是经过上述处理的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> reducer(state, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flattenReducerMap</code>方法源码分析：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    熟悉吗，这里还是调用flattenWhenNode方法，并把下面的方法参数传入</span><br><span class="line">    请先移步到flattenWhenNode方法分析</span><br><span class="line">*/</span><br><span class="line">export default flattenWhenNode(</span><br><span class="line">    <span class="keyword">node</span> <span class="title">=&gt; (isPlainObject</span>(<span class="keyword">node</span><span class="title">) || isMap</span>(<span class="keyword">node</span><span class="title">)) &amp;&amp; !hasGeneratorInterface</span>(<span class="keyword">node</span><span class="title">)</span></span><br><span class="line"><span class="title">);</span></span><br></pre></td></tr></table></figure><p><code>flattenWhenNode</code>方法源码分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里的predicate即为上面传入的那个方法参数</span></span><br><span class="line"><span class="comment">    然后返回一个方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> predicate =&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里的map即为上面的handlers</span></span><br><span class="line"><span class="comment">        namespace为'/'</span></span><br><span class="line"><span class="comment">        prefix为undefined</span></span><br><span class="line"><span class="comment">        partialFlatMap、partialFlatActionType为默认值</span></span><br><span class="line"><span class="comment">        还是一样，内部方法先不看，先看下面的，遇到调用再看</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        map,</span></span></span><br><span class="line"><span class="function"><span class="params">        &#123; namespace = DEFAULT_NAMESPACE, prefix &#125; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">        partialFlatMap = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">        partialFlatActionType = <span class="string">''</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            connectNamespace方法会接收type参数，然后进行判断</span></span><br><span class="line"><span class="comment">            因为partialFlatActionType为''，所以直接返回了type</span></span><br><span class="line"><span class="comment">            该方法下面的逻辑会在其它地方用到，这里暂且不考虑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">connectNamespace</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!partialFlatActionType) <span class="keyword">return</span> type;</span><br><span class="line">            <span class="keyword">const</span> types = type.toString().split(ACTION_TYPE_DELIMITER);</span><br><span class="line">            <span class="keyword">const</span> partials = partialFlatActionType.split(ACTION_TYPE_DELIMITER);</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">                .concat(...partials.map(<span class="function"><span class="params">p</span> =&gt;</span> types.map(<span class="function"><span class="params">t</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;p&#125;</span><span class="subst">$&#123;namespace&#125;</span><span class="subst">$&#123;t&#125;</span>`</span>)))</span><br><span class="line">                .join(ACTION_TYPE_DELIMITER);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            connectPrefix同样的，因为partialFlatActionType为''，prefix为undefined</span></span><br><span class="line"><span class="comment">            所以还是返回type</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">connectPrefix</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (partialFlatActionType || !prefix) &#123;</span><br><span class="line">                <span class="keyword">return</span> type;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;prefix&#125;</span><span class="subst">$&#123;namespace&#125;</span><span class="subst">$&#123;type&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            之前分析过，ownKeys是获取map中的每个key，然后遍历</span></span><br><span class="line"><span class="comment">            分别调用connectPrefix、connectNamespace方法</span></span><br><span class="line"><span class="comment">            请先移步到这两个方法的分析</span></span><br><span class="line"><span class="comment">            经过上面两个函数的分析，这里的nextNamespace还是type</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ownKeys(map).forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> nextNamespace = connectPrefix(connectNamespace(type));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                这里调用了get方法，得到key对应的value</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">const</span> mapValue = get(type, map);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">                这里做了判断，predicate即上面的isPlainObject</span></span><br><span class="line"><span class="comment">                因为mapValue可以不单单是个函数，如果还是对象，这递归调用flatten方法</span></span><br><span class="line"><span class="comment">                这里因为mapValue已经是函数了，所以进入else逻辑</span></span><br><span class="line"><span class="comment">                而partialFlatMap的初始值是&#123;&#125;</span></span><br><span class="line"><span class="comment">                最终遍历之后得到的partialFlatMap类似于：</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        INCREMENT: (state, action) =&gt; (&#123;</span></span><br><span class="line"><span class="comment">                            ...state, counter: state.counter + action.payload</span></span><br><span class="line"><span class="comment">                        &#125;),</span></span><br><span class="line"><span class="comment">                    ​</span></span><br><span class="line"><span class="comment">                        DECREMENT: (state, action) =&gt; (&#123;</span></span><br><span class="line"><span class="comment">                            ...state, counter: state.counter - action.payload</span></span><br><span class="line"><span class="comment">                        &#125;)</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                并将结果返回</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (predicate(mapValue)) &#123;</span><br><span class="line">                flatten(mapValue, &#123; namespace, prefix &#125;, partialFlatMap, nextNamespace);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                partialFlatMap[nextNamespace] = mapValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> partialFlatMap;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="handleActions实例"><a href="#handleActions实例" class="headerlink" title="handleActions实例"></a>handleActions实例</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    经过上述分析，其最终会转换成普通的reducer函数，与平时开发时写的reducer类似</span><br><span class="line">*/</span><br><span class="line">handleActions(</span><br><span class="line">    &#123;</span><br><span class="line">        INCREMENT: (<span class="keyword">state</span>, action) =&gt; (&#123;</span><br><span class="line">            ...<span class="keyword">state</span>, counter: <span class="keyword">state</span>.counter + action.payload</span><br><span class="line">        &#125;),</span><br><span class="line">    ​</span><br><span class="line">        DECREMENT: (<span class="keyword">state</span>, action) =&gt; (&#123;</span><br><span class="line">            ...<span class="keyword">state</span>, counter: <span class="keyword">state</span>.counter - action.payload</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; counter: <span class="number">0</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>handleActions</code>内部原理是对传入的Object或者Map遍历，并分别调用<code>handleAction</code>方法，最终还是将自身转换成为一个普通的reducer，因为redux的<code>createStore</code>方法接收的只是一个纯函数的reducer。<code>handleActions</code>弥补了<code>handleAction</code>不能处理多个type的不足，使用起来更加方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-actions-source-code-analysis-handleActions.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上一节末尾也总结了，&lt;code&gt;handleAction&lt;/code&gt;只能针对单独type，如果type多了就会不方便应用，而&lt;code&gt;handleActions&lt;/code&gt;正是来解决这一问题，它与&lt;code&gt;createActions&lt;/code&gt;类似，下面就来对其源码进行一下分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux-actions" scheme="http://yixirumeng.github.io/tags/redux-actions/"/>
    
  </entry>
  
  <entry>
    <title>redux-actions源码分析三 ———— handleAction</title>
    <link href="http://yixirumeng.github.io/2018/11/28/redux-actions-source-code-analysis-handleAction/"/>
    <id>http://yixirumeng.github.io/2018/11/28/redux-actions-source-code-analysis-handleAction/</id>
    <published>2018-11-28T12:10:09.000Z</published>
    <updated>2018-12-08T01:56:07.246Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-actions-source-code-analysis-handleAction.jpg" alt=""></p><blockquote><p>前面分析了创建action的两个方法，现在来分析一下<code>handleAction</code>方法，<code>handleAction</code>主要用于简化reducer，下面就来对其源码进行分析</p></blockquote><a id="more"></a><h3 id="handleAction"><a href="#handleAction" class="headerlink" title="handleAction"></a>handleAction</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    handleAction接收三个参数</span><br><span class="line">        type：即为action的type</span><br><span class="line">        reducer：即为要对type进行数据处理的方法</span><br><span class="line">        <span class="keyword">default</span>State：初始的<span class="keyword">state</span></span><br><span class="line">*/</span><br><span class="line">export <span class="keyword">default</span> function handleAction(type, reducer = identity, <span class="keyword">default</span>State) &#123;</span><br><span class="line">    /*</span><br><span class="line">        首先对type进行处理，这里ACTION_TYPE_DELIMITER为'||'</span><br><span class="line">        之后对reducer、<span class="keyword">default</span>State进行校验，不通过会抛出错误</span><br><span class="line">    */</span><br><span class="line">    const types = <span class="keyword">to</span>String(type).split(ACTION_TYPE_DELIMITER);</span><br><span class="line">    invariant(</span><br><span class="line">        !isUndefined(<span class="keyword">default</span>State),</span><br><span class="line">        `<span class="keyword">default</span>State <span class="keyword">for</span> reducer handling $&#123;types.join(', ')&#125; should be defined`</span><br><span class="line">    );</span><br><span class="line">    invariant(</span><br><span class="line">        isFunction(reducer) || isPlainObject(reducer),</span><br><span class="line">        'Expected reducer <span class="keyword">to</span> be a function or object with next and throw reducers'</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        这里校验reducer是否为函数，然后得到nextReducer、throwReducer</span><br><span class="line">    */</span><br><span class="line">    const [nextReducer, throwReducer] = isFunction(reducer)</span><br><span class="line">        ? [reducer, reducer]</span><br><span class="line">        : [reducer.next, reducer.throw].map(</span><br><span class="line">            aReducer =&gt; (isNil(aReducer) ? identity : aReducer)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        最终返回一个方法，再对type进行校验，如果不在上面types数组中，直接返回默认<span class="keyword">state</span></span><br><span class="line">    */</span><br><span class="line">    return (<span class="keyword">state</span> = <span class="keyword">default</span>State, action) =&gt; &#123;</span><br><span class="line">        const &#123; type: actionType &#125; = action;</span><br><span class="line">        if (!actionType || types.indexOf(<span class="keyword">to</span>String(actionType)) === -<span class="number">1</span>) &#123;</span><br><span class="line">            return <span class="keyword">state</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            如果type在types数组中，直接调用reducer函数，并把<span class="keyword">state</span>、action传入</span><br><span class="line">            这里可以看出与普通的reducer类似</span><br><span class="line">        */</span><br><span class="line">        return (action.error === true ? throwReducer : nextReducer)(<span class="keyword">state</span>, action);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handleAction实例"><a href="#handleAction实例" class="headerlink" title="handleAction实例"></a>handleAction实例</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    经过上面分析，当dispatch(increment(<span class="number">1</span>))时，会调用第二个函数参数，得到变化后的count为<span class="number">2</span></span><br><span class="line">*/</span><br><span class="line">handleAction(</span><br><span class="line">    'INCREMENT',</span><br><span class="line">    (<span class="keyword">state</span>, action) =&gt; &#123;</span><br><span class="line">        return &#123; ...<span class="keyword">state</span>, count: <span class="keyword">state</span>.count + action.payload &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; count: <span class="number">1</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>handleAction</code>方法其实就是对普通的reducer进行了包装，但其只能用于单个type，实际应用中很少会只有一个type，如果有多个type，则需要多次调用<code>handleAction</code>方法，这会很复杂，所以这个Api在开发中应用较少</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-actions-source-code-analysis-handleAction.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前面分析了创建action的两个方法，现在来分析一下&lt;code&gt;handleAction&lt;/code&gt;方法，&lt;code&gt;handleAction&lt;/code&gt;主要用于简化reducer，下面就来对其源码进行分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux-actions" scheme="http://yixirumeng.github.io/tags/redux-actions/"/>
    
  </entry>
  
  <entry>
    <title>redux-actions源码分析二 ———— createActions</title>
    <link href="http://yixirumeng.github.io/2018/11/25/redux-actions-source-code-analysis-createActions/"/>
    <id>http://yixirumeng.github.io/2018/11/25/redux-actions-source-code-analysis-createActions/</id>
    <published>2018-11-25T11:23:56.000Z</published>
    <updated>2018-12-08T01:44:28.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-actions-source-code-analysis-createActions.jpg" alt=""></p><blockquote><p>上一节对<code>createAction</code>进行了分析，其每次只能创建一个action，如果想要一次创建多个action，这就需要应用<code>createActions</code>这一Api，下面对<code>createActions</code>的源码来分析一下</p></blockquote><a id="more"></a><h3 id="createActions"><a href="#createActions" class="headerlink" title="createActions"></a>createActions</h3><p><code>createActions</code>的源码会复杂很多，一步一步来分析，不要着急</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    createActions接收两个参数actionMap、identityActions</span></span><br><span class="line"><span class="comment">    根据redux-actions的Api文档可以知道，这个actionMap是定义的一个含有多个action的对象</span></span><br><span class="line"><span class="comment">    identityActions是定义任意个数的常量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createActions</span><span class="params">(actionMap, <span class="rest_arg">...identityActions</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里对identityActions进行了一次校验，会获取identityActions最后一个元素</span></span><br><span class="line"><span class="comment">        检验其是否为是一个扁平的对象，正常我们传递的都是作为type的普通字符串</span></span><br><span class="line"><span class="comment">        所以会options的值就是&#123;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> options = isPlainObject(getLastElement(identityActions))</span><br><span class="line">        ? identityActions.pop()</span><br><span class="line">        : &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里还是像之前说过的，对参数进行校验，如果校验不通过会报出错误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    invariant(</span><br><span class="line">        identityActions.every(isString) &amp;&amp;</span><br><span class="line">        (isString(actionMap) || isPlainObject(actionMap)),</span><br><span class="line">        <span class="string">'Expected optional object followed by string action types'</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在调用createActions时，传递的参数可以全部是字符串，所以这里对actionMap进行判断</span></span><br><span class="line"><span class="comment">        如果是字符串，直接调用actionCreatorsFromIdentityActions方法</span></span><br><span class="line"><span class="comment">        请移步到actionCreatorsFromActionMap方法分析</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (isString(actionMap)) &#123;</span><br><span class="line">        <span class="keyword">return</span> actionCreatorsFromIdentityActions(</span><br><span class="line">            [actionMap, ...identityActions],</span><br><span class="line">            options</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果actionMap不是字符串，会调用actionCreatorsFromActionMap方法</span></span><br><span class="line"><span class="comment">        请先移步到actionCreatorsFromActionMap方法分析</span></span><br><span class="line"><span class="comment">        后续的参数identityActions则调用actionCreatorsFromIdentityActions方法</span></span><br><span class="line"><span class="comment">        请先移步到actionCreatorsFromIdentityActions方法分析</span></span><br><span class="line"><span class="comment">        经过分析可以知道，最终返回的结果是经过调用createAction以及camelCase转换后的结果</span></span><br><span class="line"><span class="comment">        所以还是可以通过对象解构的方式获取到每个action方法，即：</span></span><br><span class="line"><span class="comment">            const &#123; increment, decrement, asyncIncrement &#125; = createActions(&#123;</span></span><br><span class="line"><span class="comment">                    INCREMENT: value =&gt; value,</span></span><br><span class="line"><span class="comment">                    DECREMENT: value =&gt; -value</span></span><br><span class="line"><span class="comment">                &#125;, 'ASYNC_INCREMENT')</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...actionCreatorsFromActionMap(actionMap, options),</span><br><span class="line">        ...actionCreatorsFromIdentityActions(identityActions, options)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析<code>actionCreatorsFromIdentityActions</code>之前先分析一下<code>arrayToObject</code>这个方法，因为它会在很多地方用到</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    其实从名字上也可以看出，它主要是将<span class="keyword">array</span>转换为object</span><br><span class="line">    这里应用了数组的reduce方法，分别对每个元素调用callback方法</span><br><span class="line">    并将结果放入到&#123;&#125;中</span><br><span class="line">*/</span><br><span class="line">export <span class="keyword">default</span> (<span class="keyword">array</span>, callback) =&gt;</span><br><span class="line">    <span class="keyword">array</span>.reduce(</span><br><span class="line">        (partialObject, <span class="literal">element</span>) =&gt; callback(partialObject, <span class="literal">element</span>),</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><code>actionCreatorsFromIdentityActions</code>方法源码分析：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    actionCreatorsFromIdentityActions方法接收两个参数identityActions、options</span><br><span class="line">    根据上面的分析可以知道identityActions是一个字符串数组</span><br><span class="line">    而options就是个普通的&#123;&#125;</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> actionCreatorsFromIdentityActions(identityActions, options) &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        根据上面的分析，这里会对identityActions每一个元素调用第二个方法参数</span><br><span class="line">        而这个方法最终生成的对象就是一个包含所有<span class="keyword">type</span>的一个大的对象</span><br><span class="line">        下面的identity之前说过，就是 <span class="keyword">value</span> =&gt; <span class="keyword">value</span> 这个函数</span><br><span class="line">        所以最终的actionMap就是类型于：</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="symbol">'INCREMENT'</span>: <span class="keyword">value</span> =&gt; <span class="keyword">value</span>,</span><br><span class="line">                <span class="symbol">'DECREMENT'</span>: <span class="keyword">value</span> =&gt; <span class="keyword">value</span></span><br><span class="line">            &#125;</span><br><span class="line">        这样的对象</span><br><span class="line">    */</span><br><span class="line">    const actionMap = arrayToObject(</span><br><span class="line">        identityActions,</span><br><span class="line">        (partialActionMap, <span class="keyword">type</span>) =&gt; (&#123; ...partialActionMap, [<span class="keyword">type</span>]: identity &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        这里再对生成的actionMap调用actionMapToActionCreators方法，请先到下面看方法分析</span><br><span class="line">        根据下面分析可以知道，actionCreators就是一个包含<span class="keyword">type</span>-actionCreator的对象</span><br><span class="line">    */</span><br><span class="line">    const actionCreators = actionMapToActionCreators(actionMap, options);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        再一次调用了arrayToObject方法，这里以actionCreators的key作为第一个参数</span><br><span class="line">        而传入的第二个方法其实不用仔细分析也能知道，只是把<span class="keyword">type</span>转换为驼峰的形式</span><br><span class="line">        所以最终的对象根actionCreators基本一致，只不过把actionCreators的key进行了驼峰转换</span><br><span class="line">        这也就是我们可以通过对象解构的方式获取到每个action方法，即：</span><br><span class="line">        const &#123; increment, decrement, asyncIncrement &#125; </span><br><span class="line">            = createActions(<span class="symbol">'INCREMENT'</span>, <span class="symbol">'DECREMENT'</span>, <span class="symbol">'ASYNC_INCREMENT'</span>)</span><br><span class="line">    */</span><br><span class="line">    return arrayToObject(</span><br><span class="line">        <span class="type">Object</span>.keys(actionCreators),</span><br><span class="line">        (partialActionCreators, <span class="keyword">type</span>) =&gt; (&#123;</span><br><span class="line">            ...partialActionCreators,</span><br><span class="line">            [camelCase(<span class="keyword">type</span>)]: actionCreators[<span class="keyword">type</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>actionMapToActionCreators</code>方法源码分析：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    actionMapToActionCreators接收actionMap这个参数，据上面的分析</span><br><span class="line">    actionMap就是类似</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="symbol">'INCREMENT</span>': value =&gt; value,</span><br><span class="line">            <span class="symbol">'DECREMENT</span>': value =&gt; value</span><br><span class="line">        &#125;</span><br><span class="line">    这样的对象</span><br><span class="line">    下面的prefix可以理解其为undefined，namespace的值为一个常量<span class="string">'/'</span></span><br><span class="line">    因为这个方法内部还嵌套一个函数，所以先不要看嵌套的函数，先看下面返回值的内容，</span><br><span class="line">    当遇到这个函数的调用的时候，再回头来分析</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> <span class="title">actionMapToActionCreators</span>(</span><br><span class="line">    actionMap,</span><br><span class="line">    &#123; prefix, namespace = DEFAULT_NAMESPACE &#125; = &#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">isValidActionMapValue</span>(actionMapValue) &#123;</span><br><span class="line">        if (<span class="keyword">is</span><span class="keyword">Function</span>(actionMapValue) || isNil(actionMapValue)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isArray(actionMapValue)) &#123;</span><br><span class="line">            const [payload = identity, meta] = actionMapValue;</span><br><span class="line">            <span class="keyword">return</span> isFunction(payload) &amp;&amp; isFunction(meta);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        这里还是调用了arrayToObject方法，传递的第二个方法参数稍有复杂</span><br><span class="line">        别着急，还是一步一步分析</span><br><span class="line">        先获取到actionMap中的所有的key，作为arrayToObject的第一参数</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">return</span> arrayToObject(</span><br><span class="line">        Object.keys(actionMap),</span><br><span class="line">        /*</span><br><span class="line">            还记得上面分析的arrayToObject函数吗，就是调用了数组的reduce方法</span><br><span class="line">            所以这里初始的partialActionCreators就是空对象&#123;&#125;</span><br><span class="line">            <span class="keyword">type</span>就是Object.keys(actionMap)每个元素，也就是actionMap的key</span><br><span class="line">        */</span><br><span class="line">        (partialActionCreators, <span class="keyword">type</span>) =&gt; &#123;</span><br><span class="line">            /*</span><br><span class="line">                这里的actionMapValue就是每个key对应的value</span><br><span class="line">                下面还是做了校验，如果不通过报错</span><br><span class="line">            */</span><br><span class="line">            const actionMapValue = actionMap[<span class="keyword">type</span>];</span><br><span class="line">            invariant(</span><br><span class="line">                isValidActionMapValue(actionMapValue),</span><br><span class="line">                <span class="symbol">'Expected</span> <span class="keyword">function</span>, undefined, null, <span class="keyword">or</span> <span class="keyword">array</span> <span class="keyword">with</span> payload <span class="keyword">and</span> meta ' +</span><br><span class="line">                `functions <span class="keyword">for</span> $&#123;<span class="keyword">type</span>&#125;`</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">                因为上面分析了prefix就是undefined，所以prefixedType的值就是<span class="keyword">type</span></span><br><span class="line">            */</span><br><span class="line">            const prefixedType = prefix ? `$&#123;prefix&#125;$&#123;namespace&#125;$&#123;<span class="keyword">type</span>&#125;` : <span class="type">type</span>;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">                这里对actionMapValue进行是否为数组校验，然后调用createAction</span><br><span class="line">                createAction就是redux-actions的Api</span><br><span class="line">                最终返回的一个包含<span class="keyword">type</span>和actionCreator这个key-value的对象</span><br><span class="line">                而这个对象的形式就类似于：</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="symbol">'INCREMENT</span>': incrementActionCreator,</span><br><span class="line">                        <span class="symbol">'DECREMENT</span>': decrementActionCreator</span><br><span class="line">                    &#125;</span><br><span class="line">                还记得上一篇分析的createAction吗，它的返回值就是一个方法，</span><br><span class="line">                执行这个方法，也就得到了最基本的action</span><br><span class="line">                actionMapToActionCreators分析完了，再回到之前的地方</span><br><span class="line">            */</span><br><span class="line">            const actionCreator = isArray(actionMapValue)</span><br><span class="line">                ? createAction(prefixedType, ...actionMapValue)</span><br><span class="line">                : <span class="type">createAction</span>(prefixedType, actionMapValue);</span><br><span class="line">            <span class="keyword">return</span> &#123; ...partialActionCreators, [<span class="keyword">type</span>]: actionCreator &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>actionCreatorsFromActionMap</code>方法源码分析：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    actionCreatorsFromActionMap接收actionMap、options两个参数</span></span><br><span class="line"><span class="comment">    根据上面的分析，actionMap类似于：</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            INCREMENT: value =&gt; value,</span></span><br><span class="line"><span class="comment">            DECREMENT: value =&gt; -value</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    而options就是空对象&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">actionCreatorsFromActionMap</span><span class="params">(actionMap, options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里调用了flattenActionMap这个方法</span></span><br><span class="line"><span class="comment">        请先移步到flattenActionMap方法的分析</span></span><br><span class="line"><span class="comment">        经过分析可以知道，flatActionMap的值是将对象扁平化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> flatActionMap = flattenActionMap(actionMap, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里再调用actionMapToActionCreators方法</span></span><br><span class="line"><span class="comment">        请先移步到actionMapToActionCreators方法分析</span></span><br><span class="line"><span class="comment">        经过分析可以知道，调用之后的结果就是将每一项调用creatAction</span></span><br><span class="line"><span class="comment">        所以结果类似于：</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                'INCREMENT': incrementActionCreator,</span></span><br><span class="line"><span class="comment">                'DECREMENT': decrementActionCreator</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> flatActionCreators = actionMapToActionCreators(flatActionMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里调用了unflattenActionCreators方法</span></span><br><span class="line"><span class="comment">        请先移步到unflattenActionCreators的方法分析</span></span><br><span class="line"><span class="comment">        经过分析可以知道，返回的结果是经过驼峰转换后的结果</span></span><br><span class="line"><span class="comment">        这与actionCreatorsFromIdentityActions方法类似</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unflattenActionCreators(flatActionCreators, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flattenActionMap</code>方法源码分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    flattenActionMap调用了flattenWhenNode方法</span></span><br><span class="line"><span class="comment">    并传入是否为扁平对象这个方法作为参数</span></span><br><span class="line"><span class="comment">    请移步到flattenWhenNode方法分析</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title">flattenWhenNode</span><span class="params">(isPlainObject)</span></span>;</span><br></pre></td></tr></table></figure><p><code>flattenWhenNode</code>方法源码分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    flattenWhenNode接收一个predicate参数，并返回一个函数</span></span><br><span class="line"><span class="comment">    predicate为上面传入的isPlainObject</span></span><br><span class="line"><span class="comment">    返回的flatten方法中的参数分别为：</span></span><br><span class="line"><span class="comment">        map：就是上面传入的actionMap</span></span><br><span class="line"><span class="comment">        namespace：常量'/'</span></span><br><span class="line"><span class="comment">        prefix：undefined</span></span><br><span class="line"><span class="comment">        partialFlatMap：&#123;&#125;</span></span><br><span class="line"><span class="comment">        partialFlatActionType：''</span></span><br><span class="line"><span class="comment">    函数里面还有函数，还是一样当调用的时候再分析</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> predicate =&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        map,</span></span></span><br><span class="line"><span class="function"><span class="params">        &#123; namespace = DEFAULT_NAMESPACE, prefix &#125; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">        partialFlatMap = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">        partialFlatActionType = <span class="string">''</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            connectNamespace方法会接收type参数，然后进行判断</span></span><br><span class="line"><span class="comment">            因为partialFlatActionType为''，所以直接返回了type</span></span><br><span class="line"><span class="comment">            该方法下面的逻辑会在其它地方用到，这里暂且不考虑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">connectNamespace</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!partialFlatActionType) <span class="keyword">return</span> type;</span><br><span class="line">            <span class="keyword">const</span> types = type.toString().split(ACTION_TYPE_DELIMITER);</span><br><span class="line">            <span class="keyword">const</span> partials = partialFlatActionType.split(ACTION_TYPE_DELIMITER);</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">                .concat(...partials.map(<span class="function"><span class="params">p</span> =&gt;</span> types.map(<span class="function"><span class="params">t</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;p&#125;</span><span class="subst">$&#123;namespace&#125;</span><span class="subst">$&#123;t&#125;</span>`</span>)))</span><br><span class="line">                .join(ACTION_TYPE_DELIMITER);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            connectPrefix同样的，因为partialFlatActionType为''，prefix为undefined</span></span><br><span class="line"><span class="comment">            所以还是返回type</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">connectPrefix</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (partialFlatActionType || !prefix) &#123;</span><br><span class="line">                <span class="keyword">return</span> type;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;prefix&#125;</span><span class="subst">$&#123;namespace&#125;</span><span class="subst">$&#123;type&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里调用ownKeys方法，这个方法内部的逻辑是</span></span><br><span class="line"><span class="comment">            如果map是个Map类型的，则取出其中的key，并用Array.from转换成数组</span></span><br><span class="line"><span class="comment">            如果是Object类型，则用getOwnPropertyNames方法取出自身的key</span></span><br><span class="line"><span class="comment">            所以最终得到的是含有所有key的数组</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ownKeys(map).forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                遍历每个key，这里分别调用了connectNamespace、connectPrefix方法</span></span><br><span class="line"><span class="comment">                请先移步到这两个方法的分析</span></span><br><span class="line"><span class="comment">                经过上面两个函数的分析，这里的nextNamespace还是type</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">const</span> nextNamespace = connectPrefix(connectNamespace(type));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                这里调用了get方法，因为map可能是Map或者Object类型</span></span><br><span class="line"><span class="comment">                应用get方法得到key对应的value</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">const</span> mapValue = get(type, map);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                这里做了判断，predicate即上面的isPlainObject</span></span><br><span class="line"><span class="comment">                因为mapValue可以不单单是个函数，如果还是对象，这递归调用flatten方法</span></span><br><span class="line"><span class="comment">                这里因为mapValue已经是函数了，所以进入else逻辑</span></span><br><span class="line"><span class="comment">                而partialFlatMap的初始值是&#123;&#125;</span></span><br><span class="line"><span class="comment">                最终遍历之后得到的partialFlatMap类似于：</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        INCREMENT: value =&gt; value,</span></span><br><span class="line"><span class="comment">                        DECREMENT: value =&gt; -value</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                并将结果返回</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (predicate(mapValue)) &#123;</span><br><span class="line">                flatten(mapValue, &#123; namespace, prefix &#125;, partialFlatMap, nextNamespace);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                partialFlatMap[nextNamespace] = mapValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> partialFlatMap;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><code>unflattenActionCreators</code>方法源码分析</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    unflattenActionCreators的参数分别为：</span></span><br><span class="line"><span class="comment">        flatActionCreators：即上面传入的flatActionCreators</span></span><br><span class="line"><span class="comment">        namespace为常量'/'</span></span><br><span class="line"><span class="comment">        prefix为undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">unflattenActionCreators</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    flatActionCreators,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123; <span class="keyword">namespace</span> = DEFAULT_NAMESPACE, prefix &#125; = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        unflatten的方法参数分别为：</span></span><br><span class="line"><span class="comment">            flatActionType即传入的type</span></span><br><span class="line"><span class="comment">            partialNestedActionCreators为&#123;&#125;</span></span><br><span class="line"><span class="comment">            partialFlatActionTypePath为字符串转化后的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unflatten</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        flatActionType,</span></span></span><br><span class="line"><span class="function"><span class="params">        partialNestedActionCreators,</span></span></span><br><span class="line"><span class="function"><span class="params">        partialFlatActionTypePath</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里对partialFlatActionTypePath去除第一个元素调用了camelCase方法</span></span><br><span class="line"><span class="comment">            还记得分析createAction时说的吗，camelCase就是转化驼峰形式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> nextNamespace = camelCase(partialFlatActionTypePath.shift());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里对partialFlatActionTypePath做是否为空的判断，别忘了有件事</span></span><br><span class="line"><span class="comment">            上面数组调用了shift方法，而shift方法会改变原来的数组</span></span><br><span class="line"><span class="comment">            最终在partialNestedActionCreators即空&#123;&#125;中放入key、value</span></span><br><span class="line"><span class="comment">                key为经过驼峰转换后的值</span></span><br><span class="line"><span class="comment">                value就是传入的key对应的value</span></span><br><span class="line"><span class="comment">            如果partialFlatActionTypePath不为空，则递归调用unflatten方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty(partialFlatActionTypePath)) &#123;</span><br><span class="line">            partialNestedActionCreators[nextNamespace] =</span><br><span class="line">                flatActionCreators[flatActionType];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!partialNestedActionCreators[nextNamespace]) &#123;</span><br><span class="line">                partialNestedActionCreators[nextNamespace] = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            unflatten(</span><br><span class="line">                flatActionType,</span><br><span class="line">                partialNestedActionCreators[nextNamespace],</span><br><span class="line">                partialFlatActionTypePath</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> nestedActionCreators = &#123;&#125;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里获取flatActionCreators自身的属性key并遍历</span></span><br><span class="line"><span class="comment">        因为prefix为undefined，所以unprefixedType为type</span></span><br><span class="line"><span class="comment">        接着调用unflatten方法</span></span><br><span class="line"><span class="comment">        请先移步到unflatten方法的分析</span></span><br><span class="line"><span class="comment">        经过分析后可知，最终的结果其实主要对key做了驼峰转换</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyNames(flatActionCreators).forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> unprefixedType = prefix</span><br><span class="line">            ? <span class="keyword">type</span>.replace(<span class="string">`<span class="subst">$&#123;prefix&#125;</span><span class="subst">$&#123;namespace&#125;</span>`</span>, <span class="string">''</span>)</span><br><span class="line">            : <span class="keyword">type</span>;</span><br><span class="line">        <span class="keyword">return</span> unflatten(</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            nestedActionCreators,</span><br><span class="line">            unprefixedType.split(<span class="keyword">namespace</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nestedActionCreators;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createActions实例"><a href="#createActions实例" class="headerlink" title="createActions实例"></a>createActions实例</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面这几种方式都可以，经过上面的分析，如果不传入Object，则直接调用createAction</span></span><br><span class="line"><span class="comment">    传入的话，会遍历调用，如果传入的不是扁平Object，则递归遍历，再调用</span></span><br><span class="line"><span class="comment">    最终将key进行驼峰转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; increment, decrement, asyncIncrement &#125; = createActions(<span class="string">'INCREMENT'</span>, <span class="string">'DECREMENT'</span>, <span class="string">'ASYNC_INCREMENT'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; increment, decrement, asyncIncrement &#125; = createActions(&#123;</span><br><span class="line">    INCREMENT: <span class="keyword">value</span> =&gt; <span class="keyword">value</span>,</span><br><span class="line">    DECREMENT: <span class="keyword">value</span> =&gt; -<span class="keyword">value</span></span><br><span class="line">&#125;, <span class="string">'ASYNC_INCREMENT'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; increment, decrement, asyncIncrement &#125; = createActions(&#123;</span><br><span class="line">    COUNT: &#123;</span><br><span class="line">        INCREMENT: <span class="keyword">value</span> =&gt; <span class="keyword">value</span>,</span><br><span class="line">        DECREMENT: <span class="keyword">value</span> =&gt; -<span class="keyword">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">'ASYNC_INCREMENT'</span>)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>createActions</code>方法看上去很复杂，但其内部的逻辑很清晰，主要目的就是遍历每个元素，然后分别调用<code>createAction</code>方法，最终还是生成普通的action，只不过如果只用<code>createAction</code>方法只能单独生成，而<code>createActions</code>可以同时生成多个，减少代码量，更加方便书写，也很清晰。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-actions-source-code-analysis-createActions.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上一节对&lt;code&gt;createAction&lt;/code&gt;进行了分析，其每次只能创建一个action，如果想要一次创建多个action，这就需要应用&lt;code&gt;createActions&lt;/code&gt;这一Api，下面对&lt;code&gt;createActions&lt;/code&gt;的源码来分析一下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux-actions" scheme="http://yixirumeng.github.io/tags/redux-actions/"/>
    
  </entry>
  
  <entry>
    <title>redux-actions源码分析一 ———— createAction</title>
    <link href="http://yixirumeng.github.io/2018/11/23/redux-actions-source-code-analysis-createAction/"/>
    <id>http://yixirumeng.github.io/2018/11/23/redux-actions-source-code-analysis-createAction/</id>
    <published>2018-11-23T11:18:02.000Z</published>
    <updated>2018-12-08T01:44:22.375Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-actions-source-code-analysis-createAction.jpg" alt=""></p><blockquote><p>redux-actions这个中间件在平时的开发中会经常用到，可以省去繁琐的写法，很方便的写action，下面会用几篇文章分别对它里面的每个Api进行详细分析，还是像之前一样，分析源码的同时结合实际例子，帮助理解。</p></blockquote><a id="more"></a><h3 id="createAction"><a href="#createAction" class="headerlink" title="createAction"></a>createAction</h3><p>源码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    createAction接收三个参数，除了第一个之外，其它都是可以不传递的</span></span><br><span class="line"><span class="comment">    type: 就是平时定义action要写的type</span></span><br><span class="line"><span class="comment">    payloadCreator: 平时定义action时经常会传递参数（payload），而它正是生成payload的方法</span></span><br><span class="line"><span class="comment">                    这里它有默认值identity，这个identity其实很简单，就是value =&gt; value</span></span><br><span class="line"><span class="comment">                    如果不传，它就是很简单的参数=返回值</span></span><br><span class="line"><span class="comment">    metaCreator: 很少会用到，可以忽略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createAction</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">type</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    payloadCreator = identity,</span></span></span><br><span class="line"><span class="function"><span class="params">    metaCreator</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invariant是一个第三方工具，其详细用法可以去github查一下</span></span><br><span class="line"><span class="comment">        这里的意思就是对payloadCreator进行是否为函数、是否为null检验</span></span><br><span class="line"><span class="comment">        如果都不通过，就会报出下面的错误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    invariant(</span><br><span class="line">        isFunction(payloadCreator) || isNull(payloadCreator),</span><br><span class="line">        <span class="string">'Expected payloadCreator to be a function, undefined or null'</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        finalPayloadCreator即为最终的payload生成函数，这里也是做了校验</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> finalPayloadCreator =</span><br><span class="line">        isNull(payloadCreator) || payloadCreator === identity</span><br><span class="line">        ? identity</span><br><span class="line">        : <span class="function">(<span class="params">head, ...args</span>) =&gt;</span></span><br><span class="line">            head <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? head : payloadCreator(head, ...args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hasMeta = isFunction(metaCreator);</span><br><span class="line">    <span class="keyword">const</span> typeString = <span class="keyword">type</span>.toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这个actionCreator就是最终createAction要返回的函数</span></span><br><span class="line"><span class="comment">        它接收任意多个参数，最终会把这些参数传入到上面的finalPayloadCreator</span></span><br><span class="line"><span class="comment">        创建一个对象action，其属性type为createAction传入的type</span></span><br><span class="line"><span class="comment">        其属性payload为经过finalPayloadCreator处理后的payload</span></span><br><span class="line"><span class="comment">        meta属性很少用到，可以不用考虑</span></span><br><span class="line"><span class="comment">        最终导出action</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> actionCreator = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> payload = finalPayloadCreator(...args);</span><br><span class="line">        <span class="keyword">const</span> action = &#123; <span class="keyword">type</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (payload <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">            action.error = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (payload !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            action.payload = payload;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasMeta) &#123;</span><br><span class="line">            action.meta = metaCreator(...args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    actionCreator.toString = <span class="function"><span class="params">()</span> =&gt;</span> typeString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> actionCreator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的分析，可以看到<code>createAction</code>内部的实现其实很简单，主要就是对payload做了一层特殊的处理，将以函数的形式创建，最终<code>createAction</code>导出一个函数，而执行函数后的结果，就是一个正常的action</p><h3 id="createAction实际应用"><a href="#createAction实际应用" class="headerlink" title="createAction实际应用"></a>createAction实际应用</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const increment = createAction(<span class="symbol">'INCREMENT'</span>)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    这是createAction最简单用法，这里<span class="symbol">'INCREMENT'</span>即为<span class="keyword">type</span></span><br><span class="line">    根据上面分析：createAction最终会返回一个名为actionCreator的函数</span><br><span class="line">    执行这个函数会返回一个action的对象，如果没有传递payloadCreator</span><br><span class="line">    其默认为 <span class="keyword">value</span> =&gt; <span class="keyword">value</span>，finalPayloadCreator也为 <span class="keyword">value</span> =&gt; <span class="keyword">value</span></span><br><span class="line">    而下面执行increment时，并没有传递参数，</span><br><span class="line">    所以actionCreator中定义的常量payload即为undefined，不会放入action中</span><br><span class="line">    最终生成的action为&#123; <span class="keyword">type</span>: <span class="symbol">'INCREMENT'</span> &#125;</span><br><span class="line">*/</span><br><span class="line">increment<span class="literal">()</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    执行这个函数，其它的逻辑跟上面一样，但是因为传递了参数<span class="number">1</span>，所以最终的payload</span><br><span class="line">    不会是undefined，因为finalPayloadCreator也为 <span class="keyword">value</span> =&gt; <span class="keyword">value</span></span><br><span class="line">    所以payload值为<span class="number">1</span></span><br><span class="line">    最终生成的action为&#123; <span class="keyword">type</span>: <span class="symbol">'INCREMENT'</span>, payload: <span class="number">1</span> &#125;</span><br><span class="line">*/</span><br><span class="line">increment(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>除了默认的payloadCreator之外，还可以自定义payloadCreator</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const decrement = createAction(<span class="symbol">'DECREMENT'</span>, <span class="keyword">value</span> =&gt; -<span class="keyword">value</span>)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    别的逻辑还是一样，只不过这里自定义了payloadCreator，所以finalPayloadCreator</span><br><span class="line">    就是这里自定义的payloadCreator，生成的payload即为-<span class="number">1</span></span><br><span class="line">    最终的action为&#123; <span class="keyword">type</span>: <span class="symbol">'DECREMENT'</span>, payload: -<span class="number">1</span> &#125;</span><br><span class="line">*/</span><br><span class="line">decrement(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>进一步分析：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    可能有人对这个finalPayloadCreator这个判断条件不太理解</span><br><span class="line">    如果不传递payloadCreator没什么好说的，finalPayloadCreator就是<span class="keyword">value</span> =&gt; <span class="keyword">value</span></span><br><span class="line">    但如果传递了，即使传递还是 <span class="keyword">value</span> =&gt; <span class="keyword">value</span>，也会走到<span class="keyword">else</span>的逻辑</span><br><span class="line">    因为<span class="keyword">function</span>是引用类型，其在内存中并不是直接保存值，保存的是执行的地址</span><br><span class="line">    而传入的payloadCreator与identity虽然一样，但地址不同，所以也是不相等的</span><br><span class="line">    <span class="keyword">else</span>的函数又对传递的参数做了原型是否为<span class="type">Error</span>的校验，</span><br><span class="line">    其中head就是传递的第一个参数，args是后续的参数，</span><br><span class="line">    payloadCreator(head, ...args)就是正常执行传递过来的payloadCreator</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const finalPayloadCreator =</span><br><span class="line">        isNull(payloadCreator) || payloadCreator === identity</span><br><span class="line">        ? identity</span><br><span class="line">        : (head, ...args) =&gt;</span><br><span class="line">            head instanceof <span class="type">Error</span> ? head : payloadCreator(head, ...args);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>createAction</code>内部其实很简单，但也有很多需要思考并注意的地方，但不过怎样，最终还是要生成一个普通的action，只不过让我们在开发时更加方便操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-actions-source-code-analysis-createAction.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redux-actions这个中间件在平时的开发中会经常用到，可以省去繁琐的写法，很方便的写action，下面会用几篇文章分别对它里面的每个Api进行详细分析，还是像之前一样，分析源码的同时结合实际例子，帮助理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux-actions" scheme="http://yixirumeng.github.io/tags/redux-actions/"/>
    
  </entry>
  
  <entry>
    <title>redux-thunk源码分析</title>
    <link href="http://yixirumeng.github.io/2018/11/16/redux-thunk-source-code-analysis/"/>
    <id>http://yixirumeng.github.io/2018/11/16/redux-thunk-source-code-analysis/</id>
    <published>2018-11-16T10:53:27.000Z</published>
    <updated>2018-12-08T01:33:33.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-thunk-source-code-analysis.jpg" alt=""></p><blockquote><p>前面分析了redux所有api的源码，接下来分析一下redux常用中间件的源码。因为redux只能处理同步的数据变化，但很多时候需要ajax异步获取数据，所以就需要应用相关中间件来处理。这篇文章就来分析一下异步处理常用中间件<code>redux-thunk</code>的源码。</p></blockquote><a id="more"></a><h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p>因为应用中间件需要用到<code>applyMiddleware</code>这一api，所以要结合<code>applyMiddleware</code>的源码一起来分析。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span><span class="params">(<span class="rest_arg">...middlewares</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        之前分析过，applyMiddleware会作为createStore的第三个参数传入，</span></span><br><span class="line"><span class="comment">        最终会生成：enhancer(createStore)(reducer, preloadedState)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> createStore =&gt; (...args) =&gt; &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            所以，下面的store也就是去除掉enhancer之后并由createStore生成的函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">        let dispatch = () =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(</span><br><span class="line">                `Dispatching <span class="keyword">while</span> constructing your middleware <span class="keyword">is</span> not allowed. ` +</span><br><span class="line">                `Other middleware would not be applied to <span class="keyword">this</span> dispatch.`</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里获取到store的getState，以及根据上面的dispatch函数来设置新的dispatch</span></span><br><span class="line"><span class="comment">            将这些传入到中间件中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">            getState: store.getState,</span><br><span class="line">            dispatch: (...args) =&gt; dispatch(...args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            遍历每个中间件，并将middlewareAPI作为参数传入，并应用compose方法，将处理后的middleware</span></span><br><span class="line"><span class="comment">            和store原有的dispatch传入，再一次生成新的dispatch，替换掉上面的dispatch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line">        dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            最终导出store的每一项和dispatch，这里应用对象的解构使得新的dispatch替换了store原有的dispatch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><p>本以为<code>redux-thunk</code>内部实现会很复杂，但其源码就这几行，但要理解这几行代码也并非易事，还是要仔细分析一下。</p><p>结合上面以及之前的文章分析的<code>applyMiddleware</code>，来看一下<code>redux-thunk</code>的源码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    因为下面导出了thunk，而thunk是直接执行的createThunkMiddleware函数</span><br><span class="line">    也就是导出来createThunkMiddleware的返回值</span><br><span class="line">*/</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span><span class="params">(extraArgument)</span></span> &#123;</span><br><span class="line">    /*</span><br><span class="line">        这里应用的箭头函数，并以函数作为返回值一层一层传递下去，换成es5的写法是：</span><br><span class="line">        <span class="function"><span class="keyword">function</span><span class="params">(&#123; dispatch, getState &#125;)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(next)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(action)</span></span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (typeof action === <span class="string">'function'</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">next</span>(action);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        第一个函数的参数&#123; dispatch, getState &#125;正是上面middlewareAPI，</span><br><span class="line">            这里是应用了对象的解构，但是由于下面重新对dispatch进行赋值，</span><br><span class="line">            所以在我们写的action中的dispatch参数是增强后的dispatch</span><br><span class="line">            也就是compose(...chain)(store.dispatch)</span><br><span class="line">        第二个函数的参数<span class="built_in">next</span>正是上面分析过的store原有的dispatch方法，</span><br><span class="line">            这只是在只有一个中间件的时候，如果有多个中间件，且redux-thunk</span><br><span class="line">            不是最后一个的话，<span class="built_in">next</span>则是经过别的中间件处理后的函数</span><br><span class="line">        第三个函数的参数action正是我们平时写的action</span><br><span class="line">        然后对action进行判断，如果为函数，则将上面的dispatch、getState传入action中</span><br><span class="line">        如果不是函数，则直接返回<span class="built_in">next</span>(action)，也就是store.dispatch(action)</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">return</span> (&#123; dispatch, getState &#125;) =&gt; <span class="built_in">next</span> =&gt; action =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof action === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(action);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure><p>所以，我们平时在应用<code>redux-thunk</code>的时候，会定义一个函数，并返回一个新的函数，同时以<code>dispatch getState</code>作为参数</p><p>举例说明一下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                <span class="keyword">type</span>: INCREMENT</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个典型的应用<code>redux-thunk</code>异步action的写法，而返回函数的参数<code>dispatch getState</code>也正是上面我们分析过的</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面逐行代码的分析可以知道，正常<code>redux</code>定义的action只能是对象类型，但使用<code>redux-thunk</code>后，可以以函数作为action，而异步执行的操作可以在放在action函数体内，并在异步操作结束后再dispatch。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-thunk-source-code-analysis.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前面分析了redux所有api的源码，接下来分析一下redux常用中间件的源码。因为redux只能处理同步的数据变化，但很多时候需要ajax异步获取数据，所以就需要应用相关中间件来处理。这篇文章就来分析一下异步处理常用中间件&lt;code&gt;redux-thunk&lt;/code&gt;的源码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux-thunk" scheme="http://yixirumeng.github.io/tags/redux-thunk/"/>
    
  </entry>
  
  <entry>
    <title>Redux源码详细分析五 ———— applyMiddleware</title>
    <link href="http://yixirumeng.github.io/2018/11/13/redux-source-code-analysis-applyMiddleware/"/>
    <id>http://yixirumeng.github.io/2018/11/13/redux-source-code-analysis-applyMiddleware/</id>
    <published>2018-11-13T14:50:05.000Z</published>
    <updated>2018-11-14T11:34:57.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-source-code-analysis-applyMiddleware.jpg" alt=""></p><blockquote><p>applyMiddleware这个Api在应用Redux中间件时使用，比如平时开发用的react-redux、redux-thunk、redux-saga等工具，都需要应用applyMiddleware将其与redux结合才可以使用。</p></blockquote><a id="more"></a><h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p>applyMiddleware的源码也不多，但也需要仔细读一下才能理解：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//applyMiddleware接收任意多个function类型的参数，将其转换成数组传入，并返回一个高阶函数</span></span><br><span class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span><span class="params">(<span class="rest_arg">...middlewares</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        applyMiddleware会作为createStore的第三个参数传入，先来看一下createStore对应的代码：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            if (typeof enhancer !== 'undefined') &#123;</span></span><br><span class="line"><span class="comment">                if (typeof enhancer !== 'function') &#123;</span></span><br><span class="line"><span class="comment">                throw new Error('Expected the enhancer to be a function.')</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                return enhancer(createStore)(reducer, preloadedState)</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            先对其进行校验，如果已经传入并且是个function，则返回</span></span><br><span class="line"><span class="comment">                enhancer(createStore)(reducer, preloadedState)</span></span><br><span class="line"><span class="comment">            这里的参数createStore即之前的createStore方法，</span></span><br><span class="line"><span class="comment">            后面两个参数就是createStore传入的前两个参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> createStore =&gt; (...args) =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            根据上面分析，这里的store得到的就是createStore(reducer, preloadedState)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里定义的dispatch函数的作用是，当用中间件重新构建createStore还未结束时，应用dispatch会报错</span></span><br><span class="line">        let dispatch = () =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(</span><br><span class="line">                `Dispatching <span class="keyword">while</span> constructing your middleware <span class="keyword">is</span> not allowed. ` +</span><br><span class="line">                `Other middleware would not be applied to <span class="keyword">this</span> dispatch.`</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里定义的middlewareAPI将作为默认的参数传入每个中间件中，</span></span><br><span class="line"><span class="comment">            其中getState为当前的store.getState，dispatch为上面定义的函数，并将reducer、preloadedState传入，</span></span><br><span class="line"><span class="comment">            这个middlewareAPI的作用就是让中间件可以调用到原来的store</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">            getState: store.getState,</span><br><span class="line">            dispatch: (...args) =&gt; dispatch(...args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历传入的中间件，然后将middlewareAPI传入每个中间件中，执行后，最终得到一个中间件数组</span></span><br><span class="line">        <span class="keyword">const</span> chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            中间件的个数可以为任意多个，调用compose方法，并将store.dispatch作为后续的参数传入，并得到新的dispatch</span></span><br><span class="line"><span class="comment">            最终的样子为：</span></span><br><span class="line"><span class="comment">                dispatch = middleware1(middleware2(middleware3(store.dispatch)))</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            因为createStore返回多个Api函数，所以这里应用...对其进行扩展，同时用新得到的dispatch替换之前的dispatch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析可以知道，applyMiddleware最终返回的还是一个createStore，只不过是应用了其它中间件进行封装，并更改了dispatch这一Api</p><h3 id="applyMiddleware实例："><a href="#applyMiddleware实例：" class="headerlink" title="applyMiddleware实例："></a>applyMiddleware实例：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里引入redux-thunk和redux-saga两个库，应用applyMiddleware时，根据上面分析可知：</span></span><br><span class="line"><span class="comment">    首先会得到store = createStore(reducer, preloadedState)，</span></span><br><span class="line"><span class="comment">    每个中间件都会调用上面提到的middlewareAPI，也就是中间件可以获得原来store的getState、reducer和preloadedState</span></span><br><span class="line"><span class="comment">    得到：</span></span><br><span class="line"><span class="comment">        chain = [newSagaMiddleware, newThunk]</span></span><br><span class="line"><span class="comment">    再chain放入compose方法内，并将store.dispatch作为后续的参数传入</span></span><br><span class="line"><span class="comment">    所以得到的结果是：</span></span><br><span class="line"><span class="comment">        dispatch = newSagaMiddleware(newThunk(store.dispatch))</span></span><br><span class="line"><span class="comment">    最终会返回所有createStore内部的Api方法，并将原有dispatch替换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> applyMiddleware(</span><br><span class="line">    sagaMiddleware,</span><br><span class="line">    thunk</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>所以，applyMiddleware并不会改变原来createStore内部除dispatch之外的其它方法，因为在日常应用中间件的时候，大多是在处理异步、观察日志等场景下应用，而这些场景都是要在派发action时触发。可以有人会说react-redux这个常用的中间件是要在每个组件中都获取到状态，这不需要更改getState吗？其实这个中间件并不会改变原有的getState方法，因为它是应用了React的context Api将数据传递到每个组件中，后续也会推出react-redux这一中间件的源码分析。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上的五篇文章分别对Redux中五个Api进行了具体分析，经过详细解读后，其实可以发现，Redux底层的实现原理并不复杂，每一个Api的内部逻辑相对来说都很清晰，但每一个的内部都运用了大量的Javascript的基础知识，像闭包、原型链、高阶函数、ES6等，尤其是闭包，redux可以说将其发挥到了极致，这也正是表明了这个库为什么如此受欢迎。</p><p>通过源码分析，可以加深对Redux整体架构的理解，同时在日常开发中使用起来能够更加得心应手。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-source-code-analysis-applyMiddleware.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;applyMiddleware这个Api在应用Redux中间件时使用，比如平时开发用的react-redux、redux-thunk、redux-saga等工具，都需要应用applyMiddleware将其与redux结合才可以使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://yixirumeng.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Redux源码详细分析四 ———— compose</title>
    <link href="http://yixirumeng.github.io/2018/11/12/redux-source-code-analysis-compose/"/>
    <id>http://yixirumeng.github.io/2018/11/12/redux-source-code-analysis-compose/</id>
    <published>2018-11-12T14:14:43.000Z</published>
    <updated>2018-11-14T11:33:57.064Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-source-code-analysis-compose.jpg" alt=""></p><blockquote><p>compose这个Api主要是对函数的调用进行组合，即执行完一个函数得到结果后，传入下一个函数中，以此类推，而函数的调用顺序是自右向左</p></blockquote><a id="more"></a><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>源码很简单，但是内部的逻辑不是很容易懂：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compose方法接收任意多个参数，每个参数都为一个function，并把这些参数组合成数组传入</span></span><br><span class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span><span class="params">(<span class="rest_arg">...funcs</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有传入任何方法，这直接执行后续的调用，即compose()('hello')会直接得到hello</span></span><br><span class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg =&gt; arg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果传入一个方法，则直接调用这个方法</span></span><br><span class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        当参数的个数大于1时，会执行以下方法，这里调用了数组的reduce方法，</span></span><br><span class="line"><span class="comment">        并返回一个function，后续的参数作为这个function的参数传入。</span></span><br><span class="line"><span class="comment">        换成es5的写法是这样：</span></span><br><span class="line"><span class="comment">            funcs.reduce(function(a, b)&#123;</span></span><br><span class="line"><span class="comment">                return function()&#123;</span></span><br><span class="line"><span class="comment">                    return a(b.bind(undefined, arguments))</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;)</span></span><br><span class="line"><span class="comment">        数组的reduce方法是这样：</span></span><br><span class="line"><span class="comment">            [1, 2, 3].reduce((a, b) =&gt; (a + b))结果为6，</span></span><br><span class="line"><span class="comment">            其执行顺序是正序，即第一次：a=1、b=2，a+b=3；第二次：a=3、b=3，a+b=6返回</span></span><br><span class="line"><span class="comment">        而下面的方法中数组的每一项都为function，所以第一项会在最后执行，最后一项会最先执行，即：</span></span><br><span class="line"><span class="comment">            compose(f, g, h)(...args)相当于f(g(h(...args)))</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compose这个Api虽然看上去简单，但要理解还是不容易的，明白reduce的执行原理，就会轻松很多</p><h3 id="compose应用实例"><a href="#compose应用实例" class="headerlink" title="compose应用实例"></a>compose应用实例</h3><p>平时在用redux时，为了方便调试会应用redux-devtools工具，而这个工具的用法如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里传入的参数只有一个function，即applyMiddleware(thunk)，</span></span><br><span class="line"><span class="comment">    根据上面的判断，会直接执行applyMiddleware(thunk)，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, composeEnhancers(</span><br><span class="line">    applyMiddleware(thunk)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>传入多个参数的情况会在分析applyMiddleware这个Api中提到。</p><p>其实，不止在redux中，很多库或者平时开发中都可以应用compose方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-source-code-analysis-compose.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;compose这个Api主要是对函数的调用进行组合，即执行完一个函数得到结果后，传入下一个函数中，以此类推，而函数的调用顺序是自右向左&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://yixirumeng.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Redux源码详细分析三 ———— bindActionCreators</title>
    <link href="http://yixirumeng.github.io/2018/11/11/redux-source-code-analysis-bindActionCreators/"/>
    <id>http://yixirumeng.github.io/2018/11/11/redux-source-code-analysis-bindActionCreators/</id>
    <published>2018-11-11T05:41:29.000Z</published>
    <updated>2018-11-14T11:33:02.572Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-source-code-analysis-bindActionCreators.jpg" alt=""></p><blockquote><p>bindActionCreators这个Api在平时的开发中应用不是很多，它主要是用于在没有引入store的子组件中，可以让子组件不直接应用dispatch来派发action，更改state。但实际开发中更多会应用react-redux这个库，而react-redux已经对其进行了封装。</p></blockquote><a id="more"></a><h3 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h3><p>先来看一下其源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是bindActionCreators调用的公共方法，其内部就是dispatch一个action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bindActionCreators接收两个参数，类型为function或object的actionCreators和store的dispatch方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果actionCreators传入的值函数，则直接dispatch，因为只有一个actionCreator</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对actionCreators进行类型判断，不是object或者为null时，会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators !== <span class="string">'object'</span> || actionCreators === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`bindActionCreators expected an object or a function, instead received <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            actionCreators === <span class="literal">null</span> ? <span class="string">'null'</span> : <span class="keyword">typeof</span> actionCreators</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>. `</span> +</span><br><span class="line">            <span class="string">`Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时的actionCreators是一个object，对其进行遍历，并将每一项放入自定义的boundActionCreators中，</span></span><br><span class="line"><span class="comment">        相当于深拷贝一份，然后再对每一项执行bindActionCreator方法，也就是对每一项派发action</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(actionCreators)</span><br><span class="line">    <span class="keyword">const</span> boundActionCreators = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[i]</span><br><span class="line">        <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bindActionCreators的逻辑很简单，就是先遍历，然后分别执行</p><h3 id="bindActionCreators实际例子："><a href="#bindActionCreators实际例子：" class="headerlink" title="bindActionCreators实际例子："></a>bindActionCreators实际例子：</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//store.js</span><br><span class="line"></span><br><span class="line">const initialState = &#123; num: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">export const increment = () =&gt; (&#123; type: 'INCREMENT' &#125;)</span><br><span class="line">export const decrement = () =&gt; (&#123; type: 'DECREMENT' &#125;)</span><br><span class="line"></span><br><span class="line">const numReducer = (<span class="keyword">state</span>=initialState, action) =&gt; &#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">        case 'INCREMENT':</span><br><span class="line">            return &#123; ...<span class="keyword">state</span>, num: <span class="keyword">state</span>.num+<span class="number">1</span> &#125;</span><br><span class="line">        case 'DECREMENT':</span><br><span class="line">            return &#123; ...<span class="keyword">state</span>, num: <span class="keyword">state</span>.num-<span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            return <span class="keyword">state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export numStore = createStore(numReducer)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = numStore.getState()</span><br><span class="line">        numStore.subscribe(<span class="keyword">this</span>.handleChange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(numStore.getState())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; num &#125; = <span class="keyword">this</span>.state</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            将increment、decrement两个actionCreator和numStore.dispatch方法传入到bindActionCreators中，</span></span><br><span class="line"><span class="comment">            就相当于遍历&#123; increment, decrement &#125;这个对象，得到两个函数，最后以这个对象的key作为key，</span></span><br><span class="line"><span class="comment">            以函数作为value的object形式返回，所以actionCreators为：</span></span><br><span class="line"><span class="comment">            actionCreators = &#123;</span></span><br><span class="line"><span class="comment">                increment: () =&gt; numStore.dispatch(increment()),</span></span><br><span class="line"><span class="comment">                decrement: () =&gt; numStore.dispatch(decrement())</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            传入Title子组件，而子组件按钮分别绑定这两个事件，当点击时会派发对应的action，num也得到对应的更新</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> actionCreators = numStore.bindActionCreators(&#123; increment, decrement &#125;, numStore.dispatch)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;&#123; num &#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Title &#123; ...actionCreators &#125;/</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//title.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; increment, decrement &#125; = <span class="keyword">this</span>.props</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123; increment &#125;&gt;increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123; decrement &#125;&gt;decrement&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>bindActionCreators这个Api没有什么难点，就是组合在遍历执行，平时应用较少，因为组件嵌套多了，会不方便管理，如果只是在当前组件，则没必要使用，直接dispatch(action)会更方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-source-code-analysis-bindActionCreators.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bindActionCreators这个Api在平时的开发中应用不是很多，它主要是用于在没有引入store的子组件中，可以让子组件不直接应用dispatch来派发action，更改state。但实际开发中更多会应用react-redux这个库，而react-redux已经对其进行了封装。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://yixirumeng.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Redux源码详细分析二 ———— combineReducer</title>
    <link href="http://yixirumeng.github.io/2018/11/10/redux-source-code-analysis-combineReducer/"/>
    <id>http://yixirumeng.github.io/2018/11/10/redux-source-code-analysis-combineReducer/</id>
    <published>2018-11-10T02:37:20.000Z</published>
    <updated>2018-11-14T11:32:12.371Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-source-code-analysis-combineReducer.jpg" alt=""></p><blockquote><p>上一篇分析了createStore，这篇来分析一下combineReducer。当业务复杂的时候，会将reducer拆开，但createStore传入的只能是一个reducer，这个时候就需要combineReducer将所有的reducer结合起来。</p></blockquote><a id="more"></a><h3 id="combineReducer"><a href="#combineReducer" class="headerlink" title="combineReducer"></a>combineReducer</h3><p>看一下combineReducer的源码来进行分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//combineReducers方法接收对象形式的reducers，也就是&#123; a: reducerA, b: reducerB &#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取reducers的key，然后进行遍历，放入到finalReducers，其实相当于深拷贝一份reducers</span></span><br><span class="line">    <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">    <span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                warning(<span class="string">`No reducer provided for key "<span class="subst">$&#123;key&#125;</span>"`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">            finalReducers[key] = reducers[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> unexpectedKeyCache</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        unexpectedKeyCache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里调用了校验方法assertReducerShape，检查每个reducer是否有默认状态</span></span><br><span class="line">    <span class="keyword">let</span> shapeAssertionError</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        assertReducerShape(finalReducers)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        shapeAssertionError = e</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">        最终返回combination，而combination的两个参数是state和action，这正是reducer结构，</span></span><br><span class="line"><span class="comment">        所以combineReducers最终返回的还是一个reducer，只不过就是经过封装之后的reducer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果某个reducer没有返回默认状态，则会报错</span></span><br><span class="line">        <span class="keyword">if</span> (shapeAssertionError) &#123;</span><br><span class="line">            <span class="keyword">throw</span> shapeAssertionError</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用getUnexpectedStateShapeWarningMessage对reducers、state、action等做进一步校验</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> warningMessage = getUnexpectedStateShapeWarningMessage(</span><br><span class="line">                state,</span><br><span class="line">                finalReducers,</span><br><span class="line">                action,</span><br><span class="line">                unexpectedKeyCache</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (warningMessage) &#123;</span><br><span class="line">                warning(warningMessage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设定一个state是否变化的状态，以及改变后的state的初始值</span></span><br><span class="line">        <span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            遍历每个reducer，同时找到该reducer对应的state，然后把这个state和action传入到reducer中，</span></span><br><span class="line"><span class="comment">            如果在reducer中找到对应的action.type则进行状态更新，否则返回原始状态，</span></span><br><span class="line"><span class="comment">            最终会判断当前后两个state是否相同，如果相同则返回之前传入的state，否则会返回改变后的state</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            这里注意一个问题，在createStore时，会默认派发一次action，而这次派发会得到所有reducer的初始状态，</span></span><br><span class="line"><span class="comment">            然后将这些状态拼到一个大的state中，以reducers的key作为这个大state的key，value就是每个reducer对应初始state，</span></span><br><span class="line"><span class="comment">            这样state[key]就可以获取到当前reducer对应的state</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">            <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">            <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">            <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">            &#125;</span><br><span class="line">            nextState[key] = nextStateForKey</span><br><span class="line">            hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------校验函数---------------</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的作用是校验每个reducer是否有返回默认状态，如果没有回报错，如果确实不用返回默认状态，则返回null替代什么都不返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUndefinedStateErrorMessage</span>(<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> actionType = action &amp;&amp; action.type</span><br><span class="line">    <span class="keyword">const</span> actionDescription =</span><br><span class="line">        (actionType &amp;&amp; <span class="string">`action "<span class="subst">$&#123;<span class="built_in">String</span>(actionType)&#125;</span>"`</span>) || <span class="string">'an action'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`Given <span class="subst">$&#123;actionDescription&#125;</span>, reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined. `</span> +</span><br><span class="line">        <span class="string">`To ignore an action, you must explicitly return the previous state. `</span> +</span><br><span class="line">        <span class="string">`If you want this reducer to hold no value, you can return null instead of undefined.`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的主要作用是对传入的reducers、传入的state、以及初始状态做进一步校验</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUnexpectedStateShapeWarningMessage</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    inputState,</span></span></span><br><span class="line"><span class="function"><span class="params">    reducers,</span></span></span><br><span class="line"><span class="function"><span class="params">    action,</span></span></span><br><span class="line"><span class="function"><span class="params">    unexpectedKeyCache</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">    <span class="keyword">const</span> argumentName =</span><br><span class="line">        action &amp;&amp; action.type === ActionTypes.INIT</span><br><span class="line">        ? <span class="string">'preloadedState argument passed to createStore'</span></span><br><span class="line">        : <span class="string">'previous state received by the reducer'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reducerKeys.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">'Store does not have a valid reducer. Make sure the argument passed '</span> +</span><br><span class="line">        <span class="string">'to combineReducers is an object whose values are reducers.'</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(inputState)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`The <span class="subst">$&#123;argumentName&#125;</span> has unexpected type of "`</span> +</span><br><span class="line">        &#123;&#125;.toString.call(inputState).match(<span class="regexp">/\s([a-z|A-Z]+)/</span>)[<span class="number">1</span>] +</span><br><span class="line">        <span class="string">`". Expected argument to be an object with the following `</span> +</span><br><span class="line">        <span class="string">`keys: "<span class="subst">$&#123;reducerKeys.join(<span class="string">'", "'</span>)&#125;</span>"`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> unexpectedKeys = <span class="built_in">Object</span>.keys(inputState).filter(</span><br><span class="line">        key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    unexpectedKeys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        unexpectedKeyCache[key] = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (action &amp;&amp; action.type === ActionTypes.REPLACE) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unexpectedKeys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="string">`Unexpected <span class="subst">$&#123;unexpectedKeys.length &gt; <span class="number">1</span> ? <span class="string">'keys'</span> : <span class="string">'key'</span>&#125;</span> `</span> +</span><br><span class="line">        <span class="string">`"<span class="subst">$&#123;unexpectedKeys.join(<span class="string">'", "'</span>)&#125;</span>" found in <span class="subst">$&#123;argumentName&#125;</span>. `</span> +</span><br><span class="line">        <span class="string">`Expected to find one of the known reducer keys instead: `</span> +</span><br><span class="line">        <span class="string">`"<span class="subst">$&#123;reducerKeys.join(<span class="string">'", "'</span>)&#125;</span>". Unexpected keys will be ignored.`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个校验方法主要作用是检查每个reducer里有没有默认的返回状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertReducerShape</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(reducers).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> reducer = reducers[key]</span><br><span class="line">        <span class="keyword">const</span> initialState = reducer(<span class="literal">undefined</span>, &#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">`Reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined during initialization. `</span> +</span><br><span class="line">                <span class="string">`If the state passed to the reducer is undefined, you must `</span> +</span><br><span class="line">                <span class="string">`explicitly return the initial state. The initial state may `</span> +</span><br><span class="line">                <span class="string">`not be undefined. If you don't want to set a value for this reducer, `</span> +</span><br><span class="line">                <span class="string">`you can use null instead of undefined.`</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="keyword">typeof</span> reducer(<span class="literal">undefined</span>, &#123;</span><br><span class="line">                type: ActionTypes.PROBE_UNKNOWN_ACTION()</span><br><span class="line">            &#125;) === <span class="string">'undefined'</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">`Reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined when probed with a random type. `</span> +</span><br><span class="line">                <span class="string">`Don't try to handle <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">                    ActionTypes.INIT</span></span></span><br><span class="line"><span class="string"><span class="subst">                &#125;</span> or other actions in "redux/*" `</span> +</span><br><span class="line">                <span class="string">`namespace. They are considered private. Instead, you must return the `</span> +</span><br><span class="line">                <span class="string">`current state for any unknown actions, unless it is undefined, `</span> +</span><br><span class="line">                <span class="string">`in which case you must return the initial state, regardless of the `</span> +</span><br><span class="line">                <span class="string">`action type. The initial state may not be undefined, but can be null.`</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过上述的分析，其实combineReducers方法就是组合所有传入的reducer，最终返回一个组合后的reducer，其本质还是个reducer，因为createStore接收的第一个参数必须是个纯函数的reducer。当派发action进行state更新时，这个组合后的reducer会遍历所有传入的reducer，找到action.type对应的reducer并进行更改，最终会为了优化，只返回有更改的state。</strong></p><h3 id="combineReducers实例："><a href="#combineReducers实例：" class="headerlink" title="combineReducers实例："></a>combineReducers实例：</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">const numState = &#123; num: <span class="number">1</span> &#125;</span><br><span class="line">const strState = &#123; str: 'hello' &#125;</span><br><span class="line"></span><br><span class="line">const numReducer = (<span class="keyword">state</span>=numState, action) =&gt; &#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">        case 'INCREMENT':</span><br><span class="line">            return &#123; ...<span class="keyword">state</span>, num: <span class="keyword">state</span>.num+<span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            return <span class="keyword">state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const strReducer = (<span class="keyword">state</span>=strState, action) =&gt; &#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">        case 'CHANGE':</span><br><span class="line">            return &#123; ...<span class="keyword">state</span>, str: <span class="keyword">state</span>.str+' world!' &#125;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            return <span class="keyword">state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reducers = combineReducers(&#123; numR: numReducer, strR: strReducer &#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    这里通过combineReducers组合了numReducer、strReducer返回了reducers，放入createStore中，</span><br><span class="line">    而createStore会默认派发一次type为随机数的action，获取最终的组合的<span class="keyword">state</span>，对于这个例子，则是：</span><br><span class="line">        <span class="keyword">state</span> = &#123;</span><br><span class="line">            numR: &#123; num: <span class="number">1</span> &#125;,</span><br><span class="line">            strR: &#123; str: 'hello' &#125;</span><br><span class="line">        &#125;</span><br><span class="line">*/</span><br><span class="line">const store = createStore(reducers)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    当派发下面这个change的action时，首先会遍历所有的reducer：</span><br><span class="line">    <span class="number">1</span>、第一个找到numReducer，然后根据<span class="keyword">state</span>[numR]找到其状态是numState=&#123; num: <span class="number">1</span> &#125;，并将numState以及change的action传入，</span><br><span class="line">       因为没有对应的type，所以返回默认值，而这个默认值与之前找到的numState相同，则不改变<span class="keyword">state</span></span><br><span class="line">    <span class="number">2</span>、第二个找到strReducer，根据<span class="keyword">state</span>[strR]找到其状态是strState=&#123; str: 'hello' &#125;，并将strState以及change的action传入，</span><br><span class="line">        在strReducer中找到对应的type，将strState改为&#123; str: 'hello world!' &#125;并返回，因为跟之前的strState不一样，</span><br><span class="line">        所以会将<span class="keyword">state</span>中strR的value改成&#123; str: 'hello world!' &#125;，最终就可以取得更新之后<span class="keyword">state</span></span><br><span class="line">*/</span><br><span class="line">const change = () =&gt; (&#123; type: 'CHANGE' &#125;)</span><br><span class="line">dispatch(change())</span><br></pre></td></tr></table></figure><p>结合源码分析以及实际例子可以清晰知道combineReducers的内部实现原理，其实并不复杂，与单个reducer的逻辑基本一致，只不过加了一层封装。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-source-code-analysis-combineReducer.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上一篇分析了createStore，这篇来分析一下combineReducer。当业务复杂的时候，会将reducer拆开，但createStore传入的只能是一个reducer，这个时候就需要combineReducer将所有的reducer结合起来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://yixirumeng.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Redux源码详细分析一 ———— createStore</title>
    <link href="http://yixirumeng.github.io/2018/11/09/redux-source-code-analysis-createStore/"/>
    <id>http://yixirumeng.github.io/2018/11/09/redux-source-code-analysis-createStore/</id>
    <published>2018-11-09T12:19:35.000Z</published>
    <updated>2018-11-14T11:30:56.837Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/redux-source-code-analysis-createStore.jpg" alt=""></p><blockquote><p>在React框架开发应用时，作为状态管理工具的Redux会经常用到，接下来的这几篇文章会从源码上逐个分析Redux中的每个Api，并结合例子帮助理解，这样可以在以后的开发中更加熟练应用。</p></blockquote><a id="more"></a><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>用过Redux肯定会知道，这个Api是其最重要的一个，也是Redux的入口。下面先看一下其源码（这里省略了两个不常用到的方法），然后会每一步做了什么进行分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其实就是一个函数，接收三个参数，reducer、初始状态（preloadedState）、应用的中间件（enhancer）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对preloadedState和enhancer进行函数校验，如果校验不通过会报出错误</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'function'</span>) ||</span><br><span class="line">        (<span class="keyword">typeof</span> enhancer === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">3</span>] === <span class="string">'function'</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'It looks like you are passing several store enhancers to '</span> +</span><br><span class="line">            <span class="string">'createStore(). This is not supported. Instead, compose them '</span> +</span><br><span class="line">            <span class="string">'together to a single function'</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果第二个参数是function，且第三个参数为undefined，则将其交换，这也就是平时可以不写初始状态，直接写应用中间件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        enhancer = preloadedState</span><br><span class="line">        preloadedState = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果enhancer定义了，但不是function，就会报出错误，如果校验通过则执行对应的方法（这块涉及到中间件的应用，后续介绍）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果reducer不是函数，也会报出错误，这也就是平时要求reducer必须是一个纯函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一些变量，并把赋予相应的参数值</span></span><br><span class="line">    <span class="keyword">let</span> currentReducer = reducer</span><br><span class="line">    <span class="keyword">let</span> currentState = preloadedState</span><br><span class="line">    <span class="keyword">let</span> currentListeners = []</span><br><span class="line">    <span class="keyword">let</span> nextListeners = currentListeners</span><br><span class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果nextListeners与currentListeners相等，则调用数组的slice方法，对其进行深拷贝，防止后续因为引用类型出现错误</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">            nextListeners = currentListeners.slice()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这个方法就是在开发是应用的getState方法，这里对其进行了判断，如果不是在派发的过程中，</span></span><br><span class="line"><span class="comment">        就会应用闭包的方式返回currentState，而currentState在上面已经赋值，正是传入的第二个参数preloadedState。</span></span><br><span class="line"><span class="comment">        可能会问，如果第二个参数没传，那不是undefined吗？不要着急，接着看就能明白</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">'You may not call store.getState() while the reducer is executing. '</span> +</span><br><span class="line">                <span class="string">'The reducer has already received the state as an argument. '</span> +</span><br><span class="line">                <span class="string">'Pass it down from the top reducer instead of reading it from the store.'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这个方法就是在开发是调用的subscribe方法，当状态发生改变的时候，它就会执行，</span></span><br><span class="line"><span class="comment">        它接收一个需要监听的listener，这个listener必须是个函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断listener是否是个函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the listener to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前的状态是否真正派发更新</span></span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">'You may not call store.subscribe() while the reducer is executing. '</span> +</span><br><span class="line">                <span class="string">'If you would like to be notified after the store has been updated, subscribe from a '</span> +</span><br><span class="line">                <span class="string">'component and invoke store.getState() in the callback to access the latest state. '</span> +</span><br><span class="line">                <span class="string">'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里应用了刚才定义的函数，然后向nextListeners追加传入的listener，这个nextListeners在后续会用到</span></span><br><span class="line">        ensureCanMutateNextListeners()</span><br><span class="line">        nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回的这个函数的作用是在nextListeners中移除传入的listener</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                    <span class="string">'You may not unsubscribe from a store listener while the reducer is executing. '</span> +</span><br><span class="line">                    <span class="string">'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isSubscribed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            ensureCanMutateNextListeners()</span><br><span class="line">            <span class="keyword">const</span> index = nextListeners.indexOf(listener)</span><br><span class="line">            nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这个是在开发中调用的dispatch方法，它的作用就是当需要改变状态的时候，派发dispatch进行更新，</span></span><br><span class="line"><span class="comment">        它接收action参数，而这个action必须是一个plain对象，也就是这样&#123;type: 'ADD'&#125;直接定义的对象，</span></span><br><span class="line"><span class="comment">        这个对象的原型必须是Object，构造函数是Object()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对action进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">                <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果action中没有type，则会报错，这也就是平时开发时需要为每个action都指定type</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">                <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是正在派发的过程中，会报错</span></span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            平时可能用try..catch..用的比较多，而这个try...finally...的意思是当执行完try，会继续执行finally。</span></span><br><span class="line"><span class="comment">            首先将状态执为正在派发状态，然后调用传入的reducer方法，并将默认的状态以及action传入到reducer中，</span></span><br><span class="line"><span class="comment">            也就是执行平时在reducer中定义的if、switch条件判断，最后将得到的结果赋值给currentState。</span></span><br><span class="line"><span class="comment">            所有都执行完后，再将状态执回。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">true</span></span><br><span class="line">            currentState = currentReducer(currentState, action)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里就用到了上面提到的nextListeners，会遍历其中的每个listener，然后执行，</span></span><br><span class="line"><span class="comment">            这也就是要求listener必须是函数，同时也实现了每次dispatch时，subcribe订阅的listener都会得到更新</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">const</span> listeners = (currentListeners = nextListeners)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> listener = listeners[i]</span><br><span class="line">            listener()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这个dispatch非常重要，在createStore时会默认派发一次dispatch，</span></span><br><span class="line"><span class="comment">        而传入的这个action.type是随机生成的（下面是随机生成的代码），</span></span><br><span class="line"><span class="comment">        执行这个dispatch就是为了获取在定义reducer时传入的默认state，</span></span><br><span class="line"><span class="comment">        因为在写reducer时，不管是用if还是用switch，都需要写不符合所有条件的默认返回值，</span></span><br><span class="line"><span class="comment">        而这个返回值就是定义的初始状态。这样在调用getState方法时，就可以得到初始状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果没有传入preloadedState，那刚开始currentState就是undefined，而派发了这次dispatch就可以对其重新赋值，</span></span><br><span class="line"><span class="comment">        也就回答了上面如果第二参数为undefined的问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        const randomString = () =&gt;</span></span><br><span class="line"><span class="comment">            Math.random()</span></span><br><span class="line"><span class="comment">            .toString(36)</span></span><br><span class="line"><span class="comment">            .substring(7)</span></span><br><span class="line"><span class="comment">            .split('')</span></span><br><span class="line"><span class="comment">            .join('.')</span></span><br><span class="line"><span class="comment">        const ActionTypes = &#123;</span></span><br><span class="line"><span class="comment">            INIT: `@@redux/INIT$&#123;randomString()&#125;`,</span></span><br><span class="line"><span class="comment">            REPLACE: `@@redux/REPLACE$&#123;randomString()&#125;`,</span></span><br><span class="line"><span class="comment">            PROBE_UNKNOWN_ACTION: () =&gt; `@@redux/PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;`</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe,</span><br><span class="line">        getState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面逐条代码的分析可以看出，redux的createStore内部实现原理其实并不复杂，将状态同一进行管理，当需要改变的时候，必须派发更新操作，也就是dispatch(action)，而不可以直接对state进行赋值。</p><h3 id="在React中应用Redux实例："><a href="#在React中应用Redux实例：" class="headerlink" title="在React中应用Redux实例："></a>在React中应用Redux实例：</h3><p>分析完源码，下面结合具体例子来说明一下（部分地方省略）：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//store.js</span><br><span class="line"></span><br><span class="line">export const increment = () =&gt; (&#123; type: 'INCREMENT' &#125;) </span><br><span class="line"></span><br><span class="line">const initialState = &#123; num: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">const numReducer = (<span class="keyword">state</span>=initialState, action) =&gt; &#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">        case 'INCREMENT':</span><br><span class="line">            return &#123; ...<span class="keyword">state</span>, num: <span class="keyword">state</span>.num+<span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            return <span class="keyword">state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里面的initialState可不传，上面的分析可以知道，会默认派发一次action，所以还是可以得到这里的initialState</span><br><span class="line">export const numStore = createStore(numReducer, initialState)</span><br></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//App.js</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line"></span><br><span class="line">        //应用getState获取初始<span class="keyword">state</span>，因为在createStore中默认派发一次action，得到reducer中默认返回的初始状态</span><br><span class="line">        this.<span class="keyword">state</span> = numStore.getState()</span><br><span class="line"></span><br><span class="line">        //监听handleChange方法，将handleChange放入nextListeners中，当有dispatch(action)时执行handleChange</span><br><span class="line">        numStore.subscribe(this.handleChange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        //调用<span class="built_in">set</span>State改变<span class="keyword">state</span></span><br><span class="line">        this.<span class="built_in">set</span>State(numStore.getState())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        const &#123; num &#125; = this.<span class="keyword">state</span></span><br><span class="line">        return (</span><br><span class="line">            <span class="variable">&lt;div&gt;</span></span><br><span class="line">                <span class="variable">&lt;p&gt;</span>&#123; num &#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">                /*</span><br><span class="line">                    点击按钮，派发之前定义的action，得到变化后的<span class="keyword">state</span>，同时触发订阅的handleChange方法，</span><br><span class="line">                    改变当前的<span class="keyword">state</span>，最后重新执行render方法，渲染页面</span><br><span class="line">                */</span><br><span class="line">                <span class="variable">&lt;button onClick=&#123; () =&gt;</span> dispatch(increment()) &#125;&gt;increment&lt;/button&gt;</span><br><span class="line">            <span class="variable">&lt;div&gt;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个简单的例子并结合上面的源码分析，可以清晰的知道Redux内部具体做了什么，其实再复杂的项目，内部Redux的实现都是一样的，都是像上面分析的一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/redux-source-code-analysis-createStore.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在React框架开发应用时，作为状态管理工具的Redux会经常用到，接下来的这几篇文章会从源码上逐个分析Redux中的每个Api，并结合例子帮助理解，这样可以在以后的开发中更加熟练应用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://yixirumeng.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>React16新的context Api</title>
    <link href="http://yixirumeng.github.io/2018/11/06/react16-context-Api/"/>
    <id>http://yixirumeng.github.io/2018/11/06/react16-context-Api/</id>
    <published>2018-11-06T11:23:55.000Z</published>
    <updated>2018-11-14T11:29:19.830Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/react16-context-Api.jpg" alt=""></p><blockquote><p>context Api，主要用于跨组件间的数据传递，如果不用context Api，那一级组件如果要给三级组件传递数据，就会很麻烦，需要先用props传递给二级组件，二级组件再用props传给三级组件，如果再有回传也是一样的道理，一层一层的传递，这会很麻烦，如果应用context Api就会很方便。其实在React16之前的版本中，已经有context Api，但在16.3版本之后，React官方对其进行更改，使其更加方便，效率、性能都得到了提升。</p></blockquote><a id="more"></a><h3 id="用法：（部分导入导出省略）"><a href="#用法：（部分导入导出省略）" class="headerlink" title="用法：（部分导入导出省略）"></a>用法：（部分导入导出省略）</h3><h4 id="一级组件向三级组件传递数据："><a href="#一级组件向三级组件传递数据：" class="headerlink" title="一级组件向三级组件传递数据："></a>一级组件向三级组件传递数据：</h4><p>一级组件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; createContext, <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t'</span><br><span class="line"></span><br><span class="line">export const &#123; <span class="type">Provider</span>, <span class="type">Consumer</span> &#125; =  createContext()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;<span class="type">Provider</span> value=&#123;&#123; title: <span class="symbol">'hell</span>o', color: <span class="symbol">'re</span>d' &#125;&#125;&gt;</span><br><span class="line">                &lt;<span class="type">Header</span>/&gt;</span><br><span class="line">            &lt;/<span class="type">Provider</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级组件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;<span class="type">Title</span>/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三级组件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="type">Consumer</span> &#125; from './<span class="type">App</span>.js'</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;<span class="type">Consumer</span>&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    context =&gt; (</span><br><span class="line">                        &lt;h1 style=&#123;&#123; color: context.color &#125;&#125;&gt;</span><br><span class="line">                            &#123; context.title &#125;</span><br><span class="line">                        &lt;/h1&gt;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/<span class="type">Consumer</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，应用了context Api传递数据会很方便，在value中定义好就可以，不用一级一级的传递。用过react-redux会感觉很相似，其实react-redux内部的实现也是借助了context Api，只不过目前安装的版本还没有正式应用新的context Api，但已经开发出了新的版本，可以在其github仓库里找到。</p><h4 id="三级组件向一级组件传递数据："><a href="#三级组件向一级组件传递数据：" class="headerlink" title="三级组件向一级组件传递数据："></a>三级组件向一级组件传递数据：</h4><p>一级组件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; createContext, <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t'</span><br><span class="line"></span><br><span class="line">export const &#123; <span class="type">Provider</span>, <span class="type">Consumer</span> &#125; =  createContext()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleClick = (<span class="keyword">val</span>) =&gt; &#123;</span><br><span class="line">        console.log(<span class="keyword">val</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;<span class="type">Provider</span> value=&#123;&#123; title: <span class="symbol">'hell</span>o', color: <span class="symbol">'re</span>d', handleClick: <span class="keyword">this</span>.handleClick &#125;&#125;&gt;</span><br><span class="line">                &lt;<span class="type">Header</span>/&gt;</span><br><span class="line">            &lt;/<span class="type">Provider</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级组件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;<span class="type">Title</span>/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三级组件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="type">Consumer</span> &#125; from './<span class="type">App</span>.js'</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    btnClick = (fn) =&gt; &#123;</span><br><span class="line">        fn(<span class="symbol">'worl</span>d')</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;<span class="type">Consumer</span>&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    context =&gt; (</span><br><span class="line">                        &lt;div&gt;</span><br><span class="line">                            &lt;h1 style=&#123;&#123; color: context.color &#125;&#125;&gt;</span><br><span class="line">                                &#123; context.title &#125;</span><br><span class="line">                            &lt;/h1&gt;</span><br><span class="line">                            &lt;button onClick=&#123; () =&gt; <span class="keyword">this</span>.btnClick(context.handleClick) &#125;&gt;clickA&lt;button&gt;</span><br><span class="line">                            &lt;button onClick=&#123; <span class="keyword">this</span>.btnClick.bind(<span class="keyword">this</span>, context.handleClick) &#125;&gt;clickB&lt;button&gt;</span><br><span class="line">                            &lt;button onClick=&#123; () =&gt; context.handleClick(<span class="symbol">'hello</span> world') &#125;&gt;clickC&lt;button&gt;</span><br><span class="line">                            &lt;button onClick=&#123; context.handleClick.bind(<span class="keyword">this</span>, <span class="symbol">'hello</span> world') &#125;&gt;clickD&lt;button&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/<span class="type">Consumer</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三级组件向一级组件传递数据，也是采用回调函数的方式传递，但应用了context Api，就不需要一级一级向上传递，直接在一级组件中定义好方法，在三级组件中应用就可以，相比较而言，简单很多。</p><h3 id="更新context-Api的原因"><a href="#更新context-Api的原因" class="headerlink" title="更新context Api的原因"></a>更新context Api的原因</h3><p>老版本的context Api虽然在写法上不用一级一级传递，但其底层是实现还是一级一级传递数据，所以，如果某个中间组件在shouldComponentUpdate进行了优化或者限制，可能会导致下一级组件依赖的数据不会更新，同时也降低了复杂程度，提高性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/react16-context-Api.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;context Api，主要用于跨组件间的数据传递，如果不用context Api，那一级组件如果要给三级组件传递数据，就会很麻烦，需要先用props传递给二级组件，二级组件再用props传给三级组件，如果再有回传也是一样的道理，一层一层的传递，这会很麻烦，如果应用context Api就会很方便。其实在React16之前的版本中，已经有context Api，但在16.3版本之后，React官方对其进行更改，使其更加方便，效率、性能都得到了提升。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React16新生命周期函数getDerivedStateFromProps</title>
    <link href="http://yixirumeng.github.io/2018/11/01/react-getDerivedStateFromProps/"/>
    <id>http://yixirumeng.github.io/2018/11/01/react-getDerivedStateFromProps/</id>
    <published>2018-11-01T10:44:34.000Z</published>
    <updated>2018-11-01T10:45:58.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/react-getDerivedStateFromProps.jpg" alt=""></p><blockquote><p>React16这个版本，废弃了一些声明周期函数，同时也新增了一些生命周期函数。这一篇先说一下新增的声明周期函数getDerivedStateFromProps。</p></blockquote><a id="more"></a><p>getDerivedStateFromProps作为componentWillReceiveProps的替代品出现，但是它与componentWillReceiveProps也有很多不同点</p><h3 id="Derived-State（衍生状态）"><a href="#Derived-State（衍生状态）" class="headerlink" title="Derived State（衍生状态）"></a>Derived State（衍生状态）</h3><p>当组件的props改变而引发state改变，这个state就被称为是Derived State。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parent component</span></span><br><span class="line">...</span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Child productId=&#123; id &#125;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//children component</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(props)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    super(props)</span></span></span><br><span class="line"><span class="function"><span class="comment">    this.state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        id: ''</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">componentDidMount</span><span class="params">()</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    const &#123; productId &#125;</span> = <span class="title">this</span>.<span class="title">props</span></span></span><br><span class="line"><span class="function">    <span class="title">this</span>.<span class="title">setState</span><span class="params">(<span class="comment">&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">        id: productId</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    &#125;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>父组件传入的productId不同，子组件的id也会不一样，而这个id就是Derived State</p><h3 id="static-function"><a href="#static-function" class="headerlink" title="static function"></a>static function</h3><p>getDerivedStateFromProps这个生命周期函数是静态类型的，也就是说无法在其内部调用this</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>getDerivedStateFromProps(nextProps, prevState){}</p><p>它的两个参数分别是变化后的props和当前的state，因为它是静态方法，所以可以直接对state进行赋值，相当于调用setState方法，但是不管改不改变state都要有返回值，否则报错。其返回值为Object，返回null或者基本类型都相当于没有变化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getDerivedStateFromProps(nextProps, prevState)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nextProps.productId%<span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            id: productId  <span class="comment">//可以直接获取state中的key，不用根据prevState获取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><p>调用时机在16.3与16.4这两个版本有区别：</p><p>16.3：只有在props改变的时候，才会执行<br>16.4：任何一次render之前，都会执行(new props, setState, forceUpdate)</p><p>可以看出，<strong>如果任何一次render之前都需要执行，非常耗性能，所以这个生命周期函数能不用尽量不要使用。如果必须使用，最好要有条件判断</strong></p><h3 id="开发时遇到的问题以及解决方案"><a href="#开发时遇到的问题以及解决方案" class="headerlink" title="开发时遇到的问题以及解决方案"></a>开发时遇到的问题以及解决方案</h3><p>前段时间做项目的时候，遇到一个联动功能，当左侧的输入框中输入完信息后，也就是blur后右侧的下拉菜单要变为对应值，右侧是下拉菜单也是一个独立的组件：</p><p>刚开始的想法是，只要改变传入的props，然后在下拉组件内的getDerivedStateFromProps函数中设置为对应的值就可以，大致代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parent component</span></span><br><span class="line"></span><br><span class="line">onBlur = (e) =&gt; &#123;</span><br><span class="line">    const defVal = e<span class="selector-class">.target</span><span class="selector-class">.value</span></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        defVal: currentVal</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span><span class="params">()</span></span>&#123;</span><br><span class="line">    const &#123; defVal &#125; = this.state</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;<span class="selector-tag">input</span> onBlur=&#123; this<span class="selector-class">.inputBlur</span> &#125; /&gt;</span><br><span class="line">            &lt;ChildSelect defaultVal=&#123; defVal &#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChildSelect</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        defaultVal: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getDerivedStateFromProps(nextProps)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nextProps.defaultVal !== defaultVal)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            defaultVal: nextProps.defaultVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectOnChange = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; sendVal &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        ... <span class="comment">//其它功能</span></span><br><span class="line">    &#125;)</span><br><span class="line">    sendVal(val) <span class="comment">//向父组件发送数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; defaultVal &#125; = <span class="keyword">this</span>.state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Select defaultValue=&#123; defaultVal &#125; onChange=&#123; <span class="keyword">this</span>.selectOnChange &#125;&gt;</span><br><span class="line">            &lt;Option value=<span class="string">"A"</span>&gt;A&lt;<span class="regexp">/Option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Option value="B"&gt;B&lt;/</span>Option&gt;</span><br><span class="line">            &lt;Option value=<span class="string">"C"</span>&gt;C&lt;<span class="regexp">/Option&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Select&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来没什么问题，但是这样写会很麻烦，需要控制两个组件，而且在selectOnChange方法内有setState，这样每次选择选项的时候，都要走一遍getDerivedStateFromProps方法，虽然做了判断处理，但也相当于是无用的操作。如果以后扩展的功能里需要改变上面的defaultVal，那里面涉及的问题会更多。</p><p>React官网的建议是，用key值来代替getDerivedStateFromProps方法，也就是如果key改变了，子组件也会重新渲染，这样就不用在子组件内判断props来改变状态。</p><p>更改后的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parent component</span></span><br><span class="line"></span><br><span class="line">onBlur = (e) =&gt; &#123;</span><br><span class="line">    const defVal = e<span class="selector-class">.target</span><span class="selector-class">.value</span></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        defVal</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span><span class="params">()</span></span>&#123;</span><br><span class="line">    const &#123; defVal &#125; = this.state</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;<span class="selector-tag">input</span> onBlur=&#123; this<span class="selector-class">.inputBlur</span> &#125; /&gt;</span><br><span class="line">            &lt;ChildSelect key=&#123; defVal &#125; defaultVal=&#123; defVal &#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChildSelect</span></span><br><span class="line"></span><br><span class="line">selectOnChange = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; sendVal &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        ... <span class="comment">//其它功能</span></span><br><span class="line">    &#125;)</span><br><span class="line">    sendVal(val) <span class="comment">//向父组件发送数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; defaultVal &#125; = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Select defaultValue=&#123; defaultVal &#125; onChange=&#123; <span class="keyword">this</span>.selectOnChange &#125;&gt;</span><br><span class="line">            &lt;Option value=<span class="string">"A"</span>&gt;A&lt;<span class="regexp">/Option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Option value="B"&gt;B&lt;/</span>Option&gt;</span><br><span class="line">            &lt;Option value=<span class="string">"C"</span>&gt;C&lt;<span class="regexp">/Option&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Select&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件增加了key，其值为defVal，子组件内获取到props进行设置，当defVal变化后，子组件重新渲染，而当选择子组件的选项时，也不会受到影响，同时也具有可扩展性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然新增的声明周期钩子函数代替之前版本的函数，但里面也有很多不可避免的问题，所以还是那句话，也是React官方的建议，<strong>getDerivedStateFromProps是不常用的声明周期函数，如果不是必须，还是不要随意使用，否则可能是在滥用Derived State</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/react-getDerivedStateFromProps.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;React16这个版本，废弃了一些声明周期函数，同时也新增了一些生命周期函数。这一篇先说一下新增的声明周期函数getDerivedStateFromProps。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.x侦听属性watch的过程分析</title>
    <link href="http://yixirumeng.github.io/2018/10/25/vue2-watch-analysis/"/>
    <id>http://yixirumeng.github.io/2018/10/25/vue2-watch-analysis/</id>
    <published>2018-10-25T13:41:33.000Z</published>
    <updated>2018-12-08T02:15:24.080Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vue2-watch-analysis.jpg" alt=""></p><blockquote><p>Vue2.x中watch的内部原理主要也是应用了响应式原理中不可缺少的一部分watcher，只不过这个watcher区别于之前讲述的watcher，这个是用户自定义的<code>userWatcher</code>，下面来分析下侦听属性watch整体实现的过程：</p></blockquote><a id="more"></a><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">initWatch</span> <span class="params">(vm: Component, watch: Object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key in watch) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">handler</span> = watch[key]</span><br><span class="line">        <span class="keyword">if</span> (Array.isArray(<span class="keyword">handler</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="keyword">handler</span>.length; i++) &#123;</span><br><span class="line">                createWatcher(vm, key, <span class="keyword">handler</span>[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createWatcher(vm, key, <span class="keyword">handler</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createWatcher (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    <span class="keyword">handler</span>: any,</span><br><span class="line">    options?: Object</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(<span class="keyword">handler</span>)) &#123;</span><br><span class="line">        options = <span class="keyword">handler</span></span><br><span class="line">        <span class="keyword">handler</span> = <span class="keyword">handler</span>.<span class="keyword">handler</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (typeof <span class="keyword">handler</span> === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">handler</span> = vm[<span class="keyword">handler</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm.$watch(expOrFn, <span class="keyword">handler</span>, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue先会遍历所有定义在watch中的属性，而属性的值可以是数组（上篇文章提到的当一个数据需要多次监听），如果是数组，则再进一步遍历，然后调用<code>createWatcher</code>方法，在<code>createWatcher</code>方法中会做一些Object、String的判断，最后会调用$watch方法，并传入相关的参数。</p><p>$watch源码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>: <span class="title">Function</span> &#123;</span></span><br><span class="line">    const <span class="keyword">vm</span>: Component = this</span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(<span class="keyword">cb</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createWatcher(<span class="keyword">vm</span>, expOrFn, <span class="keyword">cb</span>, <span class="keyword">options</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">options</span> = <span class="keyword">options</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">options</span>.user = true</span><br><span class="line">    const watcher = <span class="keyword">new</span> Watcher(<span class="keyword">vm</span>, expOrFn, <span class="keyword">cb</span>, <span class="keyword">options</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">options</span>.immediate) &#123;</span><br><span class="line">        <span class="keyword">cb</span>.<span class="keyword">call</span>(<span class="keyword">vm</span>, watcher.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> <span class="params">()</span> &#123;</span></span><br><span class="line">        watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码上来看，$watch的实现也很简单，首先会判断传入的<code>handler</code>也就是上面的<code>cb</code>是不是Object，如果是的话，会递归调用<code>createWatcher</code>方法，正常在开发过程中watch的值的回调函数就是这里的<code>cb</code>，最终会根据相关的参数new一个新的<code>watcher</code>，而这个<code>watcher</code>是一个<code>userWatcher</code>，因为有<code>options.user = true</code>这段代码。这样就初始化好了一个<code>userWatcher</code></p><p>watcher的相关源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dep.subs.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.dep.notify()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getAndInvoke(<span class="keyword">this</span>.cb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAndInvoke (cb: Function) &#123;</span><br><span class="line">  const value = <span class="keyword">this</span>.<span class="keyword">get</span>()</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    value !== <span class="keyword">this</span>.value ||</span><br><span class="line">    isObject(value) ||</span><br><span class="line">    <span class="keyword">this</span>.deep</span><br><span class="line">  ) &#123;</span><br><span class="line">    const oldValue = <span class="keyword">this</span>.value</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, <span class="keyword">this</span>.vm, `callback <span class="keyword">for</span> watcher <span class="string">"<span class="subst">$&#123;this.expression&#125;</span>"</span>`)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当watch的数据有变化的时候，会执行<code>Object.defineProperty</code>的set方法，使得订阅者<code>Dep</code>通知所有存储在其中的watcher，并执行其中的<code>update</code>方法，<code>update</code>会走到<code>queueWatcher(this)</code>，最终会走到watcher的<code>run</code>方法（内部实现复杂，涉及到<code>nextTick</code>，但最终还是会走入到<code>run</code>方法中），接着进入到<code>getAndInvoke</code>方法中。</p><p>分析一下<code>getAndInvoke</code>方法，首先会拿到新的值，并与之前的值进行判断，如果不一样，则进入到下面的逻辑中。因为在之前已经定义了是个<code>userWatcher</code>，所以会进入到<code>if</code>中，执行<code>cb.call(this.vm, value, oldValue)</code>，这里的<code>cb</code>就是我们定义的回调函数，它改变this指向到当前组件，同时将新的<code>value</code>和旧的<code>value</code>传入（这也就是我们能在方法中获取到新旧值的原因），然后执行这个回调函数。</p><p>经过以上分析，侦听属性watch的整体过程还是相对简单的。下面根据一个具体例子来说一下过程：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeMsg"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    export default &#123;</span></span><br><span class="line"><span class="xml">        data()&#123;</span></span><br><span class="line"><span class="xml">            return &#123;</span></span><br><span class="line"><span class="xml">                message: 'hello'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        methods: &#123;</span></span><br><span class="line"><span class="xml">            changeMsg()&#123;</span></span><br><span class="line"><span class="xml">                this.message = 'world'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        watch: &#123;</span></span><br><span class="line"><span class="xml">            message(newVal, oldVal)&#123;</span></span><br><span class="line"><span class="xml">                console.log(newVal)</span></span><br><span class="line"><span class="xml">                console.log(oldVal)</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>1、初始化的时候，先用<code>Object.defineProperty</code>转换<code>message</code>，之后会通过上述所讲的初始化一个<code>message</code>的<code>userWatcher</code>，而这里定义在watch中的回调函数将作为<code>handler</code>传入，也就是后面的<code>cb</code></p><p>2、当点击按钮的时候，<code>message</code>发生了改变，会调用其中的set方法，从而走入到<code>userWatcher</code>中的<code>update</code>方法中</p><p>3、<code>update</code>最后进入到<code>getAndInvoke</code>中，首先会拿到新值，然后对比旧值，因为<code>hello</code>与<code>world</code>不相等，继续执行</p><p>4、因为这个watcher是一个<code>userWatcher</code>，所以会进入到内层的if中，执行<code>cb.call(this.vm, value, oldValue)</code></p><p>5、此时的<code>this.vm</code>是当前的组件，<code>value</code>是<code>world</code>对应回调函数中的参数<code>newVal</code>，<code>oldValue</code>是<code>hello</code>对应回调函数中的参数<code>oldVal</code>，所以可以将两个值<code>console</code>出</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>在定义侦听属性的时候，可以传入一些参数，<code>deep</code>、<code>sync</code>、<code>immediate</code></p><h4 id="immediate"><a href="#immediate" class="headerlink" title="immediate"></a>immediate</h4><p>从刚开始给出的源码中可以看出，在new一个<code>userWatcher</code>之后，有个条件判断<code>options.immediate</code>，如果为真，则执行<code>cb.call(vm, watcher.value)</code>，<code>watcher.value</code>即获取监听属性的值，<strong>所以，如果设置immediate为true，就是在初始化的时候执行一次，会马上获取到监听属性的值</strong>，对应刚才的例子，则是获取到<code>hello</code></p><h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><p>在上面最后给的一段源码中的<code>update</code>方法中，可以找到<code>sync</code>的判断条件，会执行<code>run</code>方法，走之后的逻辑，其实设置了这个参数为true的时候，将不会走<code>queueWatcher</code>中，也就是说不会涉及到<code>nextTick</code>（<code>nextTick</code>是个异步的过程），<strong>最终会同步执行cb</strong>，所以只有在watch的值的变化到执行watcher的回调函数是一个同步过程的时候才会去设置该属性为 <code>true</code></p><h4 id="deep"><a href="#deep" class="headerlink" title="deep"></a>deep</h4><p>设置<code>deep: true</code>是为了观察到深层的变化，可以在watcher中的get方法中看出，下面是get方法的源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  let value</span><br><span class="line">  const vm = <span class="keyword">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, `getter <span class="keyword">for</span> watcher <span class="string">"<span class="subst">$&#123;this.expression&#125;</span>"</span>`)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>deep</code>为<code>true</code>时，执行<code>traverse(value)</code>，其实<code>traverse</code>的内部则是进一步遍历，直到不能在遍历为止</p><p>所以，<strong>当要观察的属性是对象、数组等值时，则需要设置该属性，因为正常引用类型的对比是对比内存地址</strong>。但是，如果是观察的是基本类型的值，不要设置，因为深层遍历会耗性能，虽然Vue已经做了优化，但只是在做判断，还是会执行一些没必要的代码，所以还是不要设置的好。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是有关于watch的所有内容，整个watch的过程相对来说并不复杂，但内部也有很多需要注意的地方，了解了内部的原理对正常的开发会有很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vue2-watch-analysis.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue2.x中watch的内部原理主要也是应用了响应式原理中不可缺少的一部分watcher，只不过这个watcher区别于之前讲述的watcher，这个是用户自定义的&lt;code&gt;userWatcher&lt;/code&gt;，下面来分析下侦听属性watch整体实现的过程：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>简述Vue2.x中computed相互调用，以及watch中同一属性多次监听</title>
    <link href="http://yixirumeng.github.io/2018/10/16/vue2-computed-mutual-call-and-more-watch/"/>
    <id>http://yixirumeng.github.io/2018/10/16/vue2-computed-mutual-call-and-more-watch/</id>
    <published>2018-10-16T12:51:08.000Z</published>
    <updated>2018-10-25T13:32:00.836Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vue2-computed-mutual-call-and-more-watch.jpg" alt=""></p><blockquote><p>平时在开发的时候，在需要做数据计算的时候，会用computed计算属性，但是在computed中的某一属性是否可以调用另一属性呢？在应用侦听属性watch的时候，如何对同一属性进行多次侦听呢？</p></blockquote><a id="more"></a><h3 id="computed相互调用"><a href="#computed相互调用" class="headerlink" title="computed相互调用"></a>computed相互调用</h3><p>通过上一篇文章的分析，可以了解到computed其中的内部实现原理，即：</p><p>在初始化的时候，创建订阅者Dep，并应用Object.defineProperty对computed中计算属性进行转换拦截，定义的方法作为该属性的get方法，同时在方法内部创建观察者computedWatcher。当被render方法调用的时候，订阅renderWatcher，放入自身的Dep中，而在computed中调用的其它数据，也会执行一样的操作。</p><p>从这就可以看出，computed的实现原理与data数据基本类似，都是应用了响应式原理的三个主要特性，Object.defineProperty、Dep、Watcher，所以<strong>在computed中也是可以相互调用的，就像调用data数据一样</strong>，其内部实现原理也是同样执行上面说的。</p><p>举例说明一下：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; newMessage1 &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; newMessage2 &#125;&#125;</span><span class="xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeMessage"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    export default &#123;</span></span><br><span class="line"><span class="xml">        data()&#123;</span></span><br><span class="line"><span class="xml">            return &#123;</span></span><br><span class="line"><span class="xml">                message: 'hello'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        computed: &#123;</span></span><br><span class="line"><span class="xml">            newMessage1()&#123;</span></span><br><span class="line"><span class="xml">                return this.message + ' world'</span></span><br><span class="line"><span class="xml">            &#125;,</span></span><br><span class="line"><span class="xml">            newMessage2()&#123;</span></span><br><span class="line"><span class="xml">                return this.newMessage1 + '!'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        method: &#123;</span></span><br><span class="line"><span class="xml">            changeMessage()&#123;</span></span><br><span class="line"><span class="xml">                this.message = 'hi'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>首次渲染的时候，页面上的显示分别为<code>hello</code>、<code>hello world</code>、<code>hello world!</code>，当点击按钮后，页面上的显示会变为<code>hi</code>，<code>hi world</code>，<code>hi world!</code></p><h2 id="watch中同一属性多次监听"><a href="#watch中同一属性多次监听" class="headerlink" title="watch中同一属性多次监听"></a>watch中同一属性多次监听</h2><p>正常开发时，当某一属性发生变化时，要执行某操作会用到watch，如果想执行多种操作的时候，该怎么办呢？其实看一下Vue的源码就能轻松知道。</p><p>先贴一下Vue的相关源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">initWatch</span> <span class="params">(vm: Component, watch: Object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key in watch) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">handler</span> = watch[key]</span><br><span class="line">        <span class="keyword">if</span> (Array.isArray(<span class="keyword">handler</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="keyword">handler</span>.length; i++) &#123;</span><br><span class="line">                createWatcher(vm, key, <span class="keyword">handler</span>[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createWatcher(vm, key, <span class="keyword">handler</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createWatcher (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    <span class="keyword">handler</span>: any,</span><br><span class="line">    options?: Object</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(<span class="keyword">handler</span>)) &#123;</span><br><span class="line">        options = <span class="keyword">handler</span></span><br><span class="line">        <span class="keyword">handler</span> = <span class="keyword">handler</span>.<span class="keyword">handler</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (typeof <span class="keyword">handler</span> === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">handler</span> = vm[<span class="keyword">handler</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm.$watch(expOrFn, <span class="keyword">handler</span>, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码中可以看出，在定义watch的时候，不止能定义单一的侦听函数，还能定义数组，数组中的每个元素可以为对象，在对象内定义要执行的侦听函数。</p><p>还是举例说明一下：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeMessage"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    export default &#123;</span></span><br><span class="line"><span class="xml">        data()&#123;</span></span><br><span class="line"><span class="xml">            return &#123;</span></span><br><span class="line"><span class="xml">                message: 'hello'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        watch: &#123;</span></span><br><span class="line"><span class="xml">            message: [</span></span><br><span class="line"><span class="xml">                &#123;</span></span><br><span class="line"><span class="xml">                    handler()&#123;</span></span><br><span class="line"><span class="xml">                        console.log('message is changed')</span></span><br><span class="line"><span class="xml">                    &#125;</span></span><br><span class="line"><span class="xml">                &#125;,</span></span><br><span class="line"><span class="xml">                &#123;</span></span><br><span class="line"><span class="xml">                    handler()&#123;</span></span><br><span class="line"><span class="xml">                        console.log('new message output')</span></span><br><span class="line"><span class="xml">                    &#125;</span></span><br><span class="line"><span class="xml">                &#125;</span></span><br><span class="line"><span class="xml">            ]</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        methods: &#123;</span></span><br><span class="line"><span class="xml">            changeMessage()&#123;</span></span><br><span class="line"><span class="xml">                this.message = 'world'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当点击按钮后，在控制台会输出<code>message is changed</code>，<code>new message output</code>。</p><p><strong>这里要注意的是，在写数组中对象的时候，定义的方法的key值，必须为handler，这一点从源码中可以看出。当然在对象内部也可以定义<code>deep</code>等其它属性。如果只有一个对象的时候，也可以不用数组包围，直接定义，但同样的要用handler作为侦听函数的key值。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>平时在实际开发中，以上的操作可能应用不会很多。但是在通过阅读源码之后就能了解到其底层的实现原理，以及一些其它的定义方式，这样不管开发还是学习都能有不断的提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vue2-computed-mutual-call-and-more-watch.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;平时在开发的时候，在需要做数据计算的时候，会用computed计算属性，但是在computed中的某一属性是否可以调用另一属性呢？在应用侦听属性watch的时候，如何对同一属性进行多次侦听呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>从渲染以及内在执行过程角度阐述Vue2.x中data与computed的原理</title>
    <link href="http://yixirumeng.github.io/2018/10/13/vue2-data-computed/"/>
    <id>http://yixirumeng.github.io/2018/10/13/vue2-data-computed/</id>
    <published>2018-10-13T14:08:17.000Z</published>
    <updated>2018-12-08T02:15:40.630Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vue2-data-computed.jpg" alt=""></p><blockquote><p>网上已经有很多文章结合源码叙述了Vue框架中data与computed的实现原理，但大多都是在源代码的基础上进行讲解，对于没有仔细读过源码的同学来说，理解起来会有些费劲。这篇文章会从这两者的渲染以及内部执行过程来阐述内在原理。（注：不会过于分析源代码，想根据源码理解的，请阅读相关的文章）</p></blockquote><a id="more"></a><h3 id="Object-definePoperty"><a href="#Object-definePoperty" class="headerlink" title="Object.definePoperty"></a>Object.definePoperty</h3><p>Object.defineProperty这个相信大家都知道，它是Vue实现响应式的核心方法，也是Vue不兼容ie8及以下浏览器的主要原因。在这个方法里可以定义get、set方法（类似Java），以此来取值和赋值。Vue在初始化的时候，会将普通对象中的数据，用这个方法进行转换。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher即观察者，区别于Vue中的watch API，它是底层封装一个类。Vue中的任何操作都是基于数据的，每当render渲染、数据被访问等时候，都会创建Watcher，其主要作用就是观察数据的变化，并根据变化来进行及时的响应。</p><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>Dep即订阅者，它也是底层封装的一个类。Vue在用Object.definePoperty方法转换普通对象数据的时候，都会创建Dep，其作用是，当某个操作运用了数据的时候，就会将这一操作的watcher存储其中，也就是所说的依赖收集。如果数据发生了改变，就会通知所有存过的watcher，让它们进行更新操作。</p><p>以上这三者，是Vue响应式的核心，理解它们对理解Vue至关重要。而Vue中的data和computed的实现，也都是应用了它们。</p><hr><p>下面分别对data、computed的过程进行简要描述，可以理清它们的实现过程与响应式原理</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; msg &#125;&#125;</span><br><span class="line">        &lt;button @click=<span class="string">"changeMsg"</span>&gt;change&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg: <span class="string">'hello'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    method&#123;</span><br><span class="line">        changeMsg()&#123;</span><br><span class="line">            this.msg = <span class="string">'world'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个例子，来说下当data被访问或更新的时候，其实现的过程：</p><p>1、当初始化的时候，应用Object.defineProperty将data中的数据进行转换，创建Dep订阅者，并设置get、set方法</p><p>2、组建创建模板template的时候，会执行render方法，并创建renderWatcher观察者</p><p>3、在render方法访问data中的数据msg时，会执行get方法，在get方法中msg进行依赖收集，也就是将renderWatcher存入到Dep中。执行完收集的操作后，将数据返回给render方法，供render渲染。</p><p>4、当点击change按钮的时候，会改变msg数据，执行set方法进行数据更改。在set方法中，会让Dep通知所有存储的watcher进行更新。此时存储的是renderWatcher，而renderWatcher接受到通知后，会重新执行渲染方法来渲染组件。</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>其实computed与data类似，也会讲其中的属性应用Object.defineProperty进行转换，而定义在计算属性的函数，而这个函数会作为这一属性的get方法，举例说明一下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">computed &#123;</span><br><span class="line">    <span class="keyword">new</span><span class="type">Msg</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.msg + <span class="string">'world'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">computed &#123;</span><br><span class="line">    <span class="keyword">new</span><span class="type">Msg</span>: &#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.msg + <span class="string">'world'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在初始化的时候，会将用Object.defineProperty将newMsg进行转换，同时把上面定义函数作为newMsg的get方法，当然也会在get方法中设置对应的观察者watcher</strong></p><p>下面再来根据例子来说明一下，当data中的数据进行访问和更新时，整体的实现过程：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; msg &#125;&#125;</span><br><span class="line">        &lt;p&gt;&#123;&#123; newMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"changeMsg"</span>&gt;change&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg: <span class="string">'hello'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        newMsg()&#123;</span><br><span class="line">            return this.msg + <span class="string">' world'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    method: &#123;</span><br><span class="line">        changeMsg()&#123;</span><br><span class="line">            this.msg = <span class="string">'你好'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>初始化的时候，会将data和computed中的数据运用Object.defineProperty进行转换，都创建各自的Dep，data中的数据会设置get、set方法，computed中的函数作为其属性的get方法。</p></li><li><p>组建创建模板template的时候，会执行render方法，并创建renderWatcher观察者。</p></li><li><p>在render方法访问到data中的数据时，会执行msg的get方法，在get方法中msg进行依赖收集，将renderWatcher存入msg的Dep中。执行完操作后，将数据返回给render，供其渲染。</p></li><li><p>在render方法访问到computed中的newMsg时，会执行newMsg的get方法，在get方法中newMsg进行依赖收集，将renderWatcher存入newMsg的Dep中。</p></li><li><p>newMsg的get方法中，会访问data中的msg，执行msg的get方法，在msg的get方法中msg会进行依赖收集，将newMsgWatcher存入msg的Dep中，并将数据返回给newMsg</p></li><li><p>newMsg拿到msg的数据后，进行字符串拼接，将结果返回给render方法供其渲染</p></li><li><p>点击change按钮的时候，会执行msg的set方法设置数据，并让Dep通知所有存储的watcher进行更新。此时的watcher有renderWatcher和newMsgWatcher，renderWatcher会重新渲染template中的msg，而newMsgWatcher会通知computed中的newMsg。</p></li><li><p>newMsg接收到通知后，会重新拼接字符串，并让其Dep通知所有存储的watcher进行更新。此时的watcher只有renderWatcher，renderWatcher会重新渲染template中的newMsg。</p></li><li><p>整体渲染过程结束。（Vue当然不会一个一个进行渲染，它在底层做了复杂的逻辑算法，提高整体的性能，此处单独说明是为了叙述清楚，）</p></li></ol><hr><p><strong>通过以上的过程分析，可以明白Vue中的data、computed都是基于前面提到的三者实现的，其核心原理都是一样的，所以理解好这三点，就可以轻松理解Vue响应式的整个过程。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vue2-data-computed.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网上已经有很多文章结合源码叙述了Vue框架中data与computed的实现原理，但大多都是在源代码的基础上进行讲解，对于没有仔细读过源码的同学来说，理解起来会有些费劲。这篇文章会从这两者的渲染以及内部执行过程来阐述内在原理。（注：不会过于分析源代码，想根据源码理解的，请阅读相关的文章）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>分析React、Vue组件为什么必须只能有一个根元素</title>
    <link href="http://yixirumeng.github.io/2018/10/08/react-and-vue2-component-single-root/"/>
    <id>http://yixirumeng.github.io/2018/10/08/react-and-vue2-component-single-root/</id>
    <published>2018-10-08T11:22:18.000Z</published>
    <updated>2018-10-25T13:15:59.350Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/react-and-vue2-component-single-root.jpg" alt=""></p><blockquote><p>为什么平时在开发react或者vue组件写jsx或者template的时候，框架都要求必须只能有一个根元素？现在就来分析一下</p></blockquote><a id="more"></a><p>其实，这个要求在react和vue中的原理是一样的，分别举例说明一下：</p><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>平时定义组件的时候我们都会这样写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 className=<span class="string">"title"</span>&gt;我是标题&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;我是内容&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中的render函数中的jsx最终会被编译成React元素的形式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">React</span>.createElement(</span><br><span class="line">            <span class="symbol">'di</span>v', </span><br><span class="line">            <span class="literal">null</span>, </span><br><span class="line">            [<span class="type">React</span>.createElement(<span class="symbol">'h</span>1', &#123; className: <span class="symbol">'titl</span>e' &#125;, '我是标题'),</span><br><span class="line">            <span class="type">React</span>.createElement('p', <span class="literal">null</span>, '我是内容')]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>vue在定义组件template的时候，会是如下写法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而vue的template模板最终也会被编译为render函数，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">render(createElement)&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">        <span class="string">'div'</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        [createElement(</span><br><span class="line">            <span class="string">'h1'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">class</span>: <span class="type">'title'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'我是标题'</span></span><br><span class="line">        ),</span><br><span class="line">        createElement(</span><br><span class="line">            <span class="string">'p'</span>,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="string">'我是内容'</span></span><br><span class="line">        )]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这两个例子可以看出，<strong>不管是vue还是react，模板都将被编译为render函数，而函数的返回值只能是一个，所以如果不用单独的根节点包住，就会并列返回多个返回值，这在js中是不允许的。</strong></p><p>除了这一点，还有一个主要是原因是，<strong>react和vue都将把模板的内容转换为对应的元素，最后建立起虚拟dom树，而树状结构只能有唯一的根节点，这样在后续的虚拟dom数据有变化时，可以检查到具体更改额位置。如果有多个根节点，则不能明确到底要在哪个树上查找更新。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/react-and-vue2-component-single-root.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么平时在开发react或者vue组件写jsx或者template的时候，框架都要求必须只能有一个根元素？现在就来分析一下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>为什么定义组件的时候必须要导入React</title>
    <link href="http://yixirumeng.github.io/2018/10/06/why-compoments-must-import-react/"/>
    <id>http://yixirumeng.github.io/2018/10/06/why-compoments-must-import-react/</id>
    <published>2018-10-06T06:36:13.000Z</published>
    <updated>2018-10-25T13:22:49.270Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/why-compoments-must-import-react.jpg" alt=""></p><blockquote><p>在用react开发时，为什么要先导入React（即：<code>import React from &#39;react&#39;</code>）呢？但在组件内部并没有使用？</p></blockquote><a id="more"></a><p>可能有人会说在创建组件的时候，需要用到React中的Component组件，但完全可以用<code>import { Component } from &#39;react&#39;</code>这种方式</p><p>其实最主要的原因并不是上述所说的，根本原因是<strong>JSX</strong></p><p>先写个例子，写一个非常简单的组件：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t'</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;这是<span class="type">App</span>组件&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="type">App</span></span><br></pre></td></tr></table></figure><p>在编译时，组件内部的JSX会调用<code>React.createElement</code>方法创建React元素：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">React</span>.createElement(<span class="symbol">'di</span>v', <span class="literal">null</span>, '这是<span class="type">App</span>组件')</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以，在定义组件时必须要导入React因为在编译JSX时，需要用到<code>React.createElement</code>方法，而JSX本质则是React创建元素的语法糖。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/why-compoments-must-import-react.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在用react开发时，为什么要先导入React（即：&lt;code&gt;import React from &amp;#39;react&amp;#39;&lt;/code&gt;）呢？但在组件内部并没有使用？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Javascript面试题 —— setTimeout+promise经典面试题分析（弄懂Js执行机制Event Loop）</title>
    <link href="http://yixirumeng.github.io/2018/09/30/javascript-interview-run-mechanism/"/>
    <id>http://yixirumeng.github.io/2018/09/30/javascript-interview-run-mechanism/</id>
    <published>2018-09-29T16:35:18.000Z</published>
    <updated>2018-11-09T14:04:19.279Z</updated>
    
    <content type="html"><![CDATA[<!-- ![](/assets/blogImg/javascript-interview-run-mechanism.jpg) --><blockquote><p>在网上看JS面试题的时候，经常会遇到以下这个题目，会问这段代码的执行结果：</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span>(let i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i === <span class="number">999</span>)&#123;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>当然网上肯定也会有解答，但大多数都分析的不够彻底。现在就来彻底分析以下：</p><a id="more"></a><p>其实如果理解了在浏览器端JS的执行机制，就能很轻松的答对这道题目，而且再遇到类似的问题，也都不会害怕。</p><h3 id="1、首先要记住一个核心概念：javascript是单线程语言，所谓单线程就是事情要一个一个顺序执行，如果前一个任务执行时间过长，后一个任务只能等待前一个任务执行完毕后，才可以执行"><a href="#1、首先要记住一个核心概念：javascript是单线程语言，所谓单线程就是事情要一个一个顺序执行，如果前一个任务执行时间过长，后一个任务只能等待前一个任务执行完毕后，才可以执行" class="headerlink" title="1、首先要记住一个核心概念：javascript是单线程语言，所谓单线程就是事情要一个一个顺序执行，如果前一个任务执行时间过长，后一个任务只能等待前一个任务执行完毕后，才可以执行"></a>1、首先要记住一个核心概念：javascript是单线程语言，所谓单线程就是事情要一个一个顺序执行，如果前一个任务执行时间过长，后一个任务只能等待前一个任务执行完毕后，才可以执行</h3><p>举例说一下：夜间去火车站买票，因为客流量少，只有一个售票窗口，大家都在排队买票，第一位乘客直接说要一张6点北京到上海的硬座车票，售票员很快就能将票打印出，乘客拿着票开心走了；第二位乘客说要一张7点北京到广州的卧铺，售票员需要问要哪个位置的，乘客说要下铺，售票员知道后打印了车票，这就比第一位乘客花的时间多了；第三位乘客说要一张北京到西安的车票，售票员需要问时间、座位类型、卧铺位置等等的，明确之后才能打印车票，这花费的时间就更多了。后面的乘客必须要等到前面的乘客买完后才能去买，即使前一位花了好长时间。</p><h3 id="2、javascript的事件循环"><a href="#2、javascript的事件循环" class="headerlink" title="2、javascript的事件循环"></a>2、javascript的事件循环</h3><p>浏览器如果都按着刚才例子的方式执行，当用户浏览到有图片的网站时，要等到图片加载完毕才能进行其它操作，就会损失很多用户。为了解决这个问题，就有了任务分类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p>打开网站的时候，网页的渲染过程就是同步任务，而ajax数据获取、图片、视频等资源大加载慢的任务，就是异步任务。它们在执行的时候会有区别，分为以下几个过程：</p><ol><li>同步任务进入到主线程中，马上执行</li><li>异步任务首先进入到事件表（Event Table）中，并注册回调函数</li><li>当异步的事件执行完毕后，Event Table会将其回调函数移送到事件队列中（Event Queue），等待执行</li><li>当主线程中的任务都执行完毕为空的时候，就会去Event Queue中读取对应的回调函数，并放入到主线程中执行</li><li>不断重复以上的过程，也就是事件循环（Event Loop）</li></ol><p>注意点：<strong>setTimeout、setInterval平时都会说是过多长时间后执行，其实内在的原理是，遇到它们的时候，它们会进入事件表Event Table中，等过多长时间后，再将其回调函数移送到事件队列Event Queue中。还有就是，即使将时间设置为0，也不会存在完全的0ms，js最低时间为4ms</strong></p><p><em>扩展：js引擎存在monitoring process进程，会持续检查主线程是否为空，如果为空，会马上去Event Queue中检查是否有等待被调用的函数</em></p><hr><p>理解这两个概念之后，相信可以明白网上说的对题目的这段解释：</p><p>先输出1、3、4、6，因为这些任务都是同步执行的（new Promise是立即执行的，也是同步任务）</p><p>执行完毕之后再执行异步任务</p><p>但setTimeout和promise中的then都是异步执行的，应该先输出哪个呢？</p><hr><h3 id="3、除了广义的同步任务与异步任务外，这里又引入了对任务更精细的定义："><a href="#3、除了广义的同步任务与异步任务外，这里又引入了对任务更精细的定义：" class="headerlink" title="3、除了广义的同步任务与异步任务外，这里又引入了对任务更精细的定义："></a>3、除了广义的同步任务与异步任务外，这里又引入了对任务更精细的定义：</h3><ul><li>macro-task(宏任务)：包括script、setTimeout、setInterval等</li><li>micro-task(微任务)：包括Promise、ajax等</li></ul><p>这两个不同的任务，会进入到不同的Event Queue，比如setTimeout和setInterval会进入到相同的Event Queue，但setTimeout和Promise则会进入到不同的Event Queue</p><hr><p><strong>js的事件循环顺序是，每一次循环都是先执行宏任务，然后再执行微任务。即第一次执行完所有的宏任务，接着执行所有的微任务，第一次循环结束；第二次循环依然是先执行完所有的宏任务，接着执行所有的微任务。但是还有一个注意点，如果是宏任务，会新建一个任务队列，任务队列中的宏任务有多个来源；如果是微任务，则直接放入微任务队列。</strong></p><p><strong>所以，事件循环可以归纳为以下的步骤：</strong></p><ol><li>全局任务<code>script</code>属于宏任务，所以最先执行，也就相当执行所有的同步任务，执行完之后，开始执行微任务</li><li>微任务队列中的任务都执行完后，读取宏任务队列中拍在最前面的宏任务</li><li>执行宏任务过程中，遇到微任务，会将其加入到微任务队列</li><li>执行完宏任务之后，继续读取微任务执行。依此类推</li></ol><hr><p>现在就可以完整的理解这道面试题了，仔细分析一下：</p><ol><li>整体代码都在<code>script</code>标签之内包裹着，作为宏任务进入到主线程中</li><li>遇到<code>console.log(1)</code>的时候，马上执行输出1</li><li>遇到<code>setTimeout</code>的时候，会将其回调函数注册，过4ms后移送到宏任务Event Queue中</li><li>遇到<code>Promise</code>，由于<code>new Promise</code>是立即执行的，这就输出了3、4，</li><li><code>Promise</code>属于微任务，所以把<code>then</code>函数放到微任务Event Queue中</li><li>遇到<code>console.log(6)</code>，又会马上执行，输出6</li><li>此时第一次循环的宏任务全部执行完毕，开始执行微任务，在微任务Event Queue中发现了<code>console.log(5)</code>,输出5</li><li>由于第一次循环的宏任务与微任务全部执行完毕，开始进入第二次循环</li><li>第二次循环还是先执行宏任务，在宏任务Event Queue中发现了<code>console.log(2)</code>，输出2</li><li>现在已经没有其它任务了，整执行结束，所以最终结果是1、3、4、6、5、2</li></ol><hr><p>1、明白了javascript的执行机制，是不是做出这道题来就很简单了。再来看一道经典的题目：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>其实和之前的题目很类似，只不过用了Promise.resolve方法，用过的同学应该知道，这是new Promise中resolve的语法糖。所以这道题和上一道题的分析过程一样，注意一点就是，题目中有两个then方法，这两个都要放到微任务Event Queue中。而在当前的循环中，不管是宏任务还是微任务，都是要执行Queue中的所有任务。记住了就能知道结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>、script start</span><br><span class="line"><span class="number">2</span>、script end</span><br><span class="line"><span class="number">3</span>、promise1</span><br><span class="line"><span class="number">4</span>、promise2</span><br><span class="line"><span class="number">5</span>、setTimeout</span><br></pre></td></tr></table></figure><p>明白了javascript的执行机制，再遇到相似的题目，只要按着以上的逻辑逐行代码分析，就能很轻松的得到正确的答案。</p><p>2、接下来看一道宏微任务相互结合的题目：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>这道题里，别的地方和之前的题目没有什么差别，主要不同的地方是在第一个<code>setTimeout</code>，在其内部又有一个<code>promise</code>的<code>then</code>方法，所以这是宏任务与微任务结合的题目，记住上面加粗的那句话以及事件循环执行顺序，就可以判断出，当执行第一个<code>setTimeout</code>时，里面又有微任务，将其放入微任务队列，执行完这个宏任务，就会开始去读取微任务队列并执行，而不会先执行第二个<code>setTimeout</code>，因为这个宏任务会新建任务队列，所以要等微任务执行完之后，再开始执行第二个<code>setTimeout</code>，所以结果为<strong>1 6 5 2 3 4</strong></p><p>如果把第一个<code>setTimeout</code>的等待时间改为2000，那结果则是<strong>1 6 5 4 2 3</strong>，别忘了是先取排在前面的宏任务</p><p>3、最后再看一道题目：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    url: ajaxUrl,</span><br><span class="line">    success: <span class="function"><span class="params">(data)</span> =&gt;</span> &#123;   <span class="regexp">//</span><span class="number">40</span>ms后拿到数据</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><hr><p>分析：</p><ol><li>所有代码都在<code>script</code>标签中，整体当做宏任务，移送到主线程中</li><li>遇到<code>console.log(1)</code>，先输出1</li><li>遇到<code>setTimeout</code>，会将其回调函数注册，过100ms后移送到宏任务Event Queue中</li><li>遇到<code>Promise</code>，立即执行<code>new Promise</code>里的任务，输出3</li><li><code>Promise</code>的<code>then</code>放到微任务Event Queue中</li><li>遇到微任务<code>ajax</code>，放到微任务Event Queue中</li><li>遇到<code>console.log(7)</code>，输出7。此时第一轮的宏任务已经全部执行完毕，开始执行微任务</li><li>在微任务队列中，拿到<code>then</code>，先遇到<code>console.log(4)</code>，输出4，又遇到<code>setTimeout</code>，将其回调注册，过4ms后移送到宏任务Event Queue中</li><li>拿到到<code>ajax</code>，遇到<code>console.log(6)</code>，输出6。到此为止，第一轮已经全部执行完毕，开始执行下一轮</li><li>还是先执行宏任务，在宏任务队列中，遇到两个<code>setTimeout</code>，由于<code>then</code>中的<code>setTimeout</code>会先推入Event Queue中，所以会先输出5，之后再输出2</li></ol><p>注意点：<strong>then中的setTimeout是0ms（也就是4ms）后放入宏任务Event Queue中，但ajax是40ms后放入微任务Event Queue中，虽然setTimeout快，但是由于ajax是微任务，而每次事件循环都是要执行完微任务再开始下一轮，所以即使ajax慢，也要等到执行完，才会执行下一轮宏任务的setTimeout</strong></p><hr><h3 id="最后的最后，一定要记住以下几点："><a href="#最后的最后，一定要记住以下几点：" class="headerlink" title="最后的最后，一定要记住以下几点："></a>最后的最后，一定要记住以下几点：</h3><ol><li>javascript是单线程语言</li><li>Event Loop是javascript的执行机制</li><li>分清楚宏任务与微任务，记住每次Event loop都是要执行当前所有的宏任务与微任务</li><li>上面加粗说明的事件循环执行过程</li></ol><p><strong>注意：以上只是针对在browser即浏览器中的js，而在node中的执行机制是不同的。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- ![](/assets/blogImg/javascript-interview-run-mechanism.jpg) --&gt;
&lt;blockquote&gt;
&lt;p&gt;在网上看JS面试题的时候，经常会遇到以下这个题目，会问这段代码的执行结果：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Promise(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(resolve, reject)&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(let i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i === &lt;span class=&quot;number&quot;&gt;999&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            resolve()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然网上肯定也会有解答，但大多数都分析的不够彻底。现在就来彻底分析以下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="javascript" scheme="http://yixirumeng.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>react-router4自定义prompt组件，以及在redux或mobx中应用</title>
    <link href="http://yixirumeng.github.io/2018/09/16/react-router4-prompt-custom-md/"/>
    <id>http://yixirumeng.github.io/2018/09/16/react-router4-prompt-custom-md/</id>
    <published>2018-09-15T16:35:18.000Z</published>
    <updated>2018-09-15T18:07:40.705Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/react-router4-prompt-custom.jpg" alt=""></p><blockquote><p>react-router4提供了prompt组件，用于在路由改变之前触发确认框，点击确认可以进行跳转，点取消可以取消跳转保持在当前路由内。它底层的实现应用了原生JS的confirm，弹出的效果也跟confirm一样，但在日常的开发中，这种confirm效果肯定不是我们想要的，但也无法通过CSS来修改，不过仔细阅读一下react-router4的官方文档，可以知道在根路由上有getUserConfirmation事件，在这个事件中就可以控制prompt。</p></blockquote><a id="more"></a><p><strong>在应用react-router4定义路由的时候，在根路由组件上定义一下getUserConfirmation方法，这个方法有两个参数，分别是message、callback，其中message是传递给prompt组件的message的值，而当执行callback(true)时，相当于点击确认按钮，执行callback(false)时，相当于点击取消按钮</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BrowserRouter</span> <span class="attr">getUserConfirmation</span>=<span class="string">&#123;getConfirmation&#125;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">component</span>=<span class="string">&#123;ComponentMain&#125;/</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/AAA"</span> <span class="attr">component</span>=<span class="string">&#123;ComponentA&#125;/</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/BBB"</span> <span class="attr">component</span>=<span class="string">&#123;ComponentB&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/CCC"</span> <span class="attr">component</span>=<span class="string">&#123;ComponentC&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在定义getConfirmation函数的时候，<strong>要注意此函数返回一个自定义的组件，而这个组件不能加载到root的根div上，需要在index.html中再定义一个div，将自定义的组件挂载到这个div上，</strong>否则就会替换掉root上的所有内容。其主要原理是，只有在我们需要的时候，才会显示这个组件，不需要的时候，不要显示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConfirmComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">            <span class="keyword">super</span>(props)</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                visible: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        confirmOnChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                visible: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">            callback(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelOnChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                visible: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">            callback(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;visible&#125; = <span class="keyword">this</span>.state</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;Modal title=&#123;message&#125; visible=&#123;visible&#125; onOk=&#123;<span class="keyword">this</span>.confirmOnChange&#125; onCancel=&#123;<span class="keyword">this</span>.cancelOnChange&#125;&gt;</span><br><span class="line">                    &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;ConfirmComponent /&gt;,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"root1"</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了方便应用了antd的Modal组件，其实也可以自定义样式。以上的方法定义完之后，只要再需要的地方应用一下prompt组件，就可以直线跳转之前拦截。简单写一下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;<span class="type">Prompt</span> message=<span class="string">"确定跳转吗？"</span> when=&#123;urlChangeShowModal&#125;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                ........</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过props和state控制一下urlChangeShowModal的真假，就可以实现路由改变之前的确认提示。其实以上的内容在简书里也有类似的文章，但是在实际的开发中，会应用到状态管理，像redux、mobx等工具，那如何在应用这些工具的时候，再进行控制呢？</p><p>正常在开发中我们会在入口文件index.js中，采用react-redux或者mobx-react中的Provider来使得在任意组件中都能拿到想要的数据，其实在我们刚才自定义的确认框组件中也是一样应用，不过有个注意点，<strong>确认框中用的store不能直接引入项目中的store，而是要使用与入口文件中一样的store，否则状态就会不统一，那边改变了，这边还时初始化的数据</strong>。这里我使用的是mobx，redux也是一样的道理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">入口文件index.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> stores = &#123;</span><br><span class="line">    store: <span class="keyword">new</span> Store()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider &#123;...stores&#125;&gt;</span><br><span class="line">        &lt;App/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>更改一下上面写的自定义的Prompt组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;stores&#125; <span class="keyword">from</span> <span class="string">'../index.js'</span></span><br><span class="line"></span><br><span class="line"> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    @inject([<span class="string">'store'</span>])</span><br><span class="line">    @observer</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConfirmComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">            <span class="keyword">super</span>(props)</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                visible: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        confirmOnChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                visible: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.props.store.changeUrlChangeShowModal(<span class="literal">false</span>)</span><br><span class="line">            callback(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelOnChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                visible: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.props.store.changeUrlChangeShowModal(<span class="literal">false</span>)</span><br><span class="line">            callback(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;visible&#125; = <span class="keyword">this</span>.state</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;Modal title=&#123;message&#125; visible=&#123;visible&#125; onOk=&#123;<span class="keyword">this</span>.confirmOnChange&#125; onCancel=&#123;<span class="keyword">this</span>.cancelOnChange&#125;&gt;</span><br><span class="line">                    &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;Provider &#123;...stores&#125;&gt;</span><br><span class="line">            &lt;ConfirmComponent /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">        document.getElementById("root1")</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样在ComponentA组件中，如果用mobx的changeUrlChangeShowModal方法来控制urlChangeShowModal的true或false，同样可以实现路由跳转确认提示。</p><p>以上就是自定义Prompt组件，以及在redux或者mobx中应用的所有内容。</p><hr><p>在实际的开发中，还遇到了一个问题，就是应用了antd组件实现左侧菜单的时候，菜单传递了组件的url，但是当Prompt中的when为true的时候，点击当前页面的菜单，还是会弹出确认提示框，但此时路由的url和菜单的url是一样的，并未发生跳转，为什么还会执行Prompt提示呢？研究了好久，感觉应该是菜单上定义的url会替换当前的url，只是替换前后是一样的。</p><p>但这种效果并不是想要的，因为在当前的页面上，点击当当前页面的菜单，还会提示，不合理，所以需要进一步更改，但试了很多办法，都不能达到想要的效果，最后应用了一个暴力的解决方案：（还是应用上面的例子）</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、用<span class="built_in">window</span>.location.href获取当前的<span class="built_in">url</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果<span class="built_in">url</span>.includes(<span class="string">"AAA"</span>)为<span class="literal">true</span>的时候，让该<span class="built_in">url</span>下的子菜单不设置路由跳转的参数，其它的菜单则设置</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、如果为<span class="literal">false</span>的时候，这都设置</span><br></pre></td></tr></table></figure><p>这样可以实现想要的效果，不过感觉这种方案并不完美，但目前还没想要其它办法，如果尝试到更好的办法会进一步补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/react-router4-prompt-custom.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;react-router4提供了prompt组件，用于在路由改变之前触发确认框，点击确认可以进行跳转，点取消可以取消跳转保持在当前路由内。它底层的实现应用了原生JS的confirm，弹出的效果也跟confirm一样，但在日常的开发中，这种confirm效果肯定不是我们想要的，但也无法通过CSS来修改，不过仔细阅读一下react-router4的官方文档，可以知道在根路由上有getUserConfirmation事件，在这个事件中就可以控制prompt。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="react" scheme="http://yixirumeng.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Promise then中拦截错误与catch的区别</title>
    <link href="http://yixirumeng.github.io/2018/08/18/promise-then-second-param-md/"/>
    <id>http://yixirumeng.github.io/2018/08/18/promise-then-second-param-md/</id>
    <published>2018-08-18T09:56:52.000Z</published>
    <updated>2018-08-18T10:42:19.480Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/promise-then-second-param.jpg" alt=""></p><blockquote><p>Promise中的then接收两个函数，第一个函数的参数为成功的结果，也就是resolve的值，第二个函数中的参数为失败的结果，也就是reject的值，同时如果失败了，也能从catch中获取到结果，都能获取错误信息，那两者有什么区别呢？</p></blockquote><a id="more"></a><h3 id="其实简单一句话就是，catch不仅能获取到promise中的错误，同时也能获取到then第一个函数中的错误，而第二个函数拦截到的错误信息，只能是promise本身的错误"><a href="#其实简单一句话就是，catch不仅能获取到promise中的错误，同时也能获取到then第一个函数中的错误，而第二个函数拦截到的错误信息，只能是promise本身的错误" class="headerlink" title="其实简单一句话就是，catch不仅能获取到promise中的错误，同时也能获取到then第一个函数中的错误，而第二个函数拦截到的错误信息，只能是promise本身的错误"></a>其实简单一句话就是，catch不仅能获取到promise中的错误，同时也能获取到then第一个函数中的错误，而第二个函数拦截到的错误信息，只能是promise本身的错误</h3><p>代码简单解释一下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    let num = Math.random()*<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        resolve(<span class="string">'200 success'</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'sorry timeout'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(res)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功了 "</span> + res)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'haha error'</span>)</span><br><span class="line">&#125;, <span class="function"><span class="params">(err)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败了 "</span> + err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>当num&lt;1时，会打印出“成功了 200 success”，当num&gt;1时，会打印出“失败了 sorry timeout”，如果这样写，无论什么时候，都不会打印出then第一个函数里throw出来的错误</strong></p><p>如果把代码换成这样</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    let num = Math.random()*<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        resolve(<span class="string">'200 success'</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'sorry timeout'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(res)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功了 "</span> + res)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'haha error'</span>)</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(err)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败了 "</span> + err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>当num&lt;1时，不仅能打印出“成功了 200 success”，还能够打印出“失败了 haha error”，当num&gt;1时，也能打印出“失败了 sorry timeout”</strong></p><p>如果then中的第二个函数和catch同时写的话，又会打印出什么呢，也就是这样</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    let num = Math.random()*<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        resolve(<span class="string">'200 success'</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">'sorry timeout'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(res)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功了 "</span> + res)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'haha error'</span>)</span><br><span class="line">&#125;, <span class="function"><span class="params">(err1)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"err1失败了 "</span> + err1)</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(err2)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"err2失败了 "</span> + err2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当num&gt;1时，只会打印出“err1失败了 sorry timeout”，当num&lt;1时，则会打印出“成功了 200 success”，以及“err2失败了 haha error”</p><p><strong>当then的第二个函数与catch同时存在时，then的第二个函数会拦截到错误信息，而不会再走到catch中</strong></p><p>平时多读一下Promise的官方文档，就能对Promise有更深层的理解，这里只是简单说了一下日常开发中所经历的一些小问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/promise-then-second-param.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Promise中的then接收两个函数，第一个函数的参数为成功的结果，也就是resolve的值，第二个函数中的参数为失败的结果，也就是reject的值，同时如果失败了，也能从catch中获取到结果，都能获取错误信息，那两者有什么区别呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="promise" scheme="http://yixirumeng.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>TCP的三次握手与四次分手</title>
    <link href="http://yixirumeng.github.io/2018/08/12/tcp/"/>
    <id>http://yixirumeng.github.io/2018/08/12/tcp/</id>
    <published>2018-08-11T16:12:00.000Z</published>
    <updated>2018-08-11T16:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/tcp.jpg" alt=""></p><blockquote><p>在TCP/IP协议中，TCP为提供可靠的连接服务，需要通过“三次握手”进行初始化，初始化后建立了真正的连接，客户端与服务端才能开始数据请求与发送。当传送完数据后，需要断开TCP连接，这就涉及到了“四次分手”</p></blockquote><a id="more"></a><h3 id="三次握手的过程："><a href="#三次握手的过程：" class="headerlink" title="三次握手的过程："></a>三次握手的过程：</h3><pre><code>第一次握手：客户端向服务端发送请求建立连接第二次握手：服务端接收到客户端发送来的请求，并向客户端发送同意与客户端建立连接第三次握手：客户端接收到服务端发送来的请求，并向服务端发送同意与服务端建立连接</code></pre><h3 id="三次握手的作用"><a href="#三次握手的作用" class="headerlink" title="三次握手的作用"></a>三次握手的作用</h3><pre><code>主要作用是，防止已失效的连接突然又向服务端发送请求，产生错误。具体到每次握手的作用是，第一次和第二次握手为了保证服务端能够接收到客户端的信息并做出正确的应答，第二次与第三次握手为了保证客户端能够接收到服务端的信息并做出正确的应答。</code></pre><h3 id="四次分手的过程"><a href="#四次分手的过程" class="headerlink" title="四次分手的过程"></a>四次分手的过程</h3><pre><code>第一次分手：客户端向服务端发送断开连接的请求第二次分手：服务端接收到客户端发来的断开请求，并向客户端发送请求同意断开连接第三次分手：服务端向客户端发送断开连接的请求第四次分手：客户端收到服务端发送来的断开请求，并向服务端发送请求同意断开连接</code></pre><h3 id="四次分手的作用"><a href="#四次分手的作用" class="headerlink" title="四次分手的作用"></a>四次分手的作用</h3><pre><code>1、当客户端发送断开请求时，只是表达没有数据要发送了，告诉服务端数据已经全部发送完毕，但这个时候，仍然可以接收到服务端发来的数据2、当服务端接收到断开请求时，表达已经知道客户端没有数据要发送了，并发送同意断开连接的请求，但服务端还是可以向客户端发送数据3、当服务端发送断开连接的请求时，表示已经没有数据要发送了，并通知客户端4、当客户端接收到断开连接的请求后，再告诉服务端已经知道服务端没有数据要发送了，同意断开连接</code></pre><p>当然在每次握手与分手中，还有很多细节，这里只是简单说了一下大致的过程以及每个过程的含义和作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/tcp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在TCP/IP协议中，TCP为提供可靠的连接服务，需要通过“三次握手”进行初始化，初始化后建立了真正的连接，客户端与服务端才能开始数据请求与发送。当传送完数据后，需要断开TCP连接，这就涉及到了“四次分手”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="extend" scheme="http://yixirumeng.github.io/tags/extend/"/>
    
      <category term="TCP连接" scheme="http://yixirumeng.github.io/tags/TCP%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli区分开发、测试、生产环境</title>
    <link href="http://yixirumeng.github.io/2018/04/02/vue-cli-environment/"/>
    <id>http://yixirumeng.github.io/2018/04/02/vue-cli-environment/</id>
    <published>2018-04-02T13:59:06.000Z</published>
    <updated>2018-04-02T14:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vue-cli-environment.jpg" alt=""></p><blockquote><p>vue-cli工具能够快速搭建出vue项目，但在日常开发中，会根据不同的环境应用不同的接口地址，大多分为开发环境、测试环境、生产环境，但vue-cli工具只配置了开发环境与生产环境，但测试环境下也需要打包出来放到服务器上，频繁更改接口地址会很麻烦，其实只要更改下webpack配置，就可以根据设置的命令生成不同环境的项目。</p></blockquote><a id="more"></a><h4 id="在build文件夹中创建build-test-js文件"><a href="#在build文件夹中创建build-test-js文件" class="headerlink" title="在build文件夹中创建build-test.js文件"></a>在build文件夹中创建build-test.js文件</h4><p>代码很简单，主要配置一个环境变量来区分测试与正式环境。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process<span class="selector-class">.env</span><span class="selector-class">.type</span> = <span class="string">'"test"'</span>  <span class="comment">//注意必须是单双引号嵌套的形式</span></span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'./build'</span>)</span></span>  <span class="comment">//引入自带的文件，执行编译代码</span></span><br></pre></td></tr></table></figure><h4 id="修改config文件夹下的prod-env-js文件"><a href="#修改config文件夹下的prod-env-js文件" class="headerlink" title="修改config文件夹下的prod.env.js文件"></a>修改config文件夹下的prod.env.js文件</h4><p>配置好后就可以在应用process.env.type</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module<span class="selector-class">.exports</span> = &#123;</span><br><span class="line">    NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">    type: process<span class="selector-class">.env</span><span class="selector-class">.type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在package-json文件中添加npm-run-test命令"><a href="#在package-json文件中添加npm-run-test命令" class="headerlink" title="在package.json文件中添加npm run test命令"></a>在package.json文件中添加npm run test命令</h4><p>添加命令，执行build-test.js文件</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"node build/build-test.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在项目中根据代码判断环境"><a href="#在项目中根据代码判断环境" class="headerlink" title="在项目中根据代码判断环境"></a>在项目中根据代码判断环境</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ajaxUrl</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(process.env.<span class="attr">NODE_ENV</span> === 'development')&#123;</span><br><span class="line">    <span class="attr">ajaxUrl</span> = 开发环境的公告接口地址</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(process.env.<span class="attr">type</span> === 'test)&#123;</span><br><span class="line">        <span class="attr">ajaxUrl</span> = 测试环境的公告接口地址</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="attr">ajaxUrl</span> = 生产环境的公告接口地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同环境执行的命令："><a href="#不同环境执行的命令：" class="headerlink" title="不同环境执行的命令："></a>不同环境执行的命令：</h4><p>开发环境启动项目：npm run dev</p><p>测试环境打包项目：npm run test</p><p>生产环境打包项目：npm run build</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vue-cli-environment.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vue-cli工具能够快速搭建出vue项目，但在日常开发中，会根据不同的环境应用不同的接口地址，大多分为开发环境、测试环境、生产环境，但vue-cli工具只配置了开发环境与生产环境，但测试环境下也需要打包出来放到服务器上，频繁更改接口地址会很麻烦，其实只要更改下webpack配置，就可以根据设置的命令生成不同环境的项目。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JS判断用户是否在浏览当前页面</title>
    <link href="http://yixirumeng.github.io/2018/03/03/browser-tab-change/"/>
    <id>http://yixirumeng.github.io/2018/03/03/browser-tab-change/</id>
    <published>2018-03-03T04:44:52.000Z</published>
    <updated>2018-03-03T04:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/browser-tab-change.jpg" alt=""></p><blockquote><p>之前在浏览某网站的时候发现，当正在浏览这个网站的页面是，浏览器Tab的title是一些文字，当切换Tab切换到别的页面的时候，title内容变成的另一些文字，这个效果感觉不错，能够吸引用户。想实现这一效果，需要用JS来判断更改title内容。</p></blockquote><a id="more"></a><p>这里需要用到document.hidden这一API来判断页面是否可见，它的值返回的类型为boolean，当为true的时候，表示页面不可见，当为false的时候，表示页面可见。</p><p>搜索这一API知道它的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">document</span>.hidden );</span><br><span class="line">    <span class="comment">// 想要实现效果的代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但这一API有兼容性问题，它的兼容性为：IE10+，Firefox10+，Chrome14+，Opera12.1+，Safari7.1+，所以在代码中要做兼容性处理</p><p>兼容性写法示例：</p><p>HTML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>欢迎浏览<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> hiddenProperty = <span class="string">'hidden'</span> <span class="keyword">in</span> <span class="built_in">document</span> ? <span class="string">'hidden'</span> : <span class="string">'webkitHidden'</span> <span class="keyword">in</span> <span class="built_in">document</span> ? <span class="string">'webkitHidden'</span> : <span class="string">'mozHidden'</span> <span class="keyword">in</span> <span class="built_in">document</span> ? <span class="string">'mozHidden'</span> : <span class="literal">null</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> visibilityChangeEvent = hiddenProperty.replace(<span class="regexp">/hidden/i</span>, <span class="string">'visibilitychange'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> onVisibilityChange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> title = <span class="built_in">document</span>.querySelector(<span class="string">'title'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(!<span class="built_in">document</span>[hiddenProperty])&#123;</span></span><br><span class="line"><span class="actionscript">                title.innerHTML = <span class="string">'欢迎浏览'</span></span></span><br><span class="line"><span class="actionscript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">                title.innerHTML = <span class="string">'记得再来'</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(visibilityChangeEvent, onVisibilityChange)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当浏览此页面的时候，标题显示为“欢迎浏览”，当离开此页面的时候，标题显示为“记得再来”。即使在不兼容这一API的浏览器中打开，标题总是显示为“欢迎浏览”，也不会有很大的影响。</p><p>同时也可以根据这一API来做更多想要的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/browser-tab-change.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前在浏览某网站的时候发现，当正在浏览这个网站的页面是，浏览器Tab的title是一些文字，当切换Tab切换到别的页面的时候，title内容变成的另一些文字，这个效果感觉不错，能够吸引用户。想实现这一效果，需要用JS来判断更改title内容。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="javascript" scheme="http://yixirumeng.github.io/tags/javascript/"/>
    
      <category term="browser" scheme="http://yixirumeng.github.io/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>实现移动端页面滚动加载更多</title>
    <link href="http://yixirumeng.github.io/2018/03/03/scroll-load/"/>
    <id>http://yixirumeng.github.io/2018/03/03/scroll-load/</id>
    <published>2018-03-03T04:44:31.000Z</published>
    <updated>2018-03-03T04:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/scroll-load.jpg" alt=""></p><blockquote><p>PC页面用分页，移动端页面滚动加载更多数据在日常的开发中经常会用到，而JS实现起来也很简单。下面就来说下移动滚动加载更多的解决方案</p></blockquote><a id="more"></a><h3 id="先说下移动端滚动加载更多数据的原理："><a href="#先说下移动端滚动加载更多数据的原理：" class="headerlink" title="先说下移动端滚动加载更多数据的原理："></a>先说下移动端滚动加载更多数据的原理：</h3><p>其请求数据的原理与PC端分页是一样的，改变页码，发送请求，再将数据渲染到页面上。</p><p>而移动页面发送请求的位置要根据滚动的位置来计算，当滚动的高度+屏幕可见高度&gt;页面的高度时，发送请求，同时将数据拿到，追加的页面上</p><p>这里也有要注意的地方，需要设置一个开关来控制是否请求数据，否则会不停发送请求，还有要判断是否加载完毕更多数据，如果加载完则不要继续请求</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sw = <span class="literal">true</span>   (设置开关控制是否发送请求)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    (获取滚动的高度，这里写的两种方法是为浏览器做兼容处理)</span><br><span class="line">    <span class="keyword">var</span> scrollH = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line"></span><br><span class="line">    (获取可视高度，如果只是在某个区域，可以自行获取)</span><br><span class="line">    <span class="keyword">var</span> screenH = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line"></span><br><span class="line">    (获取整个页面高度)</span><br><span class="line">    <span class="keyword">var</span> bodyH = <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    </span><br><span class="line">    (判断开关是否为<span class="literal">true</span>，判断滚动高度+可见高度是否&gt;页面高度，判断是否加载完毕)</span><br><span class="line">    <span class="keyword">if</span>(sw &amp;&amp; (scrollH + screenH &gt; bodyH) &amp;&amp; currentPage &lt; totalPage)&#123; </span><br><span class="line">        sw = <span class="literal">false</span> (将开关关闭)</span><br><span class="line">        currentPage +=<span class="number">1</span> (设置请求下一部分数据的参数)</span><br><span class="line">        ajaxFn() (发送请求的方法)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在发送请求的方法中，获取完数据后，设置开关为<span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*ajax方法*/</span></span><br><span class="line">    sw = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为整体的原理，其它的一些效果，则根据项目的需要再进行修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/scroll-load.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PC页面用分页，移动端页面滚动加载更多数据在日常的开发中经常会用到，而JS实现起来也很简单。下面就来说下移动滚动加载更多的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="mobile" scheme="http://yixirumeng.github.io/tags/mobile/"/>
    
      <category term="scroll" scheme="http://yixirumeng.github.io/tags/scroll/"/>
    
  </entry>
  
  <entry>
    <title>HTML5不重新加载改变url</title>
    <link href="http://yixirumeng.github.io/2018/01/13/not-load-change-url/"/>
    <id>http://yixirumeng.github.io/2018/01/13/not-load-change-url/</id>
    <published>2018-01-13T05:01:01.000Z</published>
    <updated>2018-01-13T05:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/not-load-change-url.jpg" alt=""></p><blockquote><p>有时候想要实现无刷新改变url，尤其是在改变url后的参数时会用到。如果直接在js中修改url总是会重新加载页面，不能满足需求，而HTML5 History新增的两个api分别是pushState和replaceState可以很轻松解决这个问题。</p></blockquote><a id="more"></a><p>先来介绍一下这两个API：<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(data, title, <span class="built_in">url</span>)</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(data, title, <span class="built_in">url</span>)</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">data：提供state data，在用户点击后退，触发<span class="built_in">window</span>.onpopstate时提供此对象。(object类型)</span><br><span class="line">title：重写页面标题，但目前浏览器都会忽略此参数。(<span class="built_in">string</span>类型)</span><br><span class="line"><span class="built_in">url</span>：重写<span class="built_in">url</span>，只会更改<span class="built_in">url</span>部分的内容，并不能更改协议、主机名、端口、IP等内容。(<span class="built_in">string</span>类型)</span><br></pre></td></tr></table></figure></p><p>有了这两个方法，改变url就会很简单，只需设置data的值为空{}、title的值为空””、url的值为新的url就可以实现。</p><h4 id="具体实现方法："><a href="#具体实现方法：" class="headerlink" title="具体实现方法："></a>具体实现方法：</h4><p>假设当前的url为<a href="http://www.example.com?param=1，要实现不刷新页面更改参数param的值为2。(只写简单代码)" target="_blank" rel="noopener">http://www.example.com?param=1，要实现不刷新页面更改参数param的值为2。(只写简单代码)</a></p><p>html:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>更改url<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js:</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">url</span> = <span class="built_in">window</span>.location.origin;</span><br><span class="line">    <span class="keyword">var</span> newUrl = <span class="built_in">url</span> + <span class="string">'?param=2'</span>;</span><br><span class="line">    <span class="built_in">window</span>.history.pushState(&#123;&#125;, <span class="string">""</span>, newUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当点击“更改url”这个按钮后，页面的url就会更改为<a href="http://www.example.com?param=2，并且不会刷新页面。" target="_blank" rel="noopener">www.example.com?param=2，并且不会刷新页面。</a></p><p>这里只给出了很简单方法，其它更改的原理都相同，只不过是对新的url做一些处理。</p><h4 id="另附window的location对象的属性及方法"><a href="#另附window的location对象的属性及方法" class="headerlink" title="另附window的location对象的属性及方法"></a>另附window的location对象的属性及方法</h4><p>以<a href="http://www.example.com:8080/test/test.html?param=1#part2为例" target="_blank" rel="noopener">http://www.example.com:8080/test/test.html?param=1#part2为例</a></p><p>1、window.location.hash 获取url的锚部分<br>返回：#part2</p><p>2、window.location.host 获取url的主机名及端口号<br>返回：<a href="http://www.example.com:8080" target="_blank" rel="noopener">www.example.com:8080</a></p><p>3、window.location.hostname 获取url的主机名<br>返回：<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></p><p>4、window.location.pathname 获取url的路径部分<br>返回：/test/test.html</p><p>5、window.location.port 获取url的端口号<br>返回：8080（注意这里8080的类型是string，不是number）</p><p>6、window.location.search 获取url的参数部分<br>返回：?param=1</p><p>7、window.location.origin 获取主机名及端口号及路径部分<br>返回：<a href="http://www.example.com:8080/test/test.html" target="_blank" rel="noopener">http://www.example.com:8080/test/test.html</a></p><p>8、window.location.protocol 获取url的协议<br>返回：http:</p><p>9、window.location.href 获取整个url地址<br>返回：<a href="http://www.example.com:8080/test/test.html?param=1#part2" target="_blank" rel="noopener">http://www.example.com:8080/test/test.html?param=1#part2</a></p><p>10、window.location.assign(“newUrl”) 加载一个新的地址<br>链接跳转到newUrl，可以后退到之前的url</p><p>11、window.location.reload() 重新加载当前页面<br>该方法内的参数默认为false，如果设置为true，会绕过缓存，重新加载整个页面</p><p>12、window.location.replace(“newUrl”) 用新的newUrl替换当前的url<br>无法后退到之前的url</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/not-load-change-url.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有时候想要实现无刷新改变url，尤其是在改变url后的参数时会用到。如果直接在js中修改url总是会重新加载页面，不能满足需求，而HTML5 History新增的两个api分别是pushState和replaceState可以很轻松解决这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="javascript" scheme="http://yixirumeng.github.io/tags/javascript/"/>
    
      <category term="Html5" scheme="http://yixirumeng.github.io/tags/Html5/"/>
    
  </entry>
  
  <entry>
    <title>原生Javascript封装ajax</title>
    <link href="http://yixirumeng.github.io/2017/12/31/javascript-ajax/"/>
    <id>http://yixirumeng.github.io/2017/12/31/javascript-ajax/</id>
    <published>2017-12-31T07:55:26.000Z</published>
    <updated>2017-12-31T07:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/javascript-ajax.jpg" alt=""></p><blockquote><p>ajax对于前端来说并不陌生，在与后端进行交互的时候基本上都会用到。平时在使用的时候，大多数的前端er会采用jquery或者其它框架已经封装好的ajax请求，直接调用，但是如果在简单项目中，只需用到ajax，这样引入jquery显得有些过重，所以用原生JS封装好ajax函数直接调用，会方便许多。</p></blockquote><a id="more"></a><p>用原生JS封装ajax并不是很困难，只要清楚其中每一步的原理和操作，就能轻松写出来。（这里只做出简要的说明，并没有写出完整的逻辑判断）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">opt为ajax传递的参数，其值有以下几个：</span><br><span class="line">    <span class="number">1</span>、* @param &#123;<span class="keyword">string</span>&#125;opt.type http连接的方式，包括POST和GET两种方式</span><br><span class="line">    <span class="number">2</span>、* @param &#123;<span class="keyword">string</span>&#125;opt.url 发送请求的url</span><br><span class="line">    <span class="number">3</span>、* @param &#123;boolean&#125;opt.<span class="keyword">async</span> 是否为异步请求，<span class="literal">true</span>为异步，<span class="literal">false</span>为同步</span><br><span class="line">    <span class="number">4</span>、* @param &#123;<span class="keyword">object</span>&#125;opt.data 发送的参数，格式为对象类型</span><br><span class="line">    <span class="number">5</span>、* @param &#123;function&#125;opt.success ajax发送并接收成功调用的回调函数</span><br><span class="line">     </span><br><span class="line"><span class="function">function <span class="title">ajax</span>(<span class="params">opt</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对所传参数进行判断</span></span><br><span class="line">    opt = opt || &#123;&#125;;</span><br><span class="line">    opt.method = opt.method.toUpperCase() || <span class="string">'POST'</span>;</span><br><span class="line">    opt.url = opt.url || <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(opt.<span class="keyword">async</span>) == <span class="string">'undefined'</span>)&#123;</span><br><span class="line">        opt.<span class="keyword">async</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    opt.data = opt.data || <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ajax对象</span></span><br><span class="line">    <span class="keyword">var</span> xmlHttp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(XMLHttpRequest)&#123;</span><br><span class="line">        xmlHttp = <span class="keyword">new</span> XMLHttpRquest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//兼容ie6</span></span><br><span class="line">        xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHttp'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对传递的data参数进行格式化</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">params</span> = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> opt.data)&#123;</span><br><span class="line">        <span class="keyword">params</span>.push(key + <span class="string">'='</span> + opt.data[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="keyword">params</span>.<span class="keyword">join</span>(<span class="string">'&amp;'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断请求方式，连接服务器，发送请求方式、链接、是否异步、参数</span></span><br><span class="line">    <span class="keyword">if</span>(opt.method === <span class="string">'POST'</span>)&#123;</span><br><span class="line">        xmlHttp.open(opt.method, opt.url, opt.<span class="keyword">async</span>);</span><br><span class="line">        xmlHttp.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded;charset=utf-8'</span>);</span><br><span class="line">        xmlHttp.send(postData);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt.method === <span class="string">'GET'</span>)&#123;</span><br><span class="line">        xmlHttp.open(opt.method, opt.url + <span class="string">'?'</span> + postData, opt.<span class="keyword">async</span>);</span><br><span class="line">        xmlHttp.send(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否请求成功，如果成功，接收返回值</span></span><br><span class="line">    xmlHttp.onreadyStateChange = function()&#123;</span><br><span class="line">        <span class="keyword">if</span>(xmlHttp.readystate == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> response = JSON.parse(responseText);</span><br><span class="line">            success(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样引入这个JS库，并在页面中调用封装好的ajax，并传递相应的参数，就可以像应用jquery的ajax方法一样与后台进行交互了。</p><p>在去面试的时候，很多面试官会要求手写ajax，只要理清思路，一步接一步下来，很轻松就能写出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/javascript-ajax.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ajax对于前端来说并不陌生，在与后端进行交互的时候基本上都会用到。平时在使用的时候，大多数的前端er会采用jquery或者其它框架已经封装好的ajax请求，直接调用，但是如果在简单项目中，只需用到ajax，这样引入jquery显得有些过重，所以用原生JS封装好ajax函数直接调用，会方便许多。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="javascript" scheme="http://yixirumeng.github.io/tags/javascript/"/>
    
      <category term="ajax" scheme="http://yixirumeng.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>轻松解决鼠标移入事件多次触发</title>
    <link href="http://yixirumeng.github.io/2017/12/09/hover-event/"/>
    <id>http://yixirumeng.github.io/2017/12/09/hover-event/</id>
    <published>2017-12-09T07:07:06.000Z</published>
    <updated>2017-12-09T07:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/hover-event.jpg" alt=""></p><blockquote><p>在做鼠标移入触发事件时，有时会遇到事件多次触发，想尽办法，但最终的效果都不是很好。其实只要几行代码，就可以轻松解决。</p></blockquote><a id="more"></a><p>为了方便大多数的前端er学习，下面以jquery来说明，原生js和其他框架的道理一样的。</p><p>正常调用jqery的hover方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"selector"</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//鼠标移入执行的代码</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//鼠标移出执行的代码</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样偶尔会出现移入的事件多次触发。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer;</span><br><span class="line">    $(<span class="string">"selector"</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//鼠标移入执行的代码</span></span><br><span class="line">        &#125;, <span class="number">200</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="comment">//鼠标移出执行的代码</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>200的数值可以随意设置，只要设置小一点，基本上看不出延迟，但也不要过小。</p><p>代码很容易看懂，就是在鼠标移入之前加了短暂的延迟，这样就能轻松避免鼠标移入多次执行事件，以及过快重复移入鼠标导致上一事件没执行完，下一事件又开始了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/hover-event.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在做鼠标移入触发事件时，有时会遇到事件多次触发，想尽办法，但最终的效果都不是很好。其实只要几行代码，就可以轻松解决。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="JS" scheme="http://yixirumeng.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS border制作三角形详解</title>
    <link href="http://yixirumeng.github.io/2017/12/02/border-triangle/"/>
    <id>http://yixirumeng.github.io/2017/12/02/border-triangle/</id>
    <published>2017-12-02T11:01:17.000Z</published>
    <updated>2017-12-02T11:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/border-triangle.jpg" alt=""></p><blockquote><p>前端工程师在做页面遇到三角形的时候，以前都是用图片来代替，后在网上出现了用CSS样式就可以实现，这也受到了很多人的青睐，但具体为何如此设置样式就可以呈现这种效果，很多同学都模棱两可。现在就通过例子来揭晓。</p></blockquote><a id="more"></a><p>新建一个html，为了简单，只写了一个<code>div</code>，同时增加些样式。</p><p>html:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>css:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">25px</span> solid blue;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">25px</span> solid yellow;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">25px</span> solid green;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">25px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时的效果是：<br>    <div align="center"><img src="/assets/blogImg/border-triangle1.png" alt=""></div></p><p>可以看到，边框是以梯形的方式呈现出来的。</p><p>当把<code>div</code>的宽度、高度都缩小到0的时候，此时的效果是：<br>    <div align="center"><img src="/assets/blogImg/border-triangle2.png" alt=""></div></p><p>四个方向的边框都是以三角形的方式呈现的。</p><p>现在更改一下css，让相邻的两个方向的边框颜色呈现默认颜色transparent：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">25px</span> solid blue;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">25px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">25px</span> solid transparent;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在的效果为：<br>    <div align="center"><img src="/assets/blogImg/border-triangle3.png" alt=""></div></p><p>此时三角形的宽度为<code>50px</code>。</p><p>这也就很好理解为什么在网上查到的css样式可以轻松实现出三角形的效果了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="用css实现三角形可以通过以下步骤来实现："><a href="#用css实现三角形可以通过以下步骤来实现：" class="headerlink" title="用css实现三角形可以通过以下步骤来实现："></a>用css实现三角形可以通过以下步骤来实现：</h5><h5 id="1、设置元素的宽度、高度都为0。"><a href="#1、设置元素的宽度、高度都为0。" class="headerlink" title="1、设置元素的宽度、高度都为0。"></a>1、设置元素的宽度、高度都为0。</h5><h5 id="2、根据三角形箭头朝向、颜色的需要，来设置border值。"><a href="#2、根据三角形箭头朝向、颜色的需要，来设置border值。" class="headerlink" title="2、根据三角形箭头朝向、颜色的需要，来设置border值。"></a>2、根据三角形箭头朝向、颜色的需要，来设置border值。</h5><h5 id="3、为三角形箭头朝向的反方向、以及相邻两个方向设置同样的长度，并为反方向设置需要呈现的颜色，相邻两个方向的颜色设置为transparent。（此为等边三角形，想要其它三角形，可以调整长度）"><a href="#3、为三角形箭头朝向的反方向、以及相邻两个方向设置同样的长度，并为反方向设置需要呈现的颜色，相邻两个方向的颜色设置为transparent。（此为等边三角形，想要其它三角形，可以调整长度）" class="headerlink" title="3、为三角形箭头朝向的反方向、以及相邻两个方向设置同样的长度，并为反方向设置需要呈现的颜色，相邻两个方向的颜色设置为transparent。（此为等边三角形，想要其它三角形，可以调整长度）"></a>3、为三角形箭头朝向的反方向、以及相邻两个方向设置同样的长度，并为反方向设置需要呈现的颜色，相邻两个方向的颜色设置为transparent。（此为等边三角形，想要其它三角形，可以调整长度）</h5><h5 id="4、border设置的长度为需要长度的一半。"><a href="#4、border设置的长度为需要长度的一半。" class="headerlink" title="4、border设置的长度为需要长度的一半。"></a>4、border设置的长度为需要长度的一半。</h5><h5 id="用这种方法，并配合before、after等伪元素，可以轻松实现出很多效果，不用再辛苦切图片调整位置了。"><a href="#用这种方法，并配合before、after等伪元素，可以轻松实现出很多效果，不用再辛苦切图片调整位置了。" class="headerlink" title="用这种方法，并配合before、after等伪元素，可以轻松实现出很多效果，不用再辛苦切图片调整位置了。"></a>用这种方法，并配合<code>before</code>、<code>after</code>等伪元素，可以轻松实现出很多效果，不用再辛苦切图片调整位置了。</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/border-triangle.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前端工程师在做页面遇到三角形的时候，以前都是用图片来代替，后在网上出现了用CSS样式就可以实现，这也受到了很多人的青睐，但具体为何如此设置样式就可以呈现这种效果，很多同学都模棱两可。现在就通过例子来揭晓。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="css" scheme="http://yixirumeng.github.io/tags/css/"/>
    
      <category term="border" scheme="http://yixirumeng.github.io/tags/border/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件开发心得</title>
    <link href="http://yixirumeng.github.io/2017/11/26/vue-components-develop/"/>
    <id>http://yixirumeng.github.io/2017/11/26/vue-components-develop/</id>
    <published>2017-11-26T03:56:17.000Z</published>
    <updated>2017-11-26T04:01:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/vue-components-develop.jpg" alt=""></p><blockquote><p>不谈技术、只谈心得。多思考、多查资料，Vue可复用组件并不难写。</p></blockquote><a id="more"></a><p>从vue刚开源没多长时间，就开始关注，应用到大大小小项目中也已经接近两年，感觉这个框架真的越用越好用，轻量是一方面，重要的是很容易上手，即使遇到不懂得地方，查一下官方文档，就能马上解决。</p><p>在做实际的项目中，经常会有很多相似的地方，比如轮播图、跑马灯、弹出框等，之前为了快速开发完成项目进度，一直都在使用别人造好的轮子。其实自己也很想封装出一套自己的vue组件，不仅可以更加方便开发，也可以加深一下对vue的理解。</p><p>在开发之前思考了很多，把能想到的地方都尽量想到，并分析该怎样做出复用性很强的组件。</p><h4 id="拿轮播图组件来简单说一下："><a href="#拿轮播图组件来简单说一下：" class="headerlink" title="拿轮播图组件来简单说一下："></a>拿轮播图组件来简单说一下：</h4><p>看过github上大神写的源码，很多应用了slot（不知道的查一下官方文档，说的很详细）来控制组件内部的元素，感觉确实很方便。</p><p>其实除了这种方法，还可以通过数据传递，并配合vue已经存在的属性，共同来完成组件。在做轮播图组件的时候便应用了这种方法，而且也很简单。</p><p>平时做的轮播图，大多都是左右移动、淡入淡出的效果。在vue文档“过渡&amp;动画”这一块儿，对过渡、动画做出了详细的介绍，只要应用<code>enter</code>、<code>enter-active</code>、<code>leave</code>、<code>leave-active</code>这几个属性，并配合css就可以轻松实现，这样做轮播图组件便简单许多。而内部元素通过data数据进行传递，不仅易于复用，还可以轻松做到与后台的交互。</p><p>建议在开发时更多用slot方法，而对于用数据传递的方式能够更便于使用者使用的组件，选择这种方法会更好。</p><h4 id="API设置"><a href="#API设置" class="headerlink" title="API设置"></a>API设置</h4><p>对于设置组件参数这块，想的比较全面，把能控制的地方全部设置了参数，包括对样式的控制。网上大多组件都是传递参数改变状态，并没让使用者对样式做出调整，这样在使用时，可能还需要进行源代码修改，感觉不是很方便。</p><p>把一个组件做好后，一定要做的是写demo，尽量把内容写的全面，包括使用方式、API、不同的效果，让使用者能轻易看懂，因为使用者使用这个组件当然是为了要方便开发，如果看文档demo都很费劲，那为何不自己去写一个呢。</p><h4 id="记得开源"><a href="#记得开源" class="headerlink" title="记得开源"></a>记得开源</h4><p>代码写好后，尽量还是开源放到github上，这样就会有很多大神来帮助完善，前期可能不会，但是不要气馁，坚持下去，总会有人发现你的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>组件的开发并未有想象中那么难，只要理清思路，把想要呈现的效果一步一步写好，把该做活的地方做出来就可以了。当然也会遇到坑，不要着急，多查资料，查文档，google，百度，都会解决，因为很多坑都有大神为你填好了。</p><p>这篇没有谈技术，只是说出一些自己的心得，其中也有很多不足之处，还需要继续学习，后续会给出所做的组件github地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/vue-components-develop.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不谈技术、只谈心得。多思考、多查资料，Vue可复用组件并不难写。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
      <category term="component" scheme="http://yixirumeng.github.io/tags/component/"/>
    
  </entry>
  
  <entry>
    <title>图片与文字上下对齐</title>
    <link href="http://yixirumeng.github.io/2017/11/09/image-words-alignment/"/>
    <id>http://yixirumeng.github.io/2017/11/09/image-words-alignment/</id>
    <published>2017-11-09T14:10:35.000Z</published>
    <updated>2017-11-26T03:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/image-words-alignment1.jpg" alt=""></p><blockquote><p>简单几行代码，轻松实现</p></blockquote><a id="more"></a><p>在浏览网站，尤其是移动端电商网站的时候，经常会看到如下图片与文字对齐的情况<br>    <div align="center"><img src="/assets/blogImg/image-words-alignment2.jpg" alt=""></div></p><p>平时开发类似的页面时，可以用简单的img、div、span、a等标签进行布局，再通过调整CSS样式，可以达到这种效果。</p><h4 id="其实在html5的新标签中，有专门为实现这种效果的标签，相信很多人都用过，那就是dl、dt、dd，而且用起来非常简单。"><a href="#其实在html5的新标签中，有专门为实现这种效果的标签，相信很多人都用过，那就是dl、dt、dd，而且用起来非常简单。" class="headerlink" title="其实在html5的新标签中，有专门为实现这种效果的标签，相信很多人都用过，那就是dl、dt、dd，而且用起来非常简单。"></a>其实在html5的新标签中，有专门为实现这种效果的标签，相信很多人都用过，那就是dl、dt、dd，而且用起来非常简单。</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:100px; margin:100px auto; text-align:center; font-size:14px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片路径"</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>风控短信<span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>呈现的效果：<br>    <div align="center"><img src="/assets/blogImg/image-words-alignment3.jpg" alt=""></div></p><p>简单的通过几行代码就可以轻松实现，再也不用辛苦的调各种样式啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/image-words-alignment1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单几行代码，轻松实现&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="css" scheme="http://yixirumeng.github.io/tags/css/"/>
    
      <category term="html" scheme="http://yixirumeng.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>同一链接，每次无缓存加载</title>
    <link href="http://yixirumeng.github.io/2017/10/31/nocache-loading/"/>
    <id>http://yixirumeng.github.io/2017/10/31/nocache-loading/</id>
    <published>2017-10-31T13:20:56.000Z</published>
    <updated>2017-10-31T13:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何在每次访问同一链接时，加载到的页面都是没有缓存效果呢？简单一步帮你解决。</p></blockquote><a id="more"></a><p>缓存对于web开发者来说并不陌生（不知道的可以百度一下），平时在开发的过程中，为了能够看到没有缓存的效果，大家一般都采用无痕模式的浏览器，这样按<code>F5</code>之后，显示的就是没有缓存的效果，或者直接按<code>Ctrl + F5</code>，也能达到同样的效果。</p><p>但是对于普通用户来说，相信有一大部分用户都不清楚缓存的概念，即使知道的，可能更多是知道在浏览器设置中选择一下清理浏览器缓存，但具体干了什么，还是不明白。</p><p>如何让用户访问域名之后，每次访问的都是没有缓存的效果呢？</p><h5 id="其实也很简单，只要在url的后面增加一个参数（参数名随意），而参数的值是一个随机数（Math-random-）就可以了，随机数的位数可以自己定义，正常3到4位的随机数就足够了，会用JS的应该对这块不会陌生。这样既不会影响用户的使用，同时也使得用户每次访问的都是没有缓存的页面，是不是很简单。"><a href="#其实也很简单，只要在url的后面增加一个参数（参数名随意），而参数的值是一个随机数（Math-random-）就可以了，随机数的位数可以自己定义，正常3到4位的随机数就足够了，会用JS的应该对这块不会陌生。这样既不会影响用户的使用，同时也使得用户每次访问的都是没有缓存的页面，是不是很简单。" class="headerlink" title="其实也很简单，只要在url的后面增加一个参数（参数名随意），而参数的值是一个随机数（Math.random()）就可以了，随机数的位数可以自己定义，正常3到4位的随机数就足够了，会用JS的应该对这块不会陌生。这样既不会影响用户的使用，同时也使得用户每次访问的都是没有缓存的页面，是不是很简单。"></a>其实也很简单，只要在url的后面增加一个参数（参数名随意），而参数的值是一个随机数（<code>Math.random()</code>）就可以了，随机数的位数可以自己定义，正常3到4位的随机数就足够了，会用JS的应该对这块不会陌生。这样既不会影响用户的使用，同时也使得用户每次访问的都是没有缓存的页面，是不是很简单。</h5><p>当然，这样也有很大的弊端，那就是每次用户都要重新加载所有的资源，包括页面中引用的CSS、JS、图片、字体等等，影响加载速度。是否可以牺牲一些加载速度，达到每次都是最新的效果，还是要视情况而定。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如何在每次访问同一链接时，加载到的页面都是没有缓存效果呢？简单一步帮你解决。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="extend" scheme="http://yixirumeng.github.io/tags/extend/"/>
    
      <category term="无缓存加载" scheme="http://yixirumeng.github.io/tags/%E6%97%A0%E7%BC%93%E5%AD%98%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JS事件冒泡与捕获，以及阻止事件冒泡</title>
    <link href="http://yixirumeng.github.io/2017/10/31/propagation-capture/"/>
    <id>http://yixirumeng.github.io/2017/10/31/propagation-capture/</id>
    <published>2017-10-31T13:17:22.000Z</published>
    <updated>2017-10-31T13:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JS事件的冒泡与捕获在平时的开发中时常会遇到，以下用简单的叙述以及案例详细解释冒泡与捕获。同时给出阻止事件冒泡的方法。</p></blockquote><a id="more"></a><p>平时在写JS时，可能会在父子元素上都增加事件，这样就产生了事件的冒泡与捕获。</p><h4 id="冒泡：事件的冒泡简单说，是事件从内向外依次执行"><a href="#冒泡：事件的冒泡简单说，是事件从内向外依次执行" class="headerlink" title="冒泡：事件的冒泡简单说，是事件从内向外依次执行"></a>冒泡：事件的冒泡简单说，是事件从内向外依次执行</h4><h4 id="捕获：事件的捕获简单说，是事件从外向内依次执行"><a href="#捕获：事件的捕获简单说，是事件从外向内依次执行" class="headerlink" title="捕获：事件的捕获简单说，是事件从外向内依次执行"></a>捕获：事件的捕获简单说，是事件从外向内依次执行</h4><p>在HTML的DOM操作中，为元素增加事件的方法是addEventListener，这个方法的第三个参数是一个Boolean值，当为false时，指定事件在冒泡阶段执行；当为true时，在捕获阶段执行，默认值为false。</p><p>以下通过实例简单说明一下（自己也可以仿照一下代码试一下，给一些样式效果会更加明显）：</p><p>HTML:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">      父元素</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span>子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(<span class="string">"我是父元素"</span>);</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(<span class="string">"我是子元素"</span>);</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="当点击“子元素”时，会依次弹出“我是子元素”、“我是父元素”；如果将两个参数false都改为true后，点击“子元素”后，会依次弹出“我是父元素”，“我是子元素”。"><a href="#当点击“子元素”时，会依次弹出“我是子元素”、“我是父元素”；如果将两个参数false都改为true后，点击“子元素”后，会依次弹出“我是父元素”，“我是子元素”。" class="headerlink" title="当点击“子元素”时，会依次弹出“我是子元素”、“我是父元素”；如果将两个参数false都改为true后，点击“子元素”后，会依次弹出“我是父元素”，“我是子元素”。"></a>当点击“子元素”时，会依次弹出“我是子元素”、“我是父元素”；如果将两个参数<code>false</code>都改为<code>true</code>后，点击“子元素”后，会依次弹出“我是父元素”，“我是子元素”。</h5><h5 id="如果将其中的一个设置为true，另一个为false，那么将根据父元素设置的值来判断。如果父元素设置为true，将在捕获阶段执行，反之，则在冒泡阶段执行。"><a href="#如果将其中的一个设置为true，另一个为false，那么将根据父元素设置的值来判断。如果父元素设置为true，将在捕获阶段执行，反之，则在冒泡阶段执行。" class="headerlink" title="如果将其中的一个设置为true，另一个为false，那么将根据父元素设置的值来判断。如果父元素设置为true，将在捕获阶段执行，反之，则在冒泡阶段执行。"></a>如果将其中的一个设置为<code>true</code>，另一个为<code>false</code>，那么将根据父元素设置的值来判断。如果父元素设置为<code>true</code>，将在捕获阶段执行，反之，则在冒泡阶段执行。</h5><p>其实事件的捕获与时间的冒泡并不是很难理解，但是在实际应用中，我们只希望事件发生在目标元素上，这就需要阻止事件的冒泡，以此来达到我们需要的效果。阻止冒泡的方式有以下几种：</p><h4 id="原生JS方法"><a href="#原生JS方法" class="headerlink" title="原生JS方法"></a>原生JS方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">if</span>(e.stopPropagation)&#123;    <span class="comment">//W3C阻止冒泡方法</span></span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        e.cancelBubble = <span class="literal">true</span>; <span class="comment">//IE阻止冒泡方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也可以简写：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    e.stopPropagation?e.stopPropagation():e.cancelBubble=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将此方法放入之前的代码中，并在addEventListener方法中调用，就会阻止事件冒泡。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(<span class="string">"我是父元素"</span>);</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">alert(<span class="string">"我是子元素"</span>);</span></span><br><span class="line"><span class="undefined">          stopPropagation(e);</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时点击“子元素”时，将只弹出“我是子元素”。</p><h4 id="jquery方法："><a href="#jquery方法：" class="headerlink" title="jquery方法："></a>jquery方法：</h4><p>直接在事件内部调用<code>e.stopPropagation()</code>方法，就可以阻止事件冒泡，jquery已经做好了IE兼容性处理，这里就不需要写IE的方法。</p><p>虽然jquery用起来比较简单，但是还是应该了解原生JS的使用。在不同的环境下，应用不同的方法，可以使得开发更有效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JS事件的冒泡与捕获在平时的开发中时常会遇到，以下用简单的叙述以及案例详细解释冒泡与捕获。同时给出阻止事件冒泡的方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="JS" scheme="http://yixirumeng.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS水平垂直居中方法总结</title>
    <link href="http://yixirumeng.github.io/2017/10/14/css-horizontal-vertical-center/"/>
    <id>http://yixirumeng.github.io/2017/10/14/css-horizontal-vertical-center/</id>
    <published>2017-10-14T08:04:10.000Z</published>
    <updated>2017-10-14T08:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>平时在做项目的时候，会遇到让元素在水平方向和垂直方向同时居中的情况，典型的例子就是弹出框（点击某个按钮，出现弹出框）。要实现这个需求，用css就可以完全控制，非常方便。</p></blockquote><a id="more"></a><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>这个方法是同事告诉我的，用的是table布局，也就<code>display:table</code>，相对来说是种旧的方式。</p><p>HTML:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"fixBox"</span>&gt; （fixBox是为了实现弹出框悬浮）</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box1"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box2"</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><p>CSS:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fixBox</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样可以让box元素居中，但是比较复杂，要套很多层标签，显得有些复杂。（不推荐使用）</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>采用定位的方式，也就是<code>position:absolute</code></p><p>HTML:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">box&#123;</span></span><br><span class="line"><span class="keyword"> </span>   width:<span class="number">400</span>px<span class="comment">;</span></span><br><span class="line"><span class="symbol">    height:</span><span class="number">400</span>px<span class="comment">;</span></span><br><span class="line"><span class="symbol">    position:</span>absolute<span class="comment">;  让元素绝对定位</span></span><br><span class="line"><span class="symbol">    left:</span><span class="number">50</span>%<span class="comment">;           设置定位的位置距离左、上都为50%</span></span><br><span class="line"><span class="symbol">    top:</span><span class="number">50</span>%<span class="comment">;</span></span><br><span class="line">    margin-left:-<span class="number">100</span>px<span class="comment">; 设置元素的左外边距、上外边距都为宽高的负1/2</span></span><br><span class="line">    margin-top:-<span class="number">200</span>px<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法兼容性好，但是有个前提是必须要知道水平垂直元素的宽高。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>方法三跟方法二相类似，需要变换的只是不需要设置外边距，而是使用CSS3的<code>transform</code></p><p>将margin都去掉，换成<code>transform:translate(-50%,-50%)</code>,设置元素相对于自身偏移负50%，也就是自身尺寸的一半</p><p>这种方法因为使用CSS3的样式，所以兼容性不好，但是用起来很方便。</p><h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><p>方法四跟方法二也很类似，同样使用绝对定位，也需要用到margin值，只不过需要改变一下位置距离的值。</p><p>HTML:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想兼容低版本的浏览器，可以采用方法四，因为不需要用到CSS3的样式，同时对于元素的宽高也不是必须要知道的。</p><h5 id="每种方法都有自身的优缺点，在平时的开发中，根据实际情况以及需求来决定具体应用哪一种方法。"><a href="#每种方法都有自身的优缺点，在平时的开发中，根据实际情况以及需求来决定具体应用哪一种方法。" class="headerlink" title="每种方法都有自身的优缺点，在平时的开发中，根据实际情况以及需求来决定具体应用哪一种方法。"></a>每种方法都有自身的优缺点，在平时的开发中，根据实际情况以及需求来决定具体应用哪一种方法。</h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;平时在做项目的时候，会遇到让元素在水平方向和垂直方向同时居中的情况，典型的例子就是弹出框（点击某个按钮，出现弹出框）。要实现这个需求，用css就可以完全控制，非常方便。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://yixirumeng.github.io/tags/web/"/>
    
      <category term="css" scheme="http://yixirumeng.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Vue非父子组件之间的通信（不应用Vuex）</title>
    <link href="http://yixirumeng.github.io/2017/10/04/vue-$on/"/>
    <id>http://yixirumeng.github.io/2017/10/04/vue-$on/</id>
    <published>2017-10-04T09:53:36.000Z</published>
    <updated>2017-10-14T08:38:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在做Vue父子组件间的通信时，更多的方法是采用Vuex这个状态管理管理工具，相对来说比较方便。但是在读官方文档时，会看到文档采用<code>$on</code>、<code>$emit</code>来实现通信效果，但在不用Vuex的情况下，到底如何应用这两个API呢？</p></blockquote><a id="more"></a><p>Vue的文档对非父子组件通信的说明是采用创建一个空的Vue实例作为中介，然后应用<code>$emit</code>、<code>$on</code>两个API来达到信息传递的效果<br>    <div align="center"><img src="/assets/blogImg/vue-$on.jpg" alt=""></div></p><p>现在用Vue开发，基本上都会采用webpack搭建，使用官方提供的Vue-Cli脚手架工具，但是这里面的的问题是，在什么位置创建这个空的Vue实例呢？尝试过很多方法，也试过在vue的组件内部分别创建，运行后不起作用，仔细思考一下，这个实例也只是对该组件起作用，并不会影响到其它的组件。</p><p>再看一下官网的API文档，看到了有<code>$root</code>这个方法，可以访问到根实例，这样就可以在根实例中定义一个空的Vue实例供组件调用。而根实例当然就是入口文件，用脚手架的话就是<code>main.js</code>这个文件。具体的方法为：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">Vue</span>(&#123;</span><br><span class="line">    <span class="attribute">el</span>: <span class="string">'#app'</span>,</span><br><span class="line">    router,</span><br><span class="line">    <span class="attribute">template</span>: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">    <span class="attribute">components</span>: &#123; App &#125;,</span><br><span class="line">    <span class="selector-tag">data</span>()&#123;</span><br><span class="line">        <span class="selector-tag">return</span> &#123;</span><br><span class="line">            <span class="attribute">Bus</span>: new Vue()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>将Bus定义在data中，任何组件都可以访问到。现在就可以定义两个组件来试验一下(随便写的两个组件，记得配置路由，具体代码就不贴出来了)：</p><h5 id="组件A"><a href="#组件A" class="headerlink" title="组件A:"></a>组件A:</h5><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment"</span>&gt;</span></span><span class="template-variable">&#123;&#123; count &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    export default&#123;</span></span><br><span class="line"><span class="xml">        data()&#123;</span></span><br><span class="line"><span class="xml">            return &#123;</span></span><br><span class="line"><span class="xml">                count: 0,</span></span><br><span class="line"><span class="xml">                count1: '你好'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        methods:&#123;</span></span><br><span class="line"><span class="xml">            increment()&#123;</span></span><br><span class="line"><span class="xml">                this.count++;</span></span><br><span class="line"><span class="xml">                this.$root.Bus.$emit('increment', this.count1);</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="组件B"><a href="#组件B" class="headerlink" title="组件B:"></a>组件B:</h5><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    export default&#123;</span></span><br><span class="line"><span class="xml">        data()&#123;</span></span><br><span class="line"><span class="xml">            return &#123;</span></span><br><span class="line"><span class="xml">                msg: '晚安'</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        created()&#123;</span></span><br><span class="line"><span class="xml">            this.$root.Bus.$on('increment', function(msg1)&#123;</span></span><br><span class="line"><span class="xml">                console.log(msg1)</span></span><br><span class="line"><span class="xml">            &#125;)</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>组件A是一个按钮，定义了点击事件，点击后可以让数字加1；组件B只是简单的展示。在组件A上用<code>$emit</code>触发当前实例上的<code>increment</code>事件，同时将<code>count1</code>作为参数传递出去，组件B应用<code>$on</code>监听<code>increment</code>事件，同时获得所传的参数，并在控制台上打印出来。当点击组件A的按钮后，就可以在组件B的控制台上看到了“晚安”两个字，这样也就按着官网的方法实现了非父子组件间的通信。</p><p>其实这并不是推荐方式，最好还是使用官方推出的Vuex状态管理工具，所有组件的状态都能提取出来，更加方便管理。这里介绍的方法只是想应用官方文档说明的方式来做出一个具体的实例。　　</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在做Vue父子组件间的通信时，更多的方法是采用Vuex这个状态管理管理工具，相对来说比较方便。但是在读官方文档时，会看到文档采用&lt;code&gt;$on&lt;/code&gt;、&lt;code&gt;$emit&lt;/code&gt;来实现通信效果，但在不用Vuex的情况下，到底如何应用这两个API呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="framework" scheme="http://yixirumeng.github.io/tags/framework/"/>
    
      <category term="vue" scheme="http://yixirumeng.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
