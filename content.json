[{"title":"Vuex源码分析六 ———— mapMutations","date":"2019-01-24T12:34:41.000Z","path":"2019/01/24/vuex-source-code-mapMutations/","text":"说完了actions的Api，当然少不了mutations的Api————mapMutations，下面来看看其源码 mapMutationsmapMutations与mapActions的原理很相似，只不过就是调用了this.$store.commit方法来修改state 12345678910111213141516171819const mapMutations = normalizeNamespace((namespace, mutations) =&gt; &#123; const res = &#123;&#125; normalizeMap(mutations).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedMutation (...args) &#123; let commit = this.$store.commit if (namespace) &#123; const module = getModuleByNamespace(this.$store, 'mapMutations', namespace) if (!module) &#123; return &#125; commit = module.context.commit &#125; return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args)) &#125; &#125;) return res&#125;) mapMutations在Vue组件中的应用12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapGetters, mapMutations &#125; from 'vuex' export default &#123; computed: &#123; ...mapGetters(['num']) &#125;, methods: &#123; ...mapMutations(['increment']) &#125; &#125;&lt;/script&gt; 写法基本一致，当然传入的参数也可以是对象，也可以做其它名称的映射。 总结mapMutations没有特别想要说的，理解了mapActions也就明白了它的原理。 可以看出，这些方便操作的Api，其内部实现的原理还是要应用Store中定义的方法，只不过方便开发时的书写，来将其进一步封装。 整体总结以上分了几个篇幅来讲解Vuex的源码，经过分析之后，理解其内部的思想，也可以看出它与Redux的区别。这样可以让我们在开发使用的时候，更加得心应手，以前只知道这样写，但是为什么却不得而知。而读过源码之后，即使在出现问题的时候，也可以很轻松的定位到问题所在。 学到的知识1、class类的使用，深入理解面向对象编程的思想。 2、加深理解数组、对象、字符串等类型操作的各种Api。 3、高阶函数的灵活运用，Vuex将高阶函数应用到了极致，看源码可知，很多地方都应用了高阶函数，使得整体更加完善，逻辑更加清晰。 4、工具函数、方法的拆分。 5、理解工具、框架的核心思想。 6、还是那句话，基础最最重要，基础打好，更方便开发。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yixirumeng.github.io/tags/vuex/"}]},{"title":"Vuex源码分析五 ———— mapActions","date":"2019-01-20T05:08:56.000Z","path":"2019/01/20/vuex-source-code-mapActions/","text":"前两篇文章分析了获取状态的两个Api，这一篇分析一下派发action的Api————mapActions mapActionsmapActions也可以以数组或者对象作为参数，其内部调用的依然是this.$store.dispatch来派发action，看下面这个函数有个主意点就是...args，它其实就是我们在开发时传给mapActions中方法的参数，也就是this.increment(1)中的这个1 12345678910111213141516171819const mapActions = normalizeNamespace((namespace, actions) =&gt; &#123; const res = &#123;&#125; normalizeMap(actions).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedAction (...args) &#123; let dispatch = this.$store.dispatch if (namespace) &#123; const module = getModuleByNamespace(this.$store, 'mapActions', namespace) if (!module) &#123; return &#125; dispatch = module.context.dispatch &#125; return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args)) &#125; &#125;) return res&#125;) mapActions在Vue组件中的应用12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapGetters, mapActions &#125; from 'vuex' export default &#123; computed: &#123; ...mapGetters(['num']) &#125;, methods: &#123; ...mapActions(['increment']) &#125; &#125;&lt;/script&gt; 用法跟之前分析的mapState、mapGetters类似，当然也可以传入对象进行映射，即mapActions({add: &#39;increment&#39;})，这样调用add方法也就相当于调用了increment方法。 总结mapActions的用法及原理上面已经说了，这里就不在阐述了。因为action支持异步操作，看过前面对Store的源码分析之后可以知道，action是可以合并的，同时dispatch返回的是Promise，所以在处理等待某个请求之后再执行下一个请求的这种操作时，可以使用以下的方式： 12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 如果应用async/await时的写法如下： 12345678910// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; 总结部分参考：Vuex官方文档，链接：https://vuex.vuejs.org/zh/guide/actions.html","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yixirumeng.github.io/tags/vuex/"}]},{"title":"Vuex源码分析四 ———— mapGetters","date":"2019-01-17T15:10:22.000Z","path":"2019/01/17/vuex-source-code-mapGetters/","text":"上一篇分析了获取Vuex中的state的Api————mapState，这一篇继续分析获取getters的Api————mapGetters，它其实与mapState类似，下面看一下源码。 mapGettersmapGetters的方法相较于mapState简单一些，因为调用了normalizeMap方法，所以也可以传入数组或对象，而下面定义的方法内部，最终应用this.$store.getters来获取最终需要的getter。 12345678910111213141516171819const mapGetters = normalizeNamespace((namespace, getters) =&gt; &#123; const res = &#123;&#125; normalizeMap(getters).forEach((&#123; key, val &#125;) =&gt; &#123; val = namespace + val res[key] = function mappedGetter () &#123; if (namespace &amp;&amp; !getModuleByNamespace(this.$store, 'mapGetters', namespace)) &#123; return &#125; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(val in this.$store.getters)) &#123; console.error(`[vuex] unknown getter: $&#123;val&#125;`) return &#125; return this.$store.getters[val] &#125; // mark vuex getter for devtools res[key].vuex = true &#125;) return res&#125;) mapGetters在Vue组件中的应用123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapGetters &#125; from 'vuex' export default &#123; computed: &#123; ...mapGetters(['num']) &#125;, mounted()&#123; console.log(this.num) &#125; &#125;&lt;/script&gt; 它的使用方式与mapState类似，这里就不做详细的分析了。 总结mapGetters的内部原理其实同样调用了this.$store.getters来获取最终需要的getter。平时开发中，还是主要应用mapGetters来获取状态，因为有些时候，需要合并多个state才能得到想要的数据，可能暂时用不到，但随着业务的增加，不可避免会用到，所以还是统一使用mapGetters更加方便。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yixirumeng.github.io/tags/vuex/"}]},{"title":"Vuex源码分析三 ———— mapState","date":"2019-01-14T01:31:29.000Z","path":"2019/01/14/vuex-source-code-mapState/","text":"之前的两篇文章介绍了Vuex的内部过程以及实现原理，其暴露出来的方法基本上能满足日常的开发使用，但是如果都按着this.$store的这种写法，会很复杂。而Vuex也提供了很多简便操作的Api，下面的这几篇文章就分别分析一下每个Api的源码，并结合实例说明一下。 这篇先介绍第一个Api————mapState，它主要是为了方便我们操作state而应用的。在分析源码之前，先要看几个公共方法，了解它们对分析这几个Api很重要（之后的几个Api都会用到这几个方法，如果忘了可以回头来看看）。 normalizeNamespacenormalizeNamespace函数其实是个高阶函数，它以函数fn作为参数，然后返回一个函数，然后对返回的这个函数进行参数校验，如果第一个参数不是string类型，则将其设置为第二个参数map的值，本身成为空的字符串。如果是string类型，则进行一下拼接处理之后再使用。 1234567891011function normalizeNamespace (fn) &#123; return (namespace, map) =&gt; &#123; if (typeof namespace !== 'string') &#123; map = namespace namespace = '' &#125; else if (namespace.charAt(namespace.length - 1) !== '/') &#123; namespace += '/' &#125; return fn(namespace, map) &#125;&#125; normalizeMapnormalizeMap方法对传入的参数进行校验，如果是数组，则遍历这个数组，并将其每个元素处理为对象的形式；如果为Object，也会遍历，并组合成一个对象数组进行返回。 12345function normalizeMap (map) &#123; return Array.isArray(map) ? map.map(key =&gt; (&#123; key, val: key &#125;)) : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))&#125; getModuleByNamespacegetModuleByNamespace方法主要就是对命名空间进行一下校验，可以暂时不用太过考虑这个方法 1234567function getModuleByNamespace (store, helper, namespace) &#123; const module = store._modulesNamespaceMap[namespace] if (process.env.NODE_ENV !== 'production' &amp;&amp; !module) &#123; console.error(`[vuex] module namespace not found in $&#123;helper&#125;(): $&#123;namespace&#125;`) &#125; return module&#125; 上面这几个方法都是辅助函数，在Api中都会用到，不明白的时候可以翻上去看一下。 mapState还记得上面的normalizeNamespace方法吗，它的参数是一个函数，也就是下面定义的这个函数，而平时我们在使用mapState的时候，传入的参数正是传入到normalizeNamespace返回的方法中。如果不考虑命名空间的话，normalizeNamespace返回的方法最终将处理完的参数传入到下面定义的这个函数中。 1234567891011121314151617181920212223242526272829303132/* 所以，下面的namespace和states分别为空字符串和我们传入的参数*/const mapState = normalizeNamespace((namespace, states) =&gt; &#123; const res = &#123;&#125; /* 这里调用了一下normalizeMap方法，经过上面分析 它会对参数进行判断，然后转换成对象数组 接下来进行遍历，然后再判断参数是否为函数 并进行最终的返回 */ normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedState () &#123; let state = this.$store.state let getters = this.$store.getters if (namespace) &#123; const module = getModuleByNamespace(this.$store, 'mapState', namespace) if (!module) &#123; return &#125; state = module.context.state getters = module.context.getters &#125; return typeof val === 'function' ? val.call(this, state, getters) : state[val] &#125; res[key].vuex = true &#125;) // mark vuex getter for devtools return res&#125;) 根据上面的分析，在调用mapState时，可以传入数组或者是对象，因为内部会做处理，最终根据不同类型来导出不同的结果。而最终还是应用this.$store去获取对应的值。 mapState在Vue组件中的应用还是使用上一篇定义的Vuex 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapState &#125; from 'vuex' export default &#123; computed: &#123; ...mapState(['num']) &#125;, mounted()&#123; console.log(this.num) &#125; &#125;&lt;/script&gt; 经过上面源码的分析可知，这里传入的参数是个数组，所以经过normalizeMap转换后得到的对象是[{key: &#39;num&#39;, val: &#39;num&#39;}]，遍历后进行判断，因为val不是function，所以直接调用this.$store.state.num，最终返回的是一个对象{num: 1}。上面的computed中应用了...结构，最终会把num放入到computed中。 在应用mapState的时候，也可以传入对象，即mapState({num: &#39;num&#39;})，如果想给参数换个名字可以是mapState({ber: &#39;num&#39;})，这样调用this.ber就可以获取到num的值。 总结mapState方法主要为了方便我们在开发的时候进行操作，不用每次获取变量都要写this.$store.state，它可以接收数组或者对象作为参数，但观察其内部，依然是通过this.$store.state来操作，毕竟不能脱离定义的Store。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yixirumeng.github.io/tags/vuex/"}]},{"title":"Vuex源码分析二 ———— 结合实例分析Store","date":"2019-01-11T12:17:03.000Z","path":"2019/01/11/vuex-source-code-example/","text":"上一篇详细分析了Store的源码以及其实例化的具体过程，这一篇结合具体例子来分析，进一步了解Vuex的具体过程 Vuex先写一个整体的Vuex，下面的Vue组件都会用到 store.js 123456789101112131415161718192021222324import Vue from 'vue'import Vuex from 'vuex'import state from './state'import getters from './getters'import actions from './actions'import mutations from './mutations'Vue.use(Vuex)/* 经过源码分析可知，实例化Store会对下面传入的属性 进行处理，将state、getters挂载到组件上，而actions 和mutations内定义的方法会存入对应的数组中，当调用 dispatch时会去actions数组中找到对应的处理函数， 而commit会去mutations中找到对应的处理函数*/const store = new Vuex.Store(&#123; state, getters, actions, mutations&#125;)export default store state.js 1234567891011121314/* 这里state也可以定义为function 源码中可以知道，会判断是否为函数， 如果为函数会默认执行*/const state = &#123; num: 1&#125;orconst state = () =&gt; (&#123;num: 1&#125;)export default state getters.js 123456789101112/* 根据源码可以知道，getters中的每个getter都可以接收四个参数 因为没定义命名空间，所以state和rootState一样，而getters 和rootGetters一样*/const getters = &#123; num: (state, getters, rootState, rootGetters) =&gt; &#123; return state.num &#125;&#125;export default getters actions.js 1234567891011121314151617181920/* 根据源码可知，每个action都会接收到一个有六个属性的对象参数 可以分别进行操作，所以action可以commit一个或多个mutation 也可以dispatch其它action，当然也可以处理state、getters 但是只能在mutation中进行更改 这里的payload则是传入到action中的数据*/const actions = &#123; increment: (&#123; dispatch, commit, getters, state, rootGetters, rootState&#125;, payload) =&gt; &#123; commit('INCREMENT') &#125;&#125;export default actions mutations.js 1234567891011/* 源码分析后可知，每个mutation都会接收两个参数 即state和要传入的数据*/const mutations = &#123; ['INCREMENT']: (state, payload) =&gt; &#123; state.num ++ &#125;&#125;export default mutations Vue组件1根据分析，实例化Store会将state、getters挂载到组件实例上，所以下面this.$store.state.num会调用Store的get方法访问到state，而this.$store.getters.num会直接拿到对应的getter 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; $store.state.num &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; $store.getters.num &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted()&#123; console.log(this.$store.state.num) console.log(this.$store.getters.num) &#125; &#125;&lt;/script&gt; Vue组件21234567891011121314151617181920/* 这里因为是同步操作，可以直接commit mutation 要更改state，只能调用mutation中的方法*/&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; $store.state.num &#125;&#125;&lt;/div&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; increment()&#123; this.$store.commit('INCREMENT') &#125; &#125; &#125;&lt;/script&gt; Vue组件31234567891011121314151617181920/* 也可以先派发action，然后由action去commit mutation 当有异步操作的时候，只能通过action去commit mutation*/&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; $store.state.num &#125;&#125;&lt;/div&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; increment()&#123; this.$store.dispatch('increment') &#125; &#125; &#125;&lt;/script&gt; 当需要传递参数的时候，其写法是this.$store.dispatch(&#39;increment&#39;, 3)以及this.$store.commit(&#39;INCREMENT&#39;, 3)，这样就可以在action和mutation中拿到传来的数据了 总结根据源码分析，又结合实际例子，可以很清晰的了解Vuex整个过程，以及每一步为什么要如此操作，其为什么会有这些参数。 之前分析过Redux，对比可以发现，Vue的action与Redux的action类似，而mutation则与reducer类似，所以副作用的操作都要放在action中，只有mutation、reducer是改变state的唯一途径。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yixirumeng.github.io/tags/vuex/"}]},{"title":"Vuex源码分析一 ———— 初始化Store","date":"2019-01-05T11:23:46.000Z","path":"2019/01/05/vuex-source-code-Store/","text":"前面的文章分析了Redux的源码和Api，作为前端三大框架的Vue当然也少不了状态管理工具——Vuex，下面的几篇文章就来对Vuex及其常用Api进行一下源码分析 Store在平时开发使用vuex的时候，都会实例化一个Store，即new Vuex.Store，里面传入state、getters、actions，mutations等相关属性，正是在这个过程中，vuex会初始化Store，下面就来看一下Store这个类的源码（部分代码已删减，只保留核心功能），遇到调用的某个方法，请到下面查看对应的源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114class Store &#123; constructor (options = &#123;&#125;) &#123; /* 这里的options就是传入的state、action等对象参数 首先从中获取state，其可以为普通对象，也可以为一个函数 如果是函数，则执行这个函数 */ let &#123; state = &#123;&#125; &#125; = options if (typeof state === 'function') &#123; state = state() || &#123;&#125; &#125; /* 初始化一些属性，之所以用Object.create(null)不用&#123;&#125; 是为了防止对象获取原型上的属性 */ this._committing = false //是否是正在commit状态 this._actions = Object.create(null) this._mutations = Object.create(null) this._wrappedGetters = Object.create(null) /* ModuleCollection函数是来收集参数中的modules，也就是 getters、actions、mutations等属性，具体可以看下面源码分析 */ this._modules = new ModuleCollection(options) /* 这一步的操作是改写dispatch、commit函数，开发时用到的方法 正是在这里转换后的方法 */ const store = this const &#123; dispatch, commit &#125; = this this.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload) &#125; this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options) &#125; /* 这里来加载上面获取到属性，可以查看下面installModule方法源码 */ installModule(this, state, [], this._modules.root) /* 这里重新设置store */ resetStoreVM(this, state) &#125; /* get方法用来获取定义的state，也就是在开发时用到的 this.$store.state...就是执行的这个方法 */ get state () &#123; return this._vm._data.$$state &#125; /* commit方法就是action要通知mutation时调用的方法 其中unifyObjectStyle就是将type、payload、options 等属性扁平化，使其成为一个plainObject 最后在mutations中找到对应type的mutation，并将payload 传入执行这个mutation */ commit (_type, _payload, _options) &#123; const &#123; type, payload, options &#125; = unifyObjectStyle(_type, _payload, _options) const mutation = &#123; type, payload &#125; const entry = this._mutations[type] this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator (handler) &#123; handler(payload) &#125;) &#125;) &#125; /* dispatch是在派发一个action时执行的方法 其原理跟commit方法基本类似，但是有个注意点，dispatch 派发的可以不是一个action，可以是个数组，如果是数组 则会遍历每一项，然后分别处理 */ dispatch (_type, _payload) &#123; const &#123; type, payload &#125; = unifyObjectStyle(_type, _payload) const action = &#123; type, payload &#125; const entry = this._actions[type] return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload) &#125; /* withCommit方法其实就是为了设置commit状态，起到一个开关作用 */ _withCommit (fn) &#123; const committing = this._committing this._committing = true fn() this._committing = committing &#125;&#125; Store类还是很简单的，其内部主要是做一些初始化的操作。下面来看看主要的函数源码： ModuleCollection12345678910111213141516171819202122232425262728293031323334353637/* ModuleCollection类主要用来收集传入的属性 在构造函数中调用register方法，根据上面的源码 其中的rawRootModule就是options也就是传入的参数*/class ModuleCollection &#123; constructor (rawRootModule) &#123; this.register([], rawRootModule, false) &#125; get (path) &#123; return path.reduce((module, key) =&gt; &#123; return module.getChild(key) &#125;, this.root) &#125; getNamespace (path) &#123; let module = this.root return path.reduce((namespace, key) =&gt; &#123; module = module.getChild(key) return namespace + (module.namespaced ? key + '/' : '') &#125;, '') &#125; update (rawRootModule) &#123; update([], this.root, rawRootModule) &#125; /* register方法里实例化一个Module并将options传入 同时设置一个属性，名为root执行实例化后的实例 */ register (path, rawModule, runtime = true) &#123; const newModule = new Module(rawModule, runtime) this.root = newModule &#125;&#125; Module123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* Module类主要用来获取到options找那个的每个属性，并做处理*/class Module &#123; constructor (rawModule, runtime) &#123; this.runtime = runtime this._children = Object.create(null) this._rawModule = rawModule const rawState = rawModule.state this.state = (typeof rawState === 'function' ? rawState() : rawState) || &#123;&#125; &#125; get namespaced () &#123; return !!this._rawModule.namespaced &#125; addChild (key, module) &#123; this._children[key] = module &#125; removeChild (key) &#123; delete this._children[key] &#125; getChild (key) &#123; return this._children[key] &#125; update (rawModule) &#123; this._rawModule.namespaced = rawModule.namespaced if (rawModule.actions) &#123; this._rawModule.actions = rawModule.actions &#125; if (rawModule.mutations) &#123; this._rawModule.mutations = rawModule.mutations &#125; if (rawModule.getters) &#123; this._rawModule.getters = rawModule.getters &#125; &#125; forEachChild (fn) &#123; forEachValue(this._children, fn) &#125; forEachGetter (fn) &#123; if (this._rawModule.getters) &#123; forEachValue(this._rawModule.getters, fn) &#125; &#125; forEachAction (fn) &#123; if (this._rawModule.actions) &#123; forEachValue(this._rawModule.actions, fn) &#125; &#125; forEachMutation (fn) &#123; if (this._rawModule.mutations) &#123; forEachValue(this._rawModule.mutations, fn) &#125; &#125;&#125; forEachValue1234567/* forEachValue方法主要用来遍历对象，然后将对象的value、key作为参数 传入到函数参数中*/function forEachValue (obj, fn) &#123; Object.keys(obj).forEach(key =&gt; fn(obj[key], key))&#125; installModule12345678910111213141516171819202122232425262728293031323334353637383940/* installModule方法主要用来安装传入的属性 根据上面源码调用该方法的地方，传入的参数为 installModule(this, state, [], this._modules.root) 这里的this._modules.root正是在ModuleCollection中register方法中 定义的，其值为Module实例*/function installModule (store, rootState, path, module, hot) &#123; /* 这里先调用makeLocalContext方法获取到local值，主要是根据命名空间来获取 除非较大的项目，平时较少用到命名空间，所以可以将local值看成就是store 这里的namespace可以视为空字符串 */ const local = module.context = makeLocalContext(store, namespace, path) /* 然后分别注册mutation、action、getter 而forEachMutation、forEachAction、forEachGetter方法正是在module实例中 定义的方法，而根据上面的分析，这里调用的registerMutation、registerAction、 forEachGetter三个方法中传入的mutation、action、getter参数，正是在开发中 定义的三个属性中对应的方法，也就是实际写的getters、actions、mutations中的 每个方法 */ module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;) module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) &#125;) module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) &#125;)&#125; makeLocalContext123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* makeLocalContext方法对store中的命名空间做了一层处理，如果设置了命名空间 则会进一步向下获取，平时较少用到命名空间，所以可以把这步操作看成就是原始的store*/function makeLocalContext (store, namespace, path) &#123; const noNamespace = namespace === '' const local = &#123; dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) &#123; console.error(`[vuex] unknown local action type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; return store.dispatch(type, payload) &#125;, commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) &#123; console.error(`[vuex] unknown local mutation type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; store.commit(type, payload, options) &#125; &#125; Object.defineProperties(local, &#123; getters: &#123; get: noNamespace ? () =&gt; store.getters : () =&gt; makeLocalGetters(store, namespace) &#125;, state: &#123; get: () =&gt; getNestedState(store.state, path) &#125; &#125;) return local&#125; registerMutation、registerAction、registerGetter这三个方法是初始化的核心方法，是来处理我们自定义的三个队属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* registerMutation方法会在初始化属性_mutations中定义一个对应type的mutations 其初始为一个空数组，并把我们自定义的mutation转换成一个函数push到这个数组中*/function registerMutation (store, type, handler, local) &#123; const entry = store._mutations[type] || (store._mutations[type] = []) entry.push(function wrappedMutationHandler (payload) &#123; /* 调用每个mutation传入了参数local.state、payload 这样就是我们在写mutation时，可以在方法参数中获取到state，以及要传过来 的数据 */ handler.call(store, local.state, payload) &#125;)&#125;/* registerMutation方法会在初始化属性_actions中定义一个对应type的actions 其初始为一个空数组，并把我们自定义的action转换成一个函数push到这个数组中 这里做了一个isPromise校验，这样也就使得我们在定义异步操作时，要放在action中*/function registerAction (store, type, handler, local) &#123; const entry = store._actions[type] || (store._actions[type] = []) entry.push(function wrappedActionHandler (payload, cb) &#123; /* 调用每个action时，传入了local.dispatch、local.commit、 local.getters、local.state、store.getters、store.state， 并重新进行命名这也就是我们在写action时，可以获取到对应的属性， 如果没有定义命名空间，则local.getters和store.getters一样， local.state和store.state一样 */ let res = handler.call(store, &#123; dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state &#125;, payload, cb) if (!isPromise(res)) &#123; res = Promise.resolve(res) &#125; return res &#125;)&#125;/* registerGetter方法会根据对应的type找到getter，其值为一个方法， 最后调用rawGetter方法，也就是我们自定义的getter*/function registerGetter (store, type, rawGetter, local) &#123; store._wrappedGetters[type] = function wrappedGetter (store) &#123; /* 这里传入了local.state、local.getters、store.state、 store.getters四个参数，如果没有定义命名空间， 则local.getters和store.getters一样， local.state和store.state一样 这里注意一下，上面是传入一个对象，而这里是作为单独参数 分别传入 */ return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) &#125;&#125; resetStoreVMresetStoreVM方法其实很简单，主要是将state、getters挂载到vue实例上，并且将旧的vm卸载，使用新的vm 12345678910111213141516171819202122232425262728293031323334function resetStoreVM (store, state, hot) &#123; const oldVm = store._vm store.getters = &#123;&#125; const wrappedGetters = store._wrappedGetters const computed = &#123;&#125; forEachValue(wrappedGetters, (fn, key) =&gt; &#123; computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true &#125;) &#125;) /* 这一步的操作可以知道，我们在开发的过程中，即使没在 computed中定义getter，也可以用this.$store.getter 获取到自定义的getter */ store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed &#125;) if (oldVm) &#123; if (hot) &#123; store._withCommit(() =&gt; &#123; oldVm._data.$$state = null &#125;) &#125; Vue.nextTick(() =&gt; oldVm.$destroy()) &#125;&#125; 总结经过上面整体的源码分析，可以看出Vuex的内部逻辑并没有特别复杂，它会将我们自定义的state、getters、actions、mutations分别进行的处理，然后放入到Store中，而每次要做出相应的变化，都要调用dispatch、commit方法。 下一篇会结合具体实例来进一步分析一下。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yixirumeng.github.io/tags/vuex/"}]},{"title":"2018年个人总结","date":"2018-12-31T11:13:27.000Z","path":"2018/12/31/2018-summary/","text":"2018年的最后一天，对这一年的经历和收获做一下总结，为2018画上完美的句号。 2018这一年经历了很多事情，分成几个类别说说一下吧。在冷嘲中成长在之前公司的研发团队里，90%的同事都是java工程师，其中也包括领导，而我则是一名web前端工程师，这也就导致了前端这个职位并不会受到更多的重视，因为做java肯定也会写html、js，就算不会用vue、react等主流框架，jquery也一定会用，而css也有现成的UI框架，拿过来直接可以用，这难免会认为前端的工作很简单，而且也是可替代的，前端更多时候是去调一些不太好弄的样式。虽然项目都是前后端分离是开发，前端的工作已经复杂了很多，后台得到工作变得稍微轻松一些，但即使这样，前端依然没有“地位”。 做过前端开发的同学应该都知道，其实前端的工作真的不简单，并不是拿一些UI框架拼拼凑凑，用jqeury写一些ajax这么简单，需要用到的知识也很多、很复杂。 刚开始自己心里也很难受，但慢慢的明白了，难受并不能解决实际问题，让自己强大起来才会不被冷嘲，当某一天不管前端、后台、运维等等的知识都能拿起来，分配什么工作都能做，哪一方面都不是外行，不用去刻意表现什么，自然就会有人来找你。 说下来，我还要感谢之前的领导，让我成长了很多，让我真正感受到了职场的冷暖，也让我找到了应该努力的方向，只有不断学习、不断实践才能够提升自己、丰富自己，让自己强大。 2018学习到知识2018这一年，学习了很多知识，不管在工作中，还是平时，都让自己感觉很充实，以下简单总结一下： 1、深入学习了vue、react两个主流框架，尤其是react，因为目前的工作正在使用，并跟随主流学习了新的特性，将其应用到实际问题中。 2、深入学习了redux状态管理工具，以及相关的reselect、redux-thunk、redux-actions、redux-saga、redux-promise等中间件。 3、阅读并分析了redux、redux-thunk、reselect、redux-actions、fastclick的源码，并写了相应的博客（翻看之前的文章就能查阅），同时也阅读vue、react、react-router4的部分源码，因为框架本身也是很庞大的，所以还需要再进一步学习和分析。 4、巩固了很多基础知识，通过实际工作以及学习，明白了框架再多、新的东西再丰富都离不开基础，这往往也是最容易被忽视的，所以打好基础是重中之重。 5、学习了如前端缓存、代码优化、性能优化等等前端相关的知识。 6、学习了新的一门语言java，因为身边的后端都是java开发，再加上自己也很有兴趣，所以在学习前端的同时，也学习了java基础、springmvc、springboot、mybatis、sql、redis、mysql等java相关的知识，并用学到的知识做了项目。这里要非常感谢自己身边的同事，每次遇到问题都不厌其烦的教我，非常感谢！ 7、学习了简单的运维知识，nginx部署、nginx配置、tomcat部署、部分linux，同时了解了redis集群、分布式等知识。 其实还有很多没有列举，但总之这一年的收获还是很丰富的。 面试也是一种提升2018这一年，经历了10余次面试，每次面试可能还会有二面、三面。碰到的面试官都很优秀，也问到了很多我不是很了解的问题，让我知道了自身不足的地方，以及应该加强学习的地方。虽然最终因为各种原因没有在一起工作（只能选择一家公司嘛），但我还是要感谢这些面试官，让我发现不足，多多学习，进一步提升自己。 工作在这一年中，共接手了两个大的项目（其实还有一些小的项目），第一个项目是用vue做的，第二个项目是用react做的，总体来说完成的可以，没有出现重大的问题，有一些小的bug是正常的，因为程序是不能0bug的。在这两个项目中，经历过很多问题，最终通过查阅资料、实践、交流都解决了，也已经上线到生产环境了。 工作中出现问题是难免的，不可能是一帆风顺的，当想办法解决这些问题的时候，也正是提升自己的时候，这也就是俗话说的，“提升自身往往是在不断填坑”。 整体总结整体下来，2018对我来说是个收获之年，学习了很多很多知识、实践了很多项目、解决了很多问题，我觉得对我来说最大的收获是：不论到任何时候都要学习，不学习就是在让社会淘汰自己。在马上要到来的2019年，我还是会坚持自己的目标，不断学习、不断实践，让自己进步。 2019目标对于2019年的目标，目前分为以下几方面： 1、继续巩固基础知识，阅读红宝石、犀牛书、es6等基础相关的书籍。 2、进一步深入学习vue、react等框架，并阅读其源码，理解内部原理、思想。 3、阅读在工作中常用工具的源码，明白底层实现原理，使得在应用中更加得心应手。 4、进一步学习小程序、react-native、flutter等知识，并做出相关的项目，学习与实践相配合。 5、深入学习java、springboot、springcloud、redis、数据库，并写出与web、小程序、app交互的后台，并学习分布式、微服务、集群、高可用、高并发等知识。 6、学习运维相关知识，linux、nginx、redis、docker、kubernetes、ELK、集群等知识 7、跟随主流，学习最新最前沿的技术。 8、与身边的人多交流、多沟通，相互分享，相互提升。 9、其实也是最最重要的一条，多散步锻炼，学习游泳，有一个好的身体才能写出好的程序，在学习的同时，也要学会休息，放松自己。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"2018summary","slug":"2018summary","permalink":"http://yixirumeng.github.io/tags/2018summary/"}]},{"title":"ES5、ES6分别实现继承，以及说明两者的区别（Javascript知识点总结二）","date":"2018-12-26T11:23:18.000Z","path":"2018/12/26/es5-and-es6-extends/","text":"ES5和ES6都可以实现继承，但是两者实现的方式是不一样的，下面分别用代码实现一下，并说明它们的区别 ES5实现继承的方式有多种，但是每种的含义都不一样一、原型链实现继承123456789101112131415function Parent(name)&#123; this.showAge = function()&#123; console.log(this.age) &#125;&#125;function Child(age)&#123; this.age = age&#125;Child.prototype = new Parent()var child = new Child(18)child.showAge() // 18 实现原理：子类的原型对象指向父类的实例来实现继承，也就是重写子类的原型，但这种方式无法实现多继承 二、call/apply方法改变函数上下文实现继承12345678910111213141516171819202122function Parent(name)&#123; this.name = name this.age = 18 this.showAge = function()&#123; console.log(this.age) &#125;&#125;function Child(name)&#123; Parent.call(this, name) //Parent.apply(this, name) this.showCurrentAge = function()&#123; console.log(this.name) this.showAge() &#125;&#125;var child = new Child('Queen')child.showCurrentAge() // Queen 18console.log(child.constructor === Child) //true 实现原理：改变函数内部的函数上下文this，使它指向传入函数的具体对象，其实就是将父类的this指向子类。但这种方式不能继承父类的原型链 三、结合以上两种方式，共同实现继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function Parent()&#123; this.showName = function()&#123; console.log(this.name) &#125;&#125;Parent.prototype.showSex = function()&#123; console.log('man')&#125;function Child(name)&#123; this.name = name this.age = 18 Parent.call(this) this.showInfo = function()&#123; console.log(this.age) this.showName() &#125;&#125;Child.prototype = new Parent()var child = new Child('Queen')child.showInfo() //18 Queenchild.showSex() //man-------------------------------------------------------function Parent(name)&#123; this.name = name&#125;Parent.prototype.showName = function()&#123; console.log(this.name)&#125;function Child(name, age)&#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()Child.prototype.showAge = function()&#123; console.log(this.age)&#125;var child = new Child('Queen', 18)child.showName() //Queenchild.showAge() //18 实现原理：这种方式是结合了以上两种的原理共同实现的，既可以实现多继承，也可以继承父类的原型链 ES6实现继承ES6实现继承的方式很简单，其定义了extends关键字，可以方便实现继承 12345678910111213141516171819202122232425class Parent &#123; constructor(name)&#123; this.name = name &#125; showName()&#123; console.log(this.name) &#125;&#125;class Child extends Parent &#123; constructor(name, age)&#123; super(name) this.age = age &#125; showAge()&#123; console.log(this.age) &#125;&#125;const child = new Child('Queen', 18)child.showName() //Queenchild.showAge() //18 两者的区别两者实现继承的方式和内部的原理是不一样的，引用阮大大的话：ES5实现继承是先创造子类的实例对象this，然后再将父类的方法添加到this上（Parent.call(this)）。ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上，所以必须调用super方法，然后子类的构造函数修改this。 这里有几点需要注意： 1、如果子类继承父类，但内部不写构造函数的话，构造函数是会被默认添加的，即： 12345678910class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 2、如果在子类中写了构造函数，则必须先调用super之后，才可以使用this，否则会报错。这是因为子类实例的构建，是基于父类实例，只有super方法才能调用到父类的实例，即： 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 3、父类的静态方法，也会被子类继承，即： 1234567891011class A &#123; static hello() &#123; console.log('hello world'); &#125;&#125;class B extends A &#123;&#125;B.hello() // hello world 参考文章：http://es6.ruanyifeng.com/#docs/class-extends","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://yixirumeng.github.io/tags/javascript/"}]},{"title":"Javascript知识点总结一（持续更新...）","date":"2018-12-20T13:33:58.000Z","path":"2018/12/20/javascript-summary-of-knowledge-summary1/","text":"从这篇文章开始，将对js的知识点进行总结，主要是在日常开发与学习中遇到的知识，会对其进行解释说明，每篇包含几个知识点，如果知识点复杂会单独列出一篇。此类文章将不断更新。（因js过于强大，且每个人在开发时都会遇到各种各样的问题，这里写的更多是自己遇到过的，所以此类文章主要作为自己学习后的知识总结。） 一、以变量作为对象的key，其内部实现原理以前在开发时，如果对象的key为变量，一般的写法为obj[variable]，es6之后可以直接在对象中用[]将变量包起来，即{ [variable]: &#39;hello&#39; }，这两种写法，其实是调用了variable的toString方法，将其转换为字符串后放入。所以，不管是基本类型还是引用类型，都是一样的。看几个例子： 1234567891011121314151617const arr = [1, 2, 3]const obj = &#123; [arr]: 'hello number'&#125;console.log(obj)这里得到的obj为：&#123; 1,2,3: 'hello number' &#125;------------------------------------------------const obj1 = &#123; a: 3 &#125;const obj2 = &#123; [obj1]: 'hello object'&#125;console.log(obj2)这里得到的obj2为：&#123; [object,Object]: 'hello object' &#125; 这里分别调用了数组和对象的toString方法来进行转换。 二、原生JS实现数组的map方法数组的map方法包含接收两个参数，第一个为函数，其参数分别为当前项、当前项索引、当前项所属的数组，第二个为this的指向，一般不用传递。 123456789Array.prototype.map1 = function(callback, context)&#123; const arr = this let newArr = [] for(let i=0; i&lt;arr.length; i++)&#123; let newValue = callback.call(context, arr[i], i, arr) newArr.push(newValue) &#125; return newArr&#125; 例子： 1234const arr = [4, 5, 6, 7]const newArr = arr.map1((item, index) =&gt; item + 1)console.log(arr) //[4, 5, 6, 7]console.log(newArr) //[5, 6, 7, 8] 三、reduce实现数组map方法12345678Array.prototype.map2 = function(callback, context)&#123; const arr = this const newArr = arr.reduce((total, currentValue, currentIndex) =&gt; &#123; let newValue = callback.call(context, currentValue, currentIndex, arr) return total.concat(newValue) &#125;) return newArr&#125; 例子跟上面一样的，这里都没做参数类型判断，基本原理都写出来了 四、js的new操作符都做了什么12function Func()&#123;&#125;const func = new Func() new操作符会做以下几件事情： 1、创建一个空对象，即：let obj = new Object() 2、将obj的__proto__指向Func的prototype，即：obj.__proto__ = Func.prototype 3、让Func的this指向obj，并执行Func的函数体，即：const result = Func.call(obj) 4、判断result的类型，如果是基本类型，就返回obj，如果是引用类型，就返回result，即： 12345if(typeof result === 'object')&#123; func = result&#125;else&#123; func = obj&#125; 这里有个注意点，如果result的类型是基本类型，那func的构造函数指向Func，但如果是引用类型，func的构造函数指向对应的引用类型函数，举例说明一下： 1234567891011121314151617181920212223function Func1(a, b)&#123; this.a = a this.b = b&#125;const func1 = new Func1(1, 2)则：func1.constructor === Func1-------------------------------------function Func2(a, b)&#123; this.a = a this.b = b return &#123; a, b &#125;&#125;const func2 = new Func2(1, 2)则：func2.constructor === Object 一般构造函数不写返回值，则默认的返回值为undefined，为基本类型。 五、js事件流事件流描述的是从页面中接收事件的顺序，事件流包括下面几个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 addEventListener是指定事件处理程序的操作，这个方法接收3个参数： 1、要处理的事件名2、作为事件处理程序的函数3、一个布尔值。如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。默认值为false 如果不想要事件冒泡，可以对冒泡阻止，IE与非IE阻止冒泡的写法不一样，所以需要判断： 12345678const btn = document.getElementById('btn')btn.addEventListener('click', function(e)&#123; if(e &amp;&amp; e.stopPropagation)&#123; e.stopProgapation() &#125;else&#123; window.event.cancelBubble = true &#125;&#125;, false)","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://yixirumeng.github.io/tags/javascript/"}]},{"title":"reselect源码分析二 ———— createStructuredSelector","date":"2018-12-15T15:02:46.000Z","path":"2018/12/15/reselect-source-code-analysis-createStructuredSelector/","text":"reselect除了上一篇文章介绍的两个常用Api，它还提供了一个Api————createStructuredSelector，这个Api可以将结果直接生产Object的形式，这样可以简化mapStateToProps内的代码，更方便操作。那现在就分析一下它的源码，并看一下实际例子。 createStructuredSelector12345678910111213141516171819202122232425262728293031323334/* createStructuredSelector接收两个参数 selectors：即要定义的所有selector的集合 selectorCreator：要创建selector的方法，默认为createSelector*/export function createStructuredSelector(selectors, selectorCreator = createSelector) &#123; /* 先判断传入的selectors是否为object，如果不是会抛错 */ if (typeof selectors !== 'object') &#123; throw new Error( 'createStructuredSelector expects first argument to be an object ' + `where each property is a selector, instead received a $&#123;typeof selectors&#125;` ) &#125; /* 先获取到selectors中所有的key得到objectKeys 然后调用selectorCreator也就是createSelector方法， 遍历objectKeys获取到每个key对应的value，生成新的value数组 用rest参数的方式传入生成值的函数中，采用数组的reduce方法 逐步生成每个key对应的处理后的值，最终就可以得到的就是一个Object */ const objectKeys = Object.keys(selectors) return selectorCreator( objectKeys.map(key =&gt; selectors[key]), (...values) =&gt; &#123; return values.reduce((composition, value, index) =&gt; &#123; composition[objectKeys[index]] = value return composition &#125;, &#123;&#125;) &#125; )&#125; createStructureSelector实例123456789101112//selectorconst getNum = state =&gt; state.numconst getNumA = state =&gt; state.numAconst getNumB = state =&gt; state.numBconst numSelector = createStructureSelector(&#123; num: getNum, numA: getNumA, numB: getNumB&#125;)//mapStateToPropsconst mapStateToProps = state =&gt; numSelector(state) 这是createStructureSelector应用比较简单的例子，根据上面的分析，其实就是对每一个key对应的value调用一下createSelector方法，然后再应用数组的reduce方法组合成一个执行完之后的Object返回，以前需要把值都写在mapStateToProps中，现在在createStructureSelector中写就可以，提升性能的同时简化操作。 总结应用了两篇文章详细分析了reselect的源码，并结合相应的例子做了过程分析，整体看下来，reselect提高性能的方法主要是应用了闭包，将变量保存下来，下次还能再使用，然后再进行比较，以此减少更新时不必要的操作。其核心的方法是defaultMemoize，理解好它是关键，而其它的Api都是createSelectorCreator演变而来的，所以这两个方法是reselect的主要内容。 整体总结总结一下阅读完reselect之后的收获： 1、灵活运用闭包，在合适的地方应用可以起到很重要的作用，但不可过度使用，闭包保存的变量会常驻内存，如果不能有效的清理，会造成内存泄漏。 2、应用好数组、对象的每个Api方法，如every，reduce，Object.keys，map等等，每一个方法在不同的操作时，都要合理运用，尤其是reduce，在之前分析的源码中，很多地方大量应用了这个方法，最直接的就是compose，它还用很多用法值得去实践。 3、call、apply、bind三个js中非常重要的方法，主要是改变this的执行，而每一个跟另外两个又有区别。 4、在上一次分析redux-actions源码的总结中也说了，数组的部分方法会改变原始数组，如pop、push、shift、unshift等，还要知道调用这些方法后的返回值。 以上大体总结了阅读后的理解，其实还有很多学到的地方，像高阶函数、for循环、arguments等等的。所以，读源码不止能理解框架的原理，还可以读懂设计思想，更可以巩固基础知识。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"reselect","slug":"reselect","permalink":"http://yixirumeng.github.io/tags/reselect/"}]},{"title":"reselect源码分析一 ———— createSelector、createSelectorCreator","date":"2018-12-08T14:17:47.000Z","path":"2018/12/08/reselect-source-code-analysis-createSelector、createSelectorCreator/","text":"在平时开发的过程中，会应用react-redux这个中间件，但是每次更新时，不管redux中的state是否变化，都会重新更新mapStateToProps里面的值，这会造成大量冗余的操作。reselect作为redux性能优化的中间件已经在广泛使用，只有当redux中的state发生变化时，才会更新mapStateToProps中的值。下面来对其源码进行一下分析，看一下其内部是如何做到这方面性能优化的。 reselect常用的Api是createSelector，那就先来看一下它的源码： createSelector1export const createSelector = createSelectorCreator(defaultMemoize) createSelector的源码就这一行，它调用了createSelectorCreator方法并传入defaultMemoize作为参数。而createSelectorCreator也是relect的一个Api，所以createSelector是根据createSelectorCreator来的，那接下来就看一下defaultMemoize、createSelectorCreator的源码。 在看源码之前，需要先看两个工具函数，它们起着很重要的作用： 123function defaultEqualityCheck(a, b) &#123; return a === b&#125; 这个函数很简单，就是对两个参数进行强比较。 1234567891011121314function areArgumentsShallowlyEqual(equalityCheck, prev, next) &#123; if (prev === null || next === null || prev.length !== next.length) &#123; return false &#125; const length = prev.length for (let i = 0; i &lt; length; i++) &#123; if (!equalityCheck(prev[i], next[i])) &#123; return false &#125; &#125; return true&#125; 这个函数也不复杂，其主要是遍历元素，然后调用equalityCheck方法，如果有一项不满足，就会马上退出。 defaultMemoize1234567891011121314151617181920212223242526272829/* defaultMemoize接收两个参数： func是要调用的方法 equalityCheck就是对比前后两个数据的方法，默认值是defaultEqualityCheck*/export function defaultMemoize(func, equalityCheck = defaultEqualityCheck) &#123; /* 先声明了两个为null的变量，它们有很重要的作用 */ let lastArgs = null let lastResult = null /* 这里返回一个函数，调用了areArgumentsShallowlyEqual方法 并将equalityCheck、lastArgs以及函数的arguments传入 如果满足条件，则直接让传入的func调用arguments 并把arguments赋值给lastArgs 这里应用闭包的方式，将参数记录保存下来 */ return function () &#123; if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) &#123; lastResult = func.apply(null, arguments) &#125; lastArgs = arguments return lastResult &#125;&#125; defaultMemoize是reselect的核心方法，通过上面的源码分析可以知道，每次使用时，都会把参数arguments通过闭包的方式保存起来，这样下次再调用时，可以获取到上次保存的值（也就是prevArguments），然后与本次的arguments（也就是nextArguments）做对比，只有变化的时候，才会再次调用传入的func方法。而这里的arguments其实就是在mapStateToProps中传入的参数 createSelectorCreator123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* createSelectorCreator接收若干参数，但最主要的是memoize createSelector调用createSelectorCreator传入的参数是defaultMemoize 所以这里的memoize就是defaultMemoize 然后返回一个接收任意多个以函数为参数的方法*/export function createSelectorCreator(memoize, ...memoizeOptions) &#123; return (...funcs) =&gt; &#123; /* 这里先声明了要重新计算的次数，然后获取到传入的参数最后一项 并对剩余的参数调用了getDependencies方法（不要忘记数组的pop 方法会改变原始数组） 这里的funcs就是在创建createSelector时传入的参数 先去下面看看getDependencies方法 通过分析可知，就是对参数做了校验 */ let recomputations = 0 const resultFunc = funcs.pop() const dependencies = getDependencies(funcs) /* 这里调用了memoize也就是defaultMemoize，并传入参数 */ const memoizedResultFunc = memoize( function () &#123; recomputations++ return resultFunc.apply(null, arguments) &#125;, ...memoizeOptions ) /* selector是最后的返回值，它同样会调用defaultMemoize方法 */ const selector = memoize(function () &#123; const params = [] const length = dependencies.length /* 这里除funcs最后一个参数外，都会以arguments作为参数传入 并将执行后的结果放入到数组params中，最终再执行结果函数 并以params为参数，仔细分析可知，这里的arguments就是在 mapStateToProps传入的值 */ for (let i = 0; i &lt; length; i++) &#123; params.push(dependencies[i].apply(null, arguments)) &#125; /* 所以这也就是在createSelector时，最后一个方法可以以前面 方法的结果作为参数 */ return memoizedResultFunc.apply(null, params) &#125;) /* 这里还定义的selector的其它一些属性，可以直接在开发中使用 每个属性的value都对应上面定义的值 */ selector.resultFunc = resultFunc selector.dependencies = dependencies selector.recomputations = () =&gt; recomputations selector.resetRecomputations = () =&gt; recomputations = 0 return selector &#125;&#125; getDependencies方法： 1234567891011121314151617181920/* getDependencies方法其实很简单，就是判断参数的每一项是否都是函数 如果不是就会报错，如果都是函数，则直接把参数返回 看了源码也可以知道，传入的参数可以是单个的参数，也可以是数组 所以在平时写createSelector时，除了最后一个参数外，其余参数可以都放在数组里*/function getDependencies(funcs) &#123; const dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs if (!dependencies.every(dep =&gt; typeof dep === 'function')) &#123; const dependencyTypes = dependencies.map( dep =&gt; typeof dep ).join(', ') throw new Error( 'Selector creators expect all input-selectors to be functions, ' + `instead received the following types: [$&#123;dependencyTypes&#125;]` ) &#125; return dependencies&#125; creatSelector实例123456789101112//selectorconst getNumA = state =&gt; state.numAconst getNumB = state =&gt; state.numBconst sumFn = (numA, numB) =&gt; numA + numBconst numSum = createSelector( getNumA, getNumB, sumFn)//mapStateToPropsconst mapStateToProps = state =&gt; (&#123; num: numSum(state) &#125;) 上面是非常简单的例子，来结合源码看一下过程： 1、根据分析，getNumA、getNumB、sumFn作为createSelectorCreator返回函数的参数funcs传入，先将sumFn取出，然后其他参数做是否为函数校验。 2、定义memoizedResultFunc，其值是经过defaultMemoize转换后的值，也就是： 12345678910111213const func1 = function () &#123; recomputations++ return resultFunc.apply(null, arguments)&#125;const memoizedResultFunc = function () &#123; if (!areArgumentsShallowlyEqual(defaultEqualityCheck, lastArgs, arguments)) &#123; lastResult = func1.apply(null, arguments) &#125; lastArgs = arguments return lastResult&#125; 3、定义selector，其值也是经过defaultMemoize转换后的值： 12345678910111213141516171819const func2 = function () &#123; const params = [] const length = dependencies.length for (let i = 0; i &lt; length; i++) &#123; params.push(dependencies[i].apply(null, arguments)) &#125; return memoizedResultFunc.apply(null, params)&#125;const selector = function () &#123; if (!areArgumentsShallowlyEqual(defaultEqualityCheck, lastArgs, arguments)) &#123; lastResult = func2.apply(null, arguments) &#125; lastArgs = arguments return lastResult&#125; 4、当在mapStateToProps中调用numSum方法并传入state时，会执行selector方法，所以selector中的arguments就是state，在selector内部会执行func2方法，同时用闭包的方式保存下来arguments，这样在getNumA、getNumB就会接收到state参数，将结果放入params数组中，执行memoizedResultFunc传入params 5、memoizedResultFunc内的arguments就是传入的params，然后执行func1方法，也就以params为参数执行了sumFn，同样会用闭包保存下来arguments，最终得到的num就是sumFn执行后的结果 6、此时保存了两个arguments，一个是state，一个是params。只有当两个都发生变化的时候，num才会更新，否则就一直保持原来的值 createSelectorCreator其它用法看完源码知道，createSelector是基于createSelectorCreator实现的，传入的参数是defaultMemoize，也就是reselect内部默认的方法。但reselect也允许自定义可配置的selector，也就是传入createSelectorCreator的参数可以自己选择，比如传入lodash、underscore中的比较、对比、缓存等方法，具体用法可以查看github文档，里面有详细介绍。 总结经过上面的分析，createSelector也就是createSelectorCreator内部最主要是应用了闭包的方式，保存了之前的参数值，然后当再次调用方法传入参数的时候，会将前后两次的值进行对比，只有在发生变化的时候，才会真正调用定义selector时的方法。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"reselect","slug":"reselect","permalink":"http://yixirumeng.github.io/tags/reselect/"}]},{"title":"redux-actions源码分析五 ———— combineActions","date":"2018-12-02T03:32:12.000Z","path":"2018/12/02/redux-actions-source-code-analysis-combineActions/","text":"前面分析了redux-actions的四个Api，combineActions也是其很重要并且很常用的Api，之前写的不同type的处理函数都是分开写的，但是如果有关联的操作，还是需要分别写，而combineActions正好可以将它们结合起来，使得代码更加简便，下面对其源码进行分析一下 combineActions12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* isValidActionType会校验type是否为String、Function、Symbol类型*/function isValidActionType(type) &#123; return isString(type) || isFunction(type) || isSymbol(type);&#125;/* isValidActionTypes会校验types数组是否为空 如果不为空再分别调用isValidActionType方法*/function isValidActionTypes(types) &#123; if (isEmpty(types)) &#123; return false; &#125; return types.every(isValidActionType);&#125;/* combineActions接收任意个数的actionType 先对其进行isValidActionTypes校验，不通过会报错*/export default function combineActions(...actionsTypes) &#123; invariant( isValidActionTypes(actionsTypes), 'Expected action types to be strings, symbols, or action creators' ); /* 这里会遍历actionsTypes的每一项，然后调用toString方法做字符串转换 最终用'||'连接，生成一个大的字符串 然后返回一个对象，key为toString，value为一个函数返回combinedActionType */ /* 这里着重说一下为什么这么处理： 还记得在分析handleAction这个Api的时候，刚开始会先按'||'切割，然后判断是否在其中 const types = toString(type).split(ACTION_TYPE_DELIMITER); 所以这里用了常量'||'进行连接 */ const combinedActionType = actionsTypes .map(toString) .join(ACTION_TYPE_DELIMITER); /* 这里为什么会返回一个key为toString的对象呢？ 请看下面的combineActions实例，里面会有详细解释 */ return &#123; toString: () =&gt; combinedActionType &#125;;&#125; combineActions实例看过redux-actions的文档，可以知道combineActions的用法 123456789101112/* 这是combineActions的正常用法，可以看到它会放入到handleActions第一参数Object中 如果正常以变量值作为Object的key，则会成为Object的属性 所以应用es6语法[]，这样就会把变量的值作为key 而[]正好调用的是内部变量的toString方法，这也就说明了上面为什么返回的Object的 key是toString，其value为函数，调用后直接能得到上面的combineActionType*/handleActions(&#123; [combineActions(increment, decrement)]: (state, payload) =&gt; &#123; return &#123; ...state, num: state.num + payload.num &#125; &#125;&#125;, &#123; num: 1 &#125;) combineActions其它地方其实跟handleActions都很类似，但是数据处理函数会稍有不同，因为传入的值是需要满足所有map的，这就需要对payload有不同的要求，并不能像以前分开的一样，即使传入的相同得到的也是不同的结果 总结以前写的reducer是根据type来区分的，而combineActions则是根据传入的数据进行区分的。相对来说，更适合将操作相似的reducer结合在一起，如果偏差很大，用起来会很麻烦，所以实际应用中如果不能分清哪些操作相似，还是尽量少用，因为可能需要对传入的数据进行转换。 整体总结以上用了5篇文章分别从源码的角度并结合实例详细分析了redux-actions的Api，可以看出，我们平时开发应用广泛的createActions、handleActions都是基于createAction、handleAction进行实现的，只不过其内部做了很多处理，而且也支持了像Map、Array这些类型，但是他们终究还是要生成redux能够是别的action、reducer。但使用redux-actions后，可以简化开发时的书写，使得代码更加清晰易懂。 其实redux-actions还有另外一个Api，createCurriedAction，但其应用非常非常少，官方文档都没有具体说明用法，而且它也是基于其它库开发的，所以这里就先不做介绍了，能用好之前介绍的5个Api，足以开发正常应用了。 读后收获读过redux-actions源码后，从中收获了很多，简单总结一下： 1、通过原型的方式可以判断出一个对象是否为扁平对象 2、通过以函数作为参数的方式来实现复杂的功能 3、函数还可以再返回函数，以此来达到高阶函数的效果 4、数组操作的Api中，有一些会改变原有数组，这一点一定要熟知 5、基本类型、引用类型的类型判断方式，以及其Api的操作方式，得到结果是什么样子的 6、es6语法中一些语法内部的实现，以及其底层应用了什么方法，比如上面说的以[变量]作为Object的key是调用了toString方法 7、理解中间件设计的中心思想，简化代码编写、易于理解、阅读清晰 8、阅读源码可以清晰的知道每个Api的正确使用方式，以及明白这样做最终结果是什么样子的。而不是看了文档只是照搬照抄，过于局限。 …. 其实还有很多，就不再一一列举了，但有一点很重要，那就是js基础，任何框架、库都是基于基础的，所以打好基础是重中之重。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux-actions","slug":"redux-actions","permalink":"http://yixirumeng.github.io/tags/redux-actions/"}]},{"title":"redux-actions源码分析四 ———— handleActions","date":"2018-11-30T11:41:18.000Z","path":"2018/11/30/redux-actions-source-code-analysis-handleActions/","text":"上一节末尾也总结了，handleAction只能针对单独type，如果type多了就会不方便应用，而handleActions正是来解决这一问题，它与createActions类似，下面就来对其源码进行一下分析 handleActions123456789101112131415161718192021222324252627282930313233343536373839404142/* handleActions接收三个参数，分别为： handlers：Object或Map类型，里面包含对每种type的处理 defaultState：初始状态 options：一般不需要传递，默认为&#123;&#125;*/export default function handleActions(handlers, defaultState, options = &#123;&#125;) &#123; /* handlers必须为扁平Object或者Map，否则会报错 */ invariant( isPlainObject(handlers) || isMap(handlers), 'Expected handlers to be a plain object.' ); /* 这里调用flattenReducerMap方法 请先移步到flattenReducerMap方法分析 经过分析可知道，flattenedReducerMap得到的值就是扁平化的Object 其key和value分别为type及其对应的数据处理方法 */ const flattenedReducerMap = flattenReducerMap(handlers, options); /* 这里遍历flattenedReducerMap，并对每一项分别调用handleActions方法 */ const reducers = ownKeys(flattenedReducerMap).map(type =&gt; handleAction(type, get(type, flattenedReducerMap), defaultState) ); /* 这里的reduceReducers方法是引入的reduce-reducers插件 其主要是将多个reducer合并，但其与redux的combinReducers有差别 具体内容可以查看github文档 */ const reducer = reduceReducers(...reducers, defaultState); /* 最终返回的还是一个普通的reducer函数，只不过是经过上述处理的 */ return (state = defaultState, action) =&gt; reducer(state, action);&#125; flattenReducerMap方法源码分析： 1234567/* 熟悉吗，这里还是调用flattenWhenNode方法，并把下面的方法参数传入 请先移步到flattenWhenNode方法分析*/export default flattenWhenNode( node =&gt; (isPlainObject(node) || isMap(node)) &amp;&amp; !hasGeneratorInterface(node)); flattenWhenNode方法源码分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* 这里的predicate即为上面传入的那个方法参数 然后返回一个方法*/export default predicate =&gt; /* 这里的map即为上面的handlers namespace为'/' prefix为undefined partialFlatMap、partialFlatActionType为默认值 还是一样，内部方法先不看，先看下面的，遇到调用再看 */ function flatten( map, &#123; namespace = DEFAULT_NAMESPACE, prefix &#125; = &#123;&#125;, partialFlatMap = &#123;&#125;, partialFlatActionType = '' ) &#123; /* connectNamespace方法会接收type参数，然后进行判断 因为partialFlatActionType为''，所以直接返回了type 该方法下面的逻辑会在其它地方用到，这里暂且不考虑 */ function connectNamespace(type) &#123; if (!partialFlatActionType) return type; const types = type.toString().split(ACTION_TYPE_DELIMITER); const partials = partialFlatActionType.split(ACTION_TYPE_DELIMITER); return [] .concat(...partials.map(p =&gt; types.map(t =&gt; `$&#123;p&#125;$&#123;namespace&#125;$&#123;t&#125;`))) .join(ACTION_TYPE_DELIMITER); &#125; /* connectPrefix同样的，因为partialFlatActionType为''，prefix为undefined 所以还是返回type */ function connectPrefix(type) &#123; if (partialFlatActionType || !prefix) &#123; return type; &#125; return `$&#123;prefix&#125;$&#123;namespace&#125;$&#123;type&#125;`; &#125; /* 之前分析过，ownKeys是获取map中的每个key，然后遍历 分别调用connectPrefix、connectNamespace方法 请先移步到这两个方法的分析 经过上面两个函数的分析，这里的nextNamespace还是type */ ownKeys(map).forEach(type =&gt; &#123; const nextNamespace = connectPrefix(connectNamespace(type)); /* 这里调用了get方法，得到key对应的value */ const mapValue = get(type, map); /* 这里做了判断，predicate即上面的isPlainObject 因为mapValue可以不单单是个函数，如果还是对象，这递归调用flatten方法 这里因为mapValue已经是函数了，所以进入else逻辑 而partialFlatMap的初始值是&#123;&#125; 最终遍历之后得到的partialFlatMap类似于： &#123; INCREMENT: (state, action) =&gt; (&#123; ...state, counter: state.counter + action.payload &#125;), ​ DECREMENT: (state, action) =&gt; (&#123; ...state, counter: state.counter - action.payload &#125;) &#125; 并将结果返回 */ if (predicate(mapValue)) &#123; flatten(mapValue, &#123; namespace, prefix &#125;, partialFlatMap, nextNamespace); &#125; else &#123; partialFlatMap[nextNamespace] = mapValue; &#125; &#125;); return partialFlatMap; &#125;; handleActions实例123456789101112131415/* 经过上述分析，其最终会转换成普通的reducer函数，与平时开发时写的reducer类似*/handleActions( &#123; INCREMENT: (state, action) =&gt; (&#123; ...state, counter: state.counter + action.payload &#125;), ​ DECREMENT: (state, action) =&gt; (&#123; ...state, counter: state.counter - action.payload &#125;) &#125;, &#123; counter: 0 &#125;) 总结handleActions内部原理是对传入的Object或者Map遍历，并分别调用handleAction方法，最终还是将自身转换成为一个普通的reducer，因为redux的createStore方法接收的只是一个纯函数的reducer。handleActions弥补了handleAction不能处理多个type的不足，使用起来更加方便。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux-actions","slug":"redux-actions","permalink":"http://yixirumeng.github.io/tags/redux-actions/"}]},{"title":"redux-actions源码分析三 ———— handleAction","date":"2018-11-28T12:10:09.000Z","path":"2018/11/28/redux-actions-source-code-analysis-handleAction/","text":"前面分析了创建action的两个方法，现在来分析一下handleAction方法，handleAction主要用于简化reducer，下面就来对其源码进行分析 handleAction12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* handleAction接收三个参数 type：即为action的type reducer：即为要对type进行数据处理的方法 defaultState：初始的state*/export default function handleAction(type, reducer = identity, defaultState) &#123; /* 首先对type进行处理，这里ACTION_TYPE_DELIMITER为'||' 之后对reducer、defaultState进行校验，不通过会抛出错误 */ const types = toString(type).split(ACTION_TYPE_DELIMITER); invariant( !isUndefined(defaultState), `defaultState for reducer handling $&#123;types.join(', ')&#125; should be defined` ); invariant( isFunction(reducer) || isPlainObject(reducer), 'Expected reducer to be a function or object with next and throw reducers' ); /* 这里校验reducer是否为函数，然后得到nextReducer、throwReducer */ const [nextReducer, throwReducer] = isFunction(reducer) ? [reducer, reducer] : [reducer.next, reducer.throw].map( aReducer =&gt; (isNil(aReducer) ? identity : aReducer) ); /* 最终返回一个方法，再对type进行校验，如果不在上面types数组中，直接返回默认state */ return (state = defaultState, action) =&gt; &#123; const &#123; type: actionType &#125; = action; if (!actionType || types.indexOf(toString(actionType)) === -1) &#123; return state; &#125; /* 如果type在types数组中，直接调用reducer函数，并把state、action传入 这里可以看出与普通的reducer类似 */ return (action.error === true ? throwReducer : nextReducer)(state, action); &#125;;&#125; handleAction实例12345678910/* 经过上面分析，当dispatch(increment(1))时，会调用第二个函数参数，得到变化后的count为2*/handleAction( 'INCREMENT', (state, action) =&gt; &#123; return &#123; ...state, count: state.count + action.payload &#125; &#125;, &#123; count: 1 &#125;) 总结handleAction方法其实就是对普通的reducer进行了包装，但其只能用于单个type，实际应用中很少会只有一个type，如果有多个type，则需要多次调用handleAction方法，这会很复杂，所以这个Api在开发中应用较少","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux-actions","slug":"redux-actions","permalink":"http://yixirumeng.github.io/tags/redux-actions/"}]},{"title":"redux-actions源码分析二 ———— createActions","date":"2018-11-25T11:23:56.000Z","path":"2018/11/25/redux-actions-source-code-analysis-createActions/","text":"上一节对createAction进行了分析，其每次只能创建一个action，如果想要一次创建多个action，这就需要应用createActions这一Api，下面对createActions的源码来分析一下 createActionscreateActions的源码会复杂很多，一步一步来分析，不要着急 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* createActions接收两个参数actionMap、identityActions 根据redux-actions的Api文档可以知道，这个actionMap是定义的一个含有多个action的对象 identityActions是定义任意个数的常量*/export default function createActions(actionMap, ...identityActions) &#123; /* 这里对identityActions进行了一次校验，会获取identityActions最后一个元素 检验其是否为是一个扁平的对象，正常我们传递的都是作为type的普通字符串 所以会options的值就是&#123;&#125; */ const options = isPlainObject(getLastElement(identityActions)) ? identityActions.pop() : &#123;&#125;; /* 这里还是像之前说过的，对参数进行校验，如果校验不通过会报出错误 */ invariant( identityActions.every(isString) &amp;&amp; (isString(actionMap) || isPlainObject(actionMap)), 'Expected optional object followed by string action types' ); /* 在调用createActions时，传递的参数可以全部是字符串，所以这里对actionMap进行判断 如果是字符串，直接调用actionCreatorsFromIdentityActions方法 请移步到actionCreatorsFromActionMap方法分析 */ if (isString(actionMap)) &#123; return actionCreatorsFromIdentityActions( [actionMap, ...identityActions], options ); &#125; /* 如果actionMap不是字符串，会调用actionCreatorsFromActionMap方法 请先移步到actionCreatorsFromActionMap方法分析 后续的参数identityActions则调用actionCreatorsFromIdentityActions方法 请先移步到actionCreatorsFromIdentityActions方法分析 经过分析可以知道，最终返回的结果是经过调用createAction以及camelCase转换后的结果 所以还是可以通过对象解构的方式获取到每个action方法，即： const &#123; increment, decrement, asyncIncrement &#125; = createActions(&#123; INCREMENT: value =&gt; value, DECREMENT: value =&gt; -value &#125;, 'ASYNC_INCREMENT') */ return &#123; ...actionCreatorsFromActionMap(actionMap, options), ...actionCreatorsFromIdentityActions(identityActions, options) &#125;;&#125; 在分析actionCreatorsFromIdentityActions之前先分析一下arrayToObject这个方法，因为它会在很多地方用到 12345678910/* 其实从名字上也可以看出，它主要是将array转换为object 这里应用了数组的reduce方法，分别对每个元素调用callback方法 并将结果放入到&#123;&#125;中*/export default (array, callback) =&gt; array.reduce( (partialObject, element) =&gt; callback(partialObject, element), &#123;&#125; ); actionCreatorsFromIdentityActions方法源码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* actionCreatorsFromIdentityActions方法接收两个参数identityActions、options 根据上面的分析可以知道identityActions是一个字符串数组 而options就是个普通的&#123;&#125;*/function actionCreatorsFromIdentityActions(identityActions, options) &#123; /* 根据上面的分析，这里会对identityActions每一个元素调用第二个方法参数 而这个方法最终生成的对象就是一个包含所有type的一个大的对象 下面的identity之前说过，就是 value =&gt; value 这个函数 所以最终的actionMap就是类型于： &#123; 'INCREMENT': value =&gt; value, 'DECREMENT': value =&gt; value &#125; 这样的对象 */ const actionMap = arrayToObject( identityActions, (partialActionMap, type) =&gt; (&#123; ...partialActionMap, [type]: identity &#125;) ); /* 这里再对生成的actionMap调用actionMapToActionCreators方法，请先到下面看方法分析 根据下面分析可以知道，actionCreators就是一个包含type-actionCreator的对象 */ const actionCreators = actionMapToActionCreators(actionMap, options); /* 再一次调用了arrayToObject方法，这里以actionCreators的key作为第一个参数 而传入的第二个方法其实不用仔细分析也能知道，只是把type转换为驼峰的形式 所以最终的对象根actionCreators基本一致，只不过把actionCreators的key进行了驼峰转换 这也就是我们可以通过对象解构的方式获取到每个action方法，即： const &#123; increment, decrement, asyncIncrement &#125; = createActions('INCREMENT', 'DECREMENT', 'ASYNC_INCREMENT') */ return arrayToObject( Object.keys(actionCreators), (partialActionCreators, type) =&gt; (&#123; ...partialActionCreators, [camelCase(type)]: actionCreators[type] &#125;) );&#125; actionMapToActionCreators方法源码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* actionMapToActionCreators接收actionMap这个参数，据上面的分析 actionMap就是类似 &#123; 'INCREMENT': value =&gt; value, 'DECREMENT': value =&gt; value &#125; 这样的对象 下面的prefix可以理解其为undefined，namespace的值为一个常量'/' 因为这个方法内部还嵌套一个函数，所以先不要看嵌套的函数，先看下面返回值的内容， 当遇到这个函数的调用的时候，再回头来分析*/function actionMapToActionCreators( actionMap, &#123; prefix, namespace = DEFAULT_NAMESPACE &#125; = &#123;&#125;) &#123; function isValidActionMapValue(actionMapValue) &#123; if (isFunction(actionMapValue) || isNil(actionMapValue)) &#123; return true; &#125; if (isArray(actionMapValue)) &#123; const [payload = identity, meta] = actionMapValue; return isFunction(payload) &amp;&amp; isFunction(meta); &#125; return false; &#125; /* 这里还是调用了arrayToObject方法，传递的第二个方法参数稍有复杂 别着急，还是一步一步分析 先获取到actionMap中的所有的key，作为arrayToObject的第一参数 */ return arrayToObject( Object.keys(actionMap), /* 还记得上面分析的arrayToObject函数吗，就是调用了数组的reduce方法 所以这里初始的partialActionCreators就是空对象&#123;&#125; type就是Object.keys(actionMap)每个元素，也就是actionMap的key */ (partialActionCreators, type) =&gt; &#123; /* 这里的actionMapValue就是每个key对应的value 下面还是做了校验，如果不通过报错 */ const actionMapValue = actionMap[type]; invariant( isValidActionMapValue(actionMapValue), 'Expected function, undefined, null, or array with payload and meta ' + `functions for $&#123;type&#125;` ); /* 因为上面分析了prefix就是undefined，所以prefixedType的值就是type */ const prefixedType = prefix ? `$&#123;prefix&#125;$&#123;namespace&#125;$&#123;type&#125;` : type; /* 这里对actionMapValue进行是否为数组校验，然后调用createAction createAction就是redux-actions的Api 最终返回的一个包含type和actionCreator这个key-value的对象 而这个对象的形式就类似于： &#123; 'INCREMENT': incrementActionCreator, 'DECREMENT': decrementActionCreator &#125; 还记得上一篇分析的createAction吗，它的返回值就是一个方法， 执行这个方法，也就得到了最基本的action actionMapToActionCreators分析完了，再回到之前的地方 */ const actionCreator = isArray(actionMapValue) ? createAction(prefixedType, ...actionMapValue) : createAction(prefixedType, actionMapValue); return &#123; ...partialActionCreators, [type]: actionCreator &#125;; &#125; );&#125; actionCreatorsFromActionMap方法源码分析： 12345678910111213141516171819202122232425262728293031323334353637/* actionCreatorsFromActionMap接收actionMap、options两个参数 根据上面的分析，actionMap类似于： &#123; INCREMENT: value =&gt; value, DECREMENT: value =&gt; -value &#125; 而options就是空对象&#123;&#125;*/function actionCreatorsFromActionMap(actionMap, options) &#123; /* 这里调用了flattenActionMap这个方法 请先移步到flattenActionMap方法的分析 经过分析可以知道，flatActionMap的值是将对象扁平化 */ const flatActionMap = flattenActionMap(actionMap, options); /* 这里再调用actionMapToActionCreators方法 请先移步到actionMapToActionCreators方法分析 经过分析可以知道，调用之后的结果就是将每一项调用creatAction 所以结果类似于： &#123; 'INCREMENT': incrementActionCreator, 'DECREMENT': decrementActionCreator &#125; */ const flatActionCreators = actionMapToActionCreators(flatActionMap); /* 这里调用了unflattenActionCreators方法 请先移步到unflattenActionCreators的方法分析 经过分析可以知道，返回的结果是经过驼峰转换后的结果 这与actionCreatorsFromIdentityActions方法类似 */ return unflattenActionCreators(flatActionCreators, options);&#125; flattenActionMap方法源码分析： 123456/* flattenActionMap调用了flattenWhenNode方法 并传入是否为扁平对象这个方法作为参数 请移步到flattenWhenNode方法分析*/export default flattenWhenNode(isPlainObject); flattenWhenNode方法源码分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* flattenWhenNode接收一个predicate参数，并返回一个函数 predicate为上面传入的isPlainObject 返回的flatten方法中的参数分别为： map：就是上面传入的actionMap namespace：常量'/' prefix：undefined partialFlatMap：&#123;&#125; partialFlatActionType：'' 函数里面还有函数，还是一样当调用的时候再分析*/export default predicate =&gt; function flatten( map, &#123; namespace = DEFAULT_NAMESPACE, prefix &#125; = &#123;&#125;, partialFlatMap = &#123;&#125;, partialFlatActionType = '' ) &#123; /* connectNamespace方法会接收type参数，然后进行判断 因为partialFlatActionType为''，所以直接返回了type 该方法下面的逻辑会在其它地方用到，这里暂且不考虑 */ function connectNamespace(type) &#123; if (!partialFlatActionType) return type; const types = type.toString().split(ACTION_TYPE_DELIMITER); const partials = partialFlatActionType.split(ACTION_TYPE_DELIMITER); return [] .concat(...partials.map(p =&gt; types.map(t =&gt; `$&#123;p&#125;$&#123;namespace&#125;$&#123;t&#125;`))) .join(ACTION_TYPE_DELIMITER); &#125; /* connectPrefix同样的，因为partialFlatActionType为''，prefix为undefined 所以还是返回type */ function connectPrefix(type) &#123; if (partialFlatActionType || !prefix) &#123; return type; &#125; return `$&#123;prefix&#125;$&#123;namespace&#125;$&#123;type&#125;`; &#125; /* 这里调用ownKeys方法，这个方法内部的逻辑是 如果map是个Map类型的，则取出其中的key，并用Array.from转换成数组 如果是Object类型，则用getOwnPropertyNames方法取出自身的key 所以最终得到的是含有所有key的数组 */ ownKeys(map).forEach(type =&gt; &#123; /* 遍历每个key，这里分别调用了connectNamespace、connectPrefix方法 请先移步到这两个方法的分析 经过上面两个函数的分析，这里的nextNamespace还是type */ const nextNamespace = connectPrefix(connectNamespace(type)); /* 这里调用了get方法，因为map可能是Map或者Object类型 应用get方法得到key对应的value */ const mapValue = get(type, map); /* 这里做了判断，predicate即上面的isPlainObject 因为mapValue可以不单单是个函数，如果还是对象，这递归调用flatten方法 这里因为mapValue已经是函数了，所以进入else逻辑 而partialFlatMap的初始值是&#123;&#125; 最终遍历之后得到的partialFlatMap类似于： &#123; INCREMENT: value =&gt; value, DECREMENT: value =&gt; -value &#125; 并将结果返回 */ if (predicate(mapValue)) &#123; flatten(mapValue, &#123; namespace, prefix &#125;, partialFlatMap, nextNamespace); &#125; else &#123; partialFlatMap[nextNamespace] = mapValue; &#125; &#125;); return partialFlatMap; &#125;; unflattenActionCreators方法源码分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* unflattenActionCreators的参数分别为： flatActionCreators：即上面传入的flatActionCreators namespace为常量'/' prefix为undefined*/export default function unflattenActionCreators( flatActionCreators, &#123; namespace = DEFAULT_NAMESPACE, prefix &#125; = &#123;&#125;) &#123; /* unflatten的方法参数分别为： flatActionType即传入的type partialNestedActionCreators为&#123;&#125; partialFlatActionTypePath为字符串转化后的数组 */ function unflatten( flatActionType, partialNestedActionCreators, partialFlatActionTypePath ) &#123; /* 这里对partialFlatActionTypePath去除第一个元素调用了camelCase方法 还记得分析createAction时说的吗，camelCase就是转化驼峰形式 */ const nextNamespace = camelCase(partialFlatActionTypePath.shift()); /* 这里对partialFlatActionTypePath做是否为空的判断，别忘了有件事 上面数组调用了shift方法，而shift方法会改变原来的数组 最终在partialNestedActionCreators即空&#123;&#125;中放入key、value key为经过驼峰转换后的值 value就是传入的key对应的value 如果partialFlatActionTypePath不为空，则递归调用unflatten方法 */ if (isEmpty(partialFlatActionTypePath)) &#123; partialNestedActionCreators[nextNamespace] = flatActionCreators[flatActionType]; &#125; else &#123; if (!partialNestedActionCreators[nextNamespace]) &#123; partialNestedActionCreators[nextNamespace] = &#123;&#125;; &#125; unflatten( flatActionType, partialNestedActionCreators[nextNamespace], partialFlatActionTypePath ); &#125; &#125; const nestedActionCreators = &#123;&#125;; /* 这里获取flatActionCreators自身的属性key并遍历 因为prefix为undefined，所以unprefixedType为type 接着调用unflatten方法 请先移步到unflatten方法的分析 经过分析后可知，最终的结果其实主要对key做了驼峰转换 */ Object.getOwnPropertyNames(flatActionCreators).forEach(type =&gt; &#123; const unprefixedType = prefix ? type.replace(`$&#123;prefix&#125;$&#123;namespace&#125;`, '') : type; return unflatten( type, nestedActionCreators, unprefixedType.split(namespace) ); &#125;); return nestedActionCreators;&#125; createActions实例123456789101112131415161718/* 下面这几种方式都可以，经过上面的分析，如果不传入Object，则直接调用createAction 传入的话，会遍历调用，如果传入的不是扁平Object，则递归遍历，再调用 最终将key进行驼峰转换*/const &#123; increment, decrement, asyncIncrement &#125; = createActions('INCREMENT', 'DECREMENT', 'ASYNC_INCREMENT')const &#123; increment, decrement, asyncIncrement &#125; = createActions(&#123; INCREMENT: value =&gt; value, DECREMENT: value =&gt; -value&#125;, 'ASYNC_INCREMENT')const &#123; increment, decrement, asyncIncrement &#125; = createActions(&#123; COUNT: &#123; INCREMENT: value =&gt; value, DECREMENT: value =&gt; -value &#125;&#125;, 'ASYNC_INCREMENT') 总结createActions方法看上去很复杂，但其内部的逻辑很清晰，主要目的就是遍历每个元素，然后分别调用createAction方法，最终还是生成普通的action，只不过如果只用createAction方法只能单独生成，而createActions可以同时生成多个，减少代码量，更加方便书写，也很清晰。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux-actions","slug":"redux-actions","permalink":"http://yixirumeng.github.io/tags/redux-actions/"}]},{"title":"redux-actions源码分析一 ———— createAction","date":"2018-11-23T11:18:02.000Z","path":"2018/11/23/redux-actions-source-code-analysis-createAction/","text":"redux-actions这个中间件在平时的开发中会经常用到，可以省去繁琐的写法，很方便的写action，下面会用几篇文章分别对它里面的每个Api进行详细分析，还是像之前一样，分析源码的同时结合实际例子，帮助理解。 createAction源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* createAction接收三个参数，除了第一个之外，其它都是可以不传递的 type: 就是平时定义action要写的type payloadCreator: 平时定义action时经常会传递参数（payload），而它正是生成payload的方法 这里它有默认值identity，这个identity其实很简单，就是value =&gt; value 如果不传，它就是很简单的参数=返回值 metaCreator: 很少会用到，可以忽略*/export default function createAction( type, payloadCreator = identity, metaCreator) &#123; /* invariant是一个第三方工具，其详细用法可以去github查一下 这里的意思就是对payloadCreator进行是否为函数、是否为null检验 如果都不通过，就会报出下面的错误 */ invariant( isFunction(payloadCreator) || isNull(payloadCreator), 'Expected payloadCreator to be a function, undefined or null' ); /* finalPayloadCreator即为最终的payload生成函数，这里也是做了校验 */ const finalPayloadCreator = isNull(payloadCreator) || payloadCreator === identity ? identity : (head, ...args) =&gt; head instanceof Error ? head : payloadCreator(head, ...args); const hasMeta = isFunction(metaCreator); const typeString = type.toString(); /* 这个actionCreator就是最终createAction要返回的函数 它接收任意多个参数，最终会把这些参数传入到上面的finalPayloadCreator 创建一个对象action，其属性type为createAction传入的type 其属性payload为经过finalPayloadCreator处理后的payload meta属性很少用到，可以不用考虑 最终导出action */ const actionCreator = (...args) =&gt; &#123; const payload = finalPayloadCreator(...args); const action = &#123; type &#125;; if (payload instanceof Error) &#123; action.error = true; &#125; if (payload !== undefined) &#123; action.payload = payload; &#125; if (hasMeta) &#123; action.meta = metaCreator(...args); &#125; return action; &#125;; actionCreator.toString = () =&gt; typeString; return actionCreator;&#125; 经过上面的分析，可以看到createAction内部的实现其实很简单，主要就是对payload做了一层特殊的处理，将以函数的形式创建，最终createAction导出一个函数，而执行函数后的结果，就是一个正常的action createAction实际应用1234567891011121314151617181920const increment = createAction('INCREMENT')/* 这是createAction最简单用法，这里'INCREMENT'即为type 根据上面分析：createAction最终会返回一个名为actionCreator的函数 执行这个函数会返回一个action的对象，如果没有传递payloadCreator 其默认为 value =&gt; value，finalPayloadCreator也为 value =&gt; value 而下面执行increment时，并没有传递参数， 所以actionCreator中定义的常量payload即为undefined，不会放入action中 最终生成的action为&#123; type: 'INCREMENT' &#125;*/increment()/* 执行这个函数，其它的逻辑跟上面一样，但是因为传递了参数1，所以最终的payload 不会是undefined，因为finalPayloadCreator也为 value =&gt; value 所以payload值为1 最终生成的action为&#123; type: 'INCREMENT', payload: 1 &#125;*/increment(1) 除了默认的payloadCreator之外，还可以自定义payloadCreator 12345678const decrement = createAction('DECREMENT', value =&gt; -value)/* 别的逻辑还是一样，只不过这里自定义了payloadCreator，所以finalPayloadCreator 就是这里自定义的payloadCreator，生成的payload即为-1 最终的action为&#123; type: 'DECREMENT', payload: -1 &#125;*/decrement(1) 进一步分析： 12345678910111213141516/* 可能有人对这个finalPayloadCreator这个判断条件不太理解 如果不传递payloadCreator没什么好说的，finalPayloadCreator就是value =&gt; value 但如果传递了，即使传递还是 value =&gt; value，也会走到else的逻辑 因为function是引用类型，其在内存中并不是直接保存值，保存的是执行的地址 而传入的payloadCreator与identity虽然一样，但地址不同，所以也是不相等的 else的函数又对传递的参数做了原型是否为Error的校验， 其中head就是传递的第一个参数，args是后续的参数， payloadCreator(head, ...args)就是正常执行传递过来的payloadCreator*/const finalPayloadCreator = isNull(payloadCreator) || payloadCreator === identity ? identity : (head, ...args) =&gt; head instanceof Error ? head : payloadCreator(head, ...args); 总结createAction内部其实很简单，但也有很多需要思考并注意的地方，但不过怎样，最终还是要生成一个普通的action，只不过让我们在开发时更加方便操作。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux-actions","slug":"redux-actions","permalink":"http://yixirumeng.github.io/tags/redux-actions/"}]},{"title":"redux-thunk源码分析","date":"2018-11-16T10:53:27.000Z","path":"2018/11/16/redux-thunk-source-code-analysis/","text":"前面分析了redux所有api的源码，接下来分析一下redux常用中间件的源码。因为redux只能处理同步的数据变化，但很多时候需要ajax异步获取数据，所以就需要应用相关中间件来处理。这篇文章就来分析一下异步处理常用中间件redux-thunk的源码。 applyMiddleware因为应用中间件需要用到applyMiddleware这一api，所以要结合applyMiddleware的源码一起来分析。 12345678910111213141516171819202122232425262728293031323334353637383940export default function applyMiddleware(...middlewares) &#123; /* 之前分析过，applyMiddleware会作为createStore的第三个参数传入， 最终会生成：enhancer(createStore)(reducer, preloadedState) */ return createStore =&gt; (...args) =&gt; &#123; /* 所以，下面的store也就是去除掉enhancer之后并由createStore生成的函数 */ const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; /* 这里获取到store的getState，以及根据上面的dispatch函数来设置新的dispatch 将这些传入到中间件中 */ const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; /* 遍历每个中间件，并将middlewareAPI作为参数传入，并应用compose方法，将处理后的middleware 和store原有的dispatch传入，再一次生成新的dispatch，替换掉上面的dispatch */ const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) /* 最终导出store的每一项和dispatch，这里应用对象的解构使得新的dispatch替换了store原有的dispatch */ return &#123; ...store, dispatch &#125; &#125;&#125; redux-thunk本以为redux-thunk内部实现会很复杂，但其源码就这几行，但要理解这几行代码也并非易事，还是要仔细分析一下。 结合上面以及之前的文章分析的applyMiddleware，来看一下redux-thunk的源码 1234567891011121314151617181920212223242526272829303132333435363738/* 因为下面导出了thunk，而thunk是直接执行的createThunkMiddleware函数 也就是导出来createThunkMiddleware的返回值*/function createThunkMiddleware(extraArgument) &#123; /* 这里应用的箭头函数，并以函数作为返回值一层一层传递下去，换成es5的写法是： function(&#123; dispatch, getState &#125;)&#123; return function(next)&#123; return function(action)&#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125; &#125; &#125; 第一个函数的参数&#123; dispatch, getState &#125;正是上面middlewareAPI， 这里是应用了对象的解构，但是由于下面重新对dispatch进行赋值， 所以在我们写的action中的dispatch参数是增强后的dispatch 也就是compose(...chain)(store.dispatch) 第二个函数的参数next正是上面分析过的store原有的dispatch方法， 这只是在只有一个中间件的时候，如果有多个中间件，且redux-thunk 不是最后一个的话，next则是经过别的中间件处理后的函数 第三个函数的参数action正是我们平时写的action 然后对action进行判断，如果为函数，则将上面的dispatch、getState传入action中 如果不是函数，则直接返回next(action)，也就是store.dispatch(action) */ return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 所以，我们平时在应用redux-thunk的时候，会定义一个函数，并返回一个新的函数，同时以dispatch getState作为参数 举例说明一下： 123456789export const increment = () =&gt; &#123; return (dispatch, getState) =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(&#123; type: INCREMENT &#125;) &#125;, 1000) &#125;&#125; 这就是一个典型的应用redux-thunk异步action的写法，而返回函数的参数dispatch getState也正是上面我们分析过的 总结通过上面逐行代码的分析可以知道，正常redux定义的action只能是对象类型，但使用redux-thunk后，可以以函数作为action，而异步执行的操作可以在放在action函数体内，并在异步操作结束后再dispatch。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux-thunk","slug":"redux-thunk","permalink":"http://yixirumeng.github.io/tags/redux-thunk/"}]},{"title":"Redux源码详细分析五 ———— applyMiddleware","date":"2018-11-13T14:50:05.000Z","path":"2018/11/13/redux-source-code-analysis-applyMiddleware/","text":"applyMiddleware这个Api在应用Redux中间件时使用，比如平时开发用的react-redux、redux-thunk、redux-saga等工具，都需要应用applyMiddleware将其与redux结合才可以使用。 applyMiddlewareapplyMiddleware的源码也不多，但也需要仔细读一下才能理解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//applyMiddleware接收任意多个function类型的参数，将其转换成数组传入，并返回一个高阶函数export default function applyMiddleware(...middlewares) &#123; /* applyMiddleware会作为createStore的第三个参数传入，先来看一下createStore对应的代码： if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; 先对其进行校验，如果已经传入并且是个function，则返回 enhancer(createStore)(reducer, preloadedState) 这里的参数createStore即之前的createStore方法， 后面两个参数就是createStore传入的前两个参数 */ return createStore =&gt; (...args) =&gt; &#123; /* 根据上面分析，这里的store得到的就是createStore(reducer, preloadedState) */ const store = createStore(...args) //这里定义的dispatch函数的作用是，当用中间件重新构建createStore还未结束时，应用dispatch会报错 let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; /* 这里定义的middlewareAPI将作为默认的参数传入每个中间件中， 其中getState为当前的store.getState，dispatch为上面定义的函数，并将reducer、preloadedState传入， 这个middlewareAPI的作用就是让中间件可以调用到原来的store */ const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; //遍历传入的中间件，然后将middlewareAPI传入每个中间件中，执行后，最终得到一个中间件数组 const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) /* 中间件的个数可以为任意多个，调用compose方法，并将store.dispatch作为后续的参数传入，并得到新的dispatch 最终的样子为： dispatch = middleware1(middleware2(middleware3(store.dispatch))) */ dispatch = compose(...chain)(store.dispatch) /* 因为createStore返回多个Api函数，所以这里应用...对其进行扩展，同时用新得到的dispatch替换之前的dispatch */ return &#123; ...store, dispatch &#125; &#125;&#125; 通过上面的分析可以知道，applyMiddleware最终返回的还是一个createStore，只不过是应用了其它中间件进行封装，并更改了dispatch这一Api applyMiddleware实例：123456789101112131415161718192021import &#123; applyMiddleware &#125; from 'redux'import thunk from 'redux-thunk'import createSagaMiddleware from 'redux-saga'export const sagaMiddleware = createSagaMiddleware();/* 这里引入redux-thunk和redux-saga两个库，应用applyMiddleware时，根据上面分析可知： 首先会得到store = createStore(reducer, preloadedState)， 每个中间件都会调用上面提到的middlewareAPI，也就是中间件可以获得原来store的getState、reducer和preloadedState 得到： chain = [newSagaMiddleware, newThunk] 再chain放入compose方法内，并将store.dispatch作为后续的参数传入 所以得到的结果是： dispatch = newSagaMiddleware(newThunk(store.dispatch)) 最终会返回所有createStore内部的Api方法，并将原有dispatch替换*/export default applyMiddleware( sagaMiddleware, thunk) 所以，applyMiddleware并不会改变原来createStore内部除dispatch之外的其它方法，因为在日常应用中间件的时候，大多是在处理异步、观察日志等场景下应用，而这些场景都是要在派发action时触发。可以有人会说react-redux这个常用的中间件是要在每个组件中都获取到状态，这不需要更改getState吗？其实这个中间件并不会改变原有的getState方法，因为它是应用了React的context Api将数据传递到每个组件中，后续也会推出react-redux这一中间件的源码分析。 总结以上的五篇文章分别对Redux中五个Api进行了具体分析，经过详细解读后，其实可以发现，Redux底层的实现原理并不复杂，每一个Api的内部逻辑相对来说都很清晰，但每一个的内部都运用了大量的Javascript的基础知识，像闭包、原型链、高阶函数、ES6等，尤其是闭包，redux可以说将其发挥到了极致，这也正是表明了这个库为什么如此受欢迎。 通过源码分析，可以加深对Redux整体架构的理解，同时在日常开发中使用起来能够更加得心应手。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yixirumeng.github.io/tags/redux/"}]},{"title":"Redux源码详细分析四 ———— compose","date":"2018-11-12T14:14:43.000Z","path":"2018/11/12/redux-source-code-analysis-compose/","text":"compose这个Api主要是对函数的调用进行组合，即执行完一个函数得到结果后，传入下一个函数中，以此类推，而函数的调用顺序是自右向左 compose源码很简单，但是内部的逻辑不是很容易懂： 123456789101112131415161718192021222324252627282930//compose方法接收任意多个参数，每个参数都为一个function，并把这些参数组合成数组传入export default function compose(...funcs) &#123; //如果没有传入任何方法，这直接执行后续的调用，即compose()('hello')会直接得到hello if (funcs.length === 0) &#123; return arg =&gt; arg &#125; //如果传入一个方法，则直接调用这个方法 if (funcs.length === 1) &#123; return funcs[0] &#125; /* 当参数的个数大于1时，会执行以下方法，这里调用了数组的reduce方法， 并返回一个function，后续的参数作为这个function的参数传入。 换成es5的写法是这样： funcs.reduce(function(a, b)&#123; return function()&#123; return a(b.bind(undefined, arguments)) &#125; &#125;) 数组的reduce方法是这样： [1, 2, 3].reduce((a, b) =&gt; (a + b))结果为6， 其执行顺序是正序，即第一次：a=1、b=2，a+b=3；第二次：a=3、b=3，a+b=6返回 而下面的方法中数组的每一项都为function，所以第一项会在最后执行，最后一项会最先执行，即： compose(f, g, h)(...args)相当于f(g(h(...args))) */ return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; compose这个Api虽然看上去简单，但要理解还是不容易的，明白reduce的执行原理，就会轻松很多 compose应用实例平时在用redux时，为了方便调试会应用redux-devtools工具，而这个工具的用法如下： 123456789const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;/* 这里传入的参数只有一个function，即applyMiddleware(thunk)， 根据上面的判断，会直接执行applyMiddleware(thunk)，*/const store = createStore(reducer, composeEnhancers( applyMiddleware(thunk))); 传入多个参数的情况会在分析applyMiddleware这个Api中提到。 其实，不止在redux中，很多库或者平时开发中都可以应用compose方法。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yixirumeng.github.io/tags/redux/"}]},{"title":"Redux源码详细分析三 ———— bindActionCreators","date":"2018-11-11T05:41:29.000Z","path":"2018/11/11/redux-source-code-analysis-bindActionCreators/","text":"bindActionCreators这个Api在平时的开发中应用不是很多，它主要是用于在没有引入store的子组件中，可以让子组件不直接应用dispatch来派发action，更改state。但实际开发中更多会应用react-redux这个库，而react-redux已经对其进行了封装。 bindActionCreators先来看一下其源码： 12345678910111213141516171819202122232425262728293031323334353637383940//这是bindActionCreators调用的公共方法，其内部就是dispatch一个actionfunction bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125;//bindActionCreators接收两个参数，类型为function或object的actionCreators和store的dispatch方法export default function bindActionCreators(actionCreators, dispatch) &#123; //如果actionCreators传入的值函数，则直接dispatch，因为只有一个actionCreator if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; //对actionCreators进行类型判断，不是object或者为null时，会报错 if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function, instead received $&#123; actionCreators === null ? 'null' : typeof actionCreators &#125;. ` + `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?` ) &#125; /* 此时的actionCreators是一个object，对其进行遍历，并将每一项放入自定义的boundActionCreators中， 相当于深拷贝一份，然后再对每一项执行bindActionCreator方法，也就是对每一项派发action */ const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; bindActionCreators的逻辑很简单，就是先遍历，然后分别执行 bindActionCreators实际例子：12345678910111213141516171819//store.jsconst initialState = &#123; num: 1 &#125;export const increment = () =&gt; (&#123; type: 'INCREMENT' &#125;)export const decrement = () =&gt; (&#123; type: 'DECREMENT' &#125;)const numReducer = (state=initialState, action) =&gt; &#123; switch(action.type)&#123; case 'INCREMENT': return &#123; ...state, num: state.num+1 &#125; case 'DECREMENT': return &#123; ...state, num: state.num-1 &#125; default: return state &#125;&#125;export numStore = createStore(numReducer) 1234567891011121314151617181920212223242526272829303132333435//App.jsclass App extends React.Component &#123; constructor(props)&#123; super(props) this.state = numStore.getState() numStore.subscribe(this.handleChange) &#125; handleChange = () =&gt; &#123; this.setState(numStore.getState()) &#125; render()&#123; const &#123; num &#125; = this.state /* 将increment、decrement两个actionCreator和numStore.dispatch方法传入到bindActionCreators中， 就相当于遍历&#123; increment, decrement &#125;这个对象，得到两个函数，最后以这个对象的key作为key， 以函数作为value的object形式返回，所以actionCreators为： actionCreators = &#123; increment: () =&gt; numStore.dispatch(increment()), decrement: () =&gt; numStore.dispatch(decrement()) &#125; 传入Title子组件，而子组件按钮分别绑定这两个事件，当点击时会派发对应的action，num也得到对应的更新 */ const actionCreators = numStore.bindActionCreators(&#123; increment, decrement &#125;, numStore.dispatch) return ( &lt;div&gt; &lt;div&gt;&#123; num &#125;&lt;/div&gt; &lt;Title &#123; ...actionCreators &#125;/&gt; &lt;/div&gt; ) &#125;&#125; 12345678910111213//title.jsclass Title extends React.Component &#123; render()&#123; const &#123; increment, decrement &#125; = this.props return ( &lt;div&gt; &lt;button onClick=&#123; increment &#125;&gt;increment&lt;/button&gt; &lt;button onClick=&#123; decrement &#125;&gt;decrement&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; bindActionCreators这个Api没有什么难点，就是组合在遍历执行，平时应用较少，因为组件嵌套多了，会不方便管理，如果只是在当前组件，则没必要使用，直接dispatch(action)会更方便。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yixirumeng.github.io/tags/redux/"}]},{"title":"Redux源码详细分析二 ———— combineReducer","date":"2018-11-10T02:37:20.000Z","path":"2018/11/10/redux-source-code-analysis-combineReducer/","text":"上一篇分析了createStore，这篇来分析一下combineReducer。当业务复杂的时候，会将reducer拆开，但createStore传入的只能是一个reducer，这个时候就需要combineReducer将所有的reducer结合起来。 combineReducer看一下combineReducer的源码来进行分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185//combineReducers方法接收对象形式的reducers，也就是&#123; a: reducerA, b: reducerB &#125;export default function combineReducers(reducers) &#123; //获取reducers的key，然后进行遍历，放入到finalReducers，其实相当于深拷贝一份reducers const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key \"$&#123;key&#125;\"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) let unexpectedKeyCache if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125; &#125; //这里调用了校验方法assertReducerShape，检查每个reducer是否有默认状态 let shapeAssertionError try &#123; assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e &#125; /* 最终返回combination，而combination的两个参数是state和action，这正是reducer结构， 所以combineReducers最终返回的还是一个reducer，只不过就是经过封装之后的reducer */ return function combination(state = &#123;&#125;, action) &#123; //如果某个reducer没有返回默认状态，则会报错 if (shapeAssertionError) &#123; throw shapeAssertionError &#125; //调用getUnexpectedStateShapeWarningMessage对reducers、state、action等做进一步校验 if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; //设定一个state是否变化的状态，以及改变后的state的初始值 let hasChanged = false const nextState = &#123;&#125; /* 遍历每个reducer，同时找到该reducer对应的state，然后把这个state和action传入到reducer中， 如果在reducer中找到对应的action.type则进行状态更新，否则返回原始状态， 最终会判断当前后两个state是否相同，如果相同则返回之前传入的state，否则会返回改变后的state 这里注意一个问题，在createStore时，会默认派发一次action，而这次派发会得到所有reducer的初始状态， 然后将这些状态拼到一个大的state中，以reducers的key作为这个大state的key，value就是每个reducer对应初始state， 这样state[key]就可以获取到当前reducer对应的state */ for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125;------------校验函数---------------//这个函数的作用是校验每个reducer是否有返回默认状态，如果没有回报错，如果确实不用返回默认状态，则返回null替代什么都不返回function getUndefinedStateErrorMessage(key, action) &#123; const actionType = action &amp;&amp; action.type const actionDescription = (actionType &amp;&amp; `action \"$&#123;String(actionType)&#125;\"`) || 'an action' return ( `Given $&#123;actionDescription&#125;, reducer \"$&#123;key&#125;\" returned undefined. ` + `To ignore an action, you must explicitly return the previous state. ` + `If you want this reducer to hold no value, you can return null instead of undefined.` )&#125;//这个函数的主要作用是对传入的reducers、传入的state、以及初始状态做进一步校验function getUnexpectedStateShapeWarningMessage( inputState, reducers, action, unexpectedKeyCache) &#123; const reducerKeys = Object.keys(reducers) const argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer' if (reducerKeys.length === 0) &#123; return ( 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.' ) &#125; if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of \"` + &#123;&#125;.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + `\". Expected argument to be an object with the following ` + `keys: \"$&#123;reducerKeys.join('\", \"')&#125;\"` ) &#125; const unexpectedKeys = Object.keys(inputState).filter( key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key] ) unexpectedKeys.forEach(key =&gt; &#123; unexpectedKeyCache[key] = true &#125;) if (action &amp;&amp; action.type === ActionTypes.REPLACE) return if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? 'keys' : 'key'&#125; ` + `\"$&#123;unexpectedKeys.join('\", \"')&#125;\" found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `\"$&#123;reducerKeys.join('\", \"')&#125;\". Unexpected keys will be ignored.` ) &#125;&#125;//这个校验方法主要作用是检查每个reducer里有没有默认的返回状态function assertReducerShape(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; const reducer = reducers[key] const initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) &#125; if ( typeof reducer(undefined, &#123; type: ActionTypes.PROBE_UNKNOWN_ACTION() &#125;) === 'undefined' ) &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined when probed with a random type. ` + `Don't try to handle $&#123; ActionTypes.INIT &#125; or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) &#125; &#125;)&#125; 通过上述的分析，其实combineReducers方法就是组合所有传入的reducer，最终返回一个组合后的reducer，其本质还是个reducer，因为createStore接收的第一个参数必须是个纯函数的reducer。当派发action进行state更新时，这个组合后的reducer会遍历所有传入的reducer，找到action.type对应的reducer并进行更改，最终会为了优化，只返回有更改的state。 combineReducers实例：12345678910111213141516171819202122232425262728293031323334353637383940414243const numState = &#123; num: 1 &#125;const strState = &#123; str: 'hello' &#125;const numReducer = (state=numState, action) =&gt; &#123; switch(action.type)&#123; case 'INCREMENT': return &#123; ...state, num: state.num+1 &#125; default: return state &#125;&#125;const strReducer = (state=strState, action) =&gt; &#123; switch(action.type)&#123; case 'CHANGE': return &#123; ...state, str: state.str+' world!' &#125; default: return state &#125;&#125;const reducers = combineReducers(&#123; numR: numReducer, strR: strReducer &#125;)/* 这里通过combineReducers组合了numReducer、strReducer返回了reducers，放入createStore中， 而createStore会默认派发一次type为随机数的action，获取最终的组合的state，对于这个例子，则是： state = &#123; numR: &#123; num: 1 &#125;, strR: &#123; str: 'hello' &#125; &#125;*/const store = createStore(reducers)/* 当派发下面这个change的action时，首先会遍历所有的reducer： 1、第一个找到numReducer，然后根据state[numR]找到其状态是numState=&#123; num: 1 &#125;，并将numState以及change的action传入， 因为没有对应的type，所以返回默认值，而这个默认值与之前找到的numState相同，则不改变state 2、第二个找到strReducer，根据state[strR]找到其状态是strState=&#123; str: 'hello' &#125;，并将strState以及change的action传入， 在strReducer中找到对应的type，将strState改为&#123; str: 'hello world!' &#125;并返回，因为跟之前的strState不一样， 所以会将state中strR的value改成&#123; str: 'hello world!' &#125;，最终就可以取得更新之后state*/const change = () =&gt; (&#123; type: 'CHANGE' &#125;)dispatch(change()) 结合源码分析以及实际例子可以清晰知道combineReducers的内部实现原理，其实并不复杂，与单个reducer的逻辑基本一致，只不过加了一层封装。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yixirumeng.github.io/tags/redux/"}]},{"title":"Redux源码详细分析一 ———— createStore","date":"2018-11-09T12:19:35.000Z","path":"2018/11/09/redux-source-code-analysis-createStore/","text":"在React框架开发应用时，作为状态管理工具的Redux会经常用到，接下来的这几篇文章会从源码上逐个分析Redux中的每个Api，并结合例子帮助理解，这样可以在以后的开发中更加熟练应用。 createStore用过Redux肯定会知道，这个Api是其最重要的一个，也是Redux的入口。下面先看一下其源码（这里省略了两个不常用到的方法），然后会每一步做了什么进行分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198//其实就是一个函数，接收三个参数，reducer、初始状态（preloadedState）、应用的中间件（enhancer）export default function createStore(reducer, preloadedState, enhancer) &#123; //对preloadedState和enhancer进行函数校验，如果校验不通过会报出错误 if ( (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'function') || (typeof enhancer === 'function' &amp;&amp; typeof arguments[3] === 'function') ) &#123; throw new Error( 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function' ) &#125; //如果第二个参数是function，且第三个参数为undefined，则将其交换，这也就是平时可以不写初始状态，直接写应用中间件 if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; //如果enhancer定义了，但不是function，就会报出错误，如果校验通过则执行对应的方法（这块涉及到中间件的应用，后续介绍） if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; //如果reducer不是函数，也会报出错误，这也就是平时要求reducer必须是一个纯函数 if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; //声明一些变量，并把赋予相应的参数值 let currentReducer = reducer let currentState = preloadedState let currentListeners = [] let nextListeners = currentListeners let isDispatching = false //如果nextListeners与currentListeners相等，则调用数组的slice方法，对其进行深拷贝，防止后续因为引用类型出现错误 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; /* 这个方法就是在开发是应用的getState方法，这里对其进行了判断，如果不是在派发的过程中， 就会应用闭包的方式返回currentState，而currentState在上面已经赋值，正是传入的第二个参数preloadedState。 可能会问，如果第二个参数没传，那不是undefined吗？不要着急，接着看就能明白 */ function getState() &#123; if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState &#125; /* 这个方法就是在开发是调用的subscribe方法，当状态发生改变的时候，它就会执行， 它接收一个需要监听的listener，这个listener必须是个函数 */ function subscribe(listener) &#123; //判断listener是否是个函数 if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; //判断当前的状态是否真正派发更新 if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true //这里应用了刚才定义的函数，然后向nextListeners追加传入的listener，这个nextListeners在后续会用到 ensureCanMutateNextListeners() nextListeners.push(listener) //返回的这个函数的作用是在nextListeners中移除传入的listener return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; /* 这个是在开发中调用的dispatch方法，它的作用就是当需要改变状态的时候，派发dispatch进行更新， 它接收action参数，而这个action必须是一个plain对象，也就是这样&#123;type: 'ADD'&#125;直接定义的对象， 这个对象的原型必须是Object，构造函数是Object() */ function dispatch(action) &#123; //对action进行校验 if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; //如果action中没有type，则会报错，这也就是平时开发时需要为每个action都指定type if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; //如果是正在派发的过程中，会报错 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; /* 平时可能用try..catch..用的比较多，而这个try...finally...的意思是当执行完try，会继续执行finally。 首先将状态执为正在派发状态，然后调用传入的reducer方法，并将默认的状态以及action传入到reducer中， 也就是执行平时在reducer中定义的if、switch条件判断，最后将得到的结果赋值给currentState。 所有都执行完后，再将状态执回。 */ try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; /* 这里就用到了上面提到的nextListeners，会遍历其中的每个listener，然后执行， 这也就是要求listener必须是函数，同时也实现了每次dispatch时，subcribe订阅的listener都会得到更新 */ const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; /* 这个dispatch非常重要，在createStore时会默认派发一次dispatch， 而传入的这个action.type是随机生成的（下面是随机生成的代码）， 执行这个dispatch就是为了获取在定义reducer时传入的默认state， 因为在写reducer时，不管是用if还是用switch，都需要写不符合所有条件的默认返回值， 而这个返回值就是定义的初始状态。这样在调用getState方法时，就可以得到初始状态。 如果没有传入preloadedState，那刚开始currentState就是undefined，而派发了这次dispatch就可以对其重新赋值， 也就回答了上面如果第二参数为undefined的问题 */ /* const randomString = () =&gt; Math.random() .toString(36) .substring(7) .split('') .join('.') const ActionTypes = &#123; INIT: `@@redux/INIT$&#123;randomString()&#125;`, REPLACE: `@@redux/REPLACE$&#123;randomString()&#125;`, PROBE_UNKNOWN_ACTION: () =&gt; `@@redux/PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;` &#125; */ dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState &#125;&#125; 从上面逐条代码的分析可以看出，redux的createStore内部实现原理其实并不复杂，将状态同一进行管理，当需要改变的时候，必须派发更新操作，也就是dispatch(action)，而不可以直接对state进行赋值。 在React中应用Redux实例：分析完源码，下面结合具体例子来说明一下（部分地方省略）： 1234567891011121314151617//store.jsexport const increment = () =&gt; (&#123; type: 'INCREMENT' &#125;) const initialState = &#123; num: 1 &#125;const numReducer = (state=initialState, action) =&gt; &#123; switch(action.type)&#123; case 'INCREMENT': return &#123; ...state, num: state.num+1 &#125; default: return state &#125;&#125;//这里面的initialState可不传，上面的分析可以知道，会默认派发一次action，所以还是可以得到这里的initialStateexport const numStore = createStore(numReducer, initialState) 12345678910111213141516171819202122232425262728293031323334//App.jsclass App extends React.Component &#123; constructor(props)&#123; super(props) //应用getState获取初始state，因为在createStore中默认派发一次action，得到reducer中默认返回的初始状态 this.state = numStore.getState() //监听handleChange方法，将handleChange放入nextListeners中，当有dispatch(action)时执行handleChange numStore.subscribe(this.handleChange) &#125; handleChange = () =&gt; &#123; //调用setState改变state this.setState(numStore.getState()) &#125; render()&#123; const &#123; num &#125; = this.state return ( &lt;div&gt; &lt;p&gt;&#123; num &#125;&lt;/p&gt; /* 点击按钮，派发之前定义的action，得到变化后的state，同时触发订阅的handleChange方法， 改变当前的state，最后重新执行render方法，渲染页面 */ &lt;button onClick=&#123; () =&gt; dispatch(increment()) &#125;&gt;increment&lt;/button&gt; &lt;div&gt; ) &#125;&#125; 通过一个简单的例子并结合上面的源码分析，可以清晰的知道Redux内部具体做了什么，其实再复杂的项目，内部Redux的实现都是一样的，都是像上面分析的一样。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yixirumeng.github.io/tags/redux/"}]},{"title":"React16新的context Api","date":"2018-11-06T11:23:55.000Z","path":"2018/11/06/react16-context-Api/","text":"context Api，主要用于跨组件间的数据传递，如果不用context Api，那一级组件如果要给三级组件传递数据，就会很麻烦，需要先用props传递给二级组件，二级组件再用props传给三级组件，如果再有回传也是一样的道理，一层一层的传递，这会很麻烦，如果应用context Api就会很方便。其实在React16之前的版本中，已经有context Api，但在16.3版本之后，React官方对其进行更改，使其更加方便，效率、性能都得到了提升。 用法：（部分导入导出省略）一级组件向三级组件传递数据：一级组件： 12345678910111213import React, &#123; createContext, Component &#125; from 'react'export const &#123; Provider, Consumer &#125; = createContext()class App extends Component &#123; render()&#123; return ( &lt;Provider value=&#123;&#123; title: 'hello', color: 'red' &#125;&#125;&gt; &lt;Header/&gt; &lt;/Provider&gt; ) &#125;&#125; 二级组件： 1234567class Header extends Component &#123; render()&#123; return ( &lt;Title/&gt; ) &#125;&#125; 三级组件： 1234567891011121314151617import &#123; Consumer &#125; from './App.js'class Title extends Component &#123; render()&#123; return ( &lt;Consumer&gt; &#123; context =&gt; ( &lt;h1 style=&#123;&#123; color: context.color &#125;&#125;&gt; &#123; context.title &#125; &lt;/h1&gt; ) &#125; &lt;/Consumer&gt; ) &#125;&#125; 可以看出，应用了context Api传递数据会很方便，在value中定义好就可以，不用一级一级的传递。用过react-redux会感觉很相似，其实react-redux内部的实现也是借助了context Api，只不过目前安装的版本还没有正式应用新的context Api，但已经开发出了新的版本，可以在其github仓库里找到。 三级组件向一级组件传递数据：一级组件： 123456789101112131415161718import React, &#123; createContext, Component &#125; from 'react'export const &#123; Provider, Consumer &#125; = createContext()class App extends Component &#123; this.handleClick = (val) =&gt; &#123; console.log(val) &#125; render()&#123; return ( &lt;Provider value=&#123;&#123; title: 'hello', color: 'red', handleClick: this.handleClick &#125;&#125;&gt; &lt;Header/&gt; &lt;/Provider&gt; ) &#125;&#125; 二级组件： 1234567class Header extends Component &#123; render()&#123; return ( &lt;Title/&gt; ) &#125;&#125; 三级组件： 12345678910111213141516171819202122232425262728import &#123; Consumer &#125; from './App.js'class Title extends Component &#123; btnClick = (fn) =&gt; &#123; fn('world') &#125; render()&#123; return ( &lt;Consumer&gt; &#123; context =&gt; ( &lt;div&gt; &lt;h1 style=&#123;&#123; color: context.color &#125;&#125;&gt; &#123; context.title &#125; &lt;/h1&gt; &lt;button onClick=&#123; () =&gt; this.btnClick(context.handleClick) &#125;&gt;clickA&lt;button&gt; &lt;button onClick=&#123; this.btnClick.bind(this, context.handleClick) &#125;&gt;clickB&lt;button&gt; &lt;button onClick=&#123; () =&gt; context.handleClick('hello world') &#125;&gt;clickC&lt;button&gt; &lt;button onClick=&#123; context.handleClick.bind(this, 'hello world') &#125;&gt;clickD&lt;button&gt; &lt;/div&gt; ) &#125; &lt;/Consumer&gt; ) &#125;&#125; 三级组件向一级组件传递数据，也是采用回调函数的方式传递，但应用了context Api，就不需要一级一级向上传递，直接在一级组件中定义好方法，在三级组件中应用就可以，相比较而言，简单很多。 更新context Api的原因老版本的context Api虽然在写法上不用一级一级传递，但其底层是实现还是一级一级传递数据，所以，如果某个中间组件在shouldComponentUpdate进行了优化或者限制，可能会导致下一级组件依赖的数据不会更新，同时也降低了复杂程度，提高性能。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"}]},{"title":"React16新生命周期函数getDerivedStateFromProps","date":"2018-11-01T10:44:34.000Z","path":"2018/11/01/react-getDerivedStateFromProps/","text":"React16这个版本，废弃了一些声明周期函数，同时也新增了一些生命周期函数。这一篇先说一下新增的声明周期函数getDerivedStateFromProps。 getDerivedStateFromProps作为componentWillReceiveProps的替代品出现，但是它与componentWillReceiveProps也有很多不同点 Derived State（衍生状态）当组件的props改变而引发state改变，这个state就被称为是Derived State。 1234567//parent component...render()&#123; return ( &lt;Child productId=&#123; id &#125;&gt; )&#125; 123456789101112131415//children component...constructor(props)&#123; super(props) this.state = &#123; id: '' &#125;&#125;componentDidMount()&#123; const &#123; productId &#125; = this.props this.setState(&#123; id: productId &#125;)&#125; 父组件传入的productId不同，子组件的id也会不一样，而这个id就是Derived State static functiongetDerivedStateFromProps这个生命周期函数是静态类型的，也就是说无法在其内部调用this 参数getDerivedStateFromProps(nextProps, prevState){} 它的两个参数分别是变化后的props和当前的state，因为它是静态方法，所以可以直接对state进行赋值，相当于调用setState方法，但是不管改不改变state都要有返回值，否则报错。其返回值为Object，返回null或者基本类型都相当于没有变化。 12345678getDerivedStateFromProps(nextProps, prevState)&#123; if(nextProps.productId%2 === 0)&#123; return &#123; id: productId //可以直接获取state中的key，不用根据prevState获取 &#125; &#125; return null&#125; 调用时机调用时机在16.3与16.4这两个版本有区别： 16.3：只有在props改变的时候，才会执行16.4：任何一次render之前，都会执行(new props, setState, forceUpdate) 可以看出，如果任何一次render之前都需要执行，非常耗性能，所以这个生命周期函数能不用尽量不要使用。如果必须使用，最好要有条件判断 开发时遇到的问题以及解决方案前段时间做项目的时候，遇到一个联动功能，当左侧的输入框中输入完信息后，也就是blur后右侧的下拉菜单要变为对应值，右侧是下拉菜单也是一个独立的组件： 刚开始的想法是，只要改变传入的props，然后在下拉组件内的getDerivedStateFromProps函数中设置为对应的值就可以，大致代码如下： 12345678910111213141516171819//parent componentonBlur = (e) =&gt; &#123; const defVal = e.target.value this.setState(&#123; defVal: currentVal &#125;)&#125;render()&#123; const &#123; defVal &#125; = this.state return ( &lt;div&gt; &lt;input onBlur=&#123; this.inputBlur &#125; /&gt; &lt;ChildSelect defaultVal=&#123; defVal &#125; /&gt; &lt;/div&gt; )&#125; 12345678910111213141516171819202122232425262728293031323334353637//ChildSelectconstructor(props)&#123; super(props) this.state = &#123; defaultVal: '' &#125;&#125;getDerivedStateFromProps(nextProps)&#123; if(nextProps.defaultVal !== defaultVal)&#123; return &#123; defaultVal: nextProps.defaultVal &#125; &#125; return null&#125;selectOnChange = (val) =&gt; &#123; const &#123; sendVal &#125; = this.props this.setState(&#123; ... //其它功能 &#125;) sendVal(val) //向父组件发送数据&#125;render()&#123; const &#123; defaultVal &#125; = this.state return ( &lt;Select defaultValue=&#123; defaultVal &#125; onChange=&#123; this.selectOnChange &#125;&gt; &lt;Option value=\"A\"&gt;A&lt;/Option&gt; &lt;Option value=\"B\"&gt;B&lt;/Option&gt; &lt;Option value=\"C\"&gt;C&lt;/Option&gt; &lt;/Select&gt; )&#125; 看起来没什么问题，但是这样写会很麻烦，需要控制两个组件，而且在selectOnChange方法内有setState，这样每次选择选项的时候，都要走一遍getDerivedStateFromProps方法，虽然做了判断处理，但也相当于是无用的操作。如果以后扩展的功能里需要改变上面的defaultVal，那里面涉及的问题会更多。 React官网的建议是，用key值来代替getDerivedStateFromProps方法，也就是如果key改变了，子组件也会重新渲染，这样就不用在子组件内判断props来改变状态。 更改后的代码： 12345678910111213141516171819//parent componentonBlur = (e) =&gt; &#123; const defVal = e.target.value this.setState(&#123; defVal &#125;)&#125;render()&#123; const &#123; defVal &#125; = this.state return ( &lt;div&gt; &lt;input onBlur=&#123; this.inputBlur &#125; /&gt; &lt;ChildSelect key=&#123; defVal &#125; defaultVal=&#123; defVal &#125; /&gt; &lt;/div&gt; )&#125; 123456789101112131415161718192021//ChildSelectselectOnChange = (val) =&gt; &#123; const &#123; sendVal &#125; = this.props this.setState(&#123; ... //其它功能 &#125;) sendVal(val) //向父组件发送数据&#125;render()&#123; const &#123; defaultVal &#125; = this.props return ( &lt;Select defaultValue=&#123; defaultVal &#125; onChange=&#123; this.selectOnChange &#125;&gt; &lt;Option value=\"A\"&gt;A&lt;/Option&gt; &lt;Option value=\"B\"&gt;B&lt;/Option&gt; &lt;Option value=\"C\"&gt;C&lt;/Option&gt; &lt;/Select&gt; )&#125; 父组件增加了key，其值为defVal，子组件内获取到props进行设置，当defVal变化后，子组件重新渲染，而当选择子组件的选项时，也不会受到影响，同时也具有可扩展性。 总结虽然新增的声明周期钩子函数代替之前版本的函数，但里面也有很多不可避免的问题，所以还是那句话，也是React官方的建议，getDerivedStateFromProps是不常用的声明周期函数，如果不是必须，还是不要随意使用，否则可能是在滥用Derived State。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"}]},{"title":"Vue2.x侦听属性watch的过程分析","date":"2018-10-25T13:41:33.000Z","path":"2018/10/25/vue2-watch-analysis/","text":"Vue2.x中watch的内部原理主要也是应用了响应式原理中不可缺少的一部分watcher，只不过这个watcher区别于之前讲述的watcher，这个是用户自定义的userWatcher，下面来分析下侦听属性watch整体实现的过程： 12345678910111213141516171819202122232425262728function initWatch (vm: Component, watch: Object) &#123; for (const key in watch) &#123; const handler = watch[key] if (Array.isArray(handler)) &#123; for (let i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]) &#125; &#125; else &#123; createWatcher(vm, key, handler) &#125; &#125;&#125;function createWatcher ( vm: Component, expOrFn: string | Function, handler: any, options?: Object) &#123; if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; if (typeof handler === 'string') &#123; handler = vm[handler] &#125; return vm.$watch(expOrFn, handler, options)&#125; Vue先会遍历所有定义在watch中的属性，而属性的值可以是数组（上篇文章提到的当一个数据需要多次监听），如果是数组，则再进一步遍历，然后调用createWatcher方法，在createWatcher方法中会做一些Object、String的判断，最后会调用$watch方法，并传入相关的参数。 $watch源码： 12345678910111213141516171819Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object): Function &#123; const vm: Component = this if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125; options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) &#123; cb.call(vm, watcher.value) &#125; return function unwatchFn () &#123; watcher.teardown() &#125;&#125; 从源码上来看，$watch的实现也很简单，首先会判断传入的handler也就是上面的cb是不是Object，如果是的话，会递归调用createWatcher方法，正常在开发过程中watch的值的回调函数就是这里的cb，最终会根据相关的参数new一个新的watcher，而这个watcher是一个userWatcher，因为有options.user = true这段代码。这样就初始化好了一个userWatcher watcher的相关源码： 123456789101112131415161718192021222324252627282930313233343536373839404142update () &#123; if (this.computed) &#123; if (this.dep.subs.length === 0) &#123; this.dirty = true &#125; else &#123; this.dep.notify() &#125;) &#125; &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125;run () &#123; if (this.active) &#123; this.getAndInvoke(this.cb) &#125;&#125;getAndInvoke (cb: Function) &#123; const value = this.get() if ( value !== this.value || isObject(value) || this.deep ) &#123; const oldValue = this.value this.value = value this.dirty = false if (this.user) &#123; try &#123; cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; cb.call(this.vm, value, oldValue) &#125; &#125;&#125; 当watch的数据有变化的时候，会执行Object.defineProperty的set方法，使得订阅者Dep通知所有存储在其中的watcher，并执行其中的update方法，update会走到queueWatcher(this)，最终会走到watcher的run方法（内部实现复杂，涉及到nextTick，但最终还是会走入到run方法中），接着进入到getAndInvoke方法中。 分析一下getAndInvoke方法，首先会拿到新的值，并与之前的值进行判断，如果不一样，则进入到下面的逻辑中。因为在之前已经定义了是个userWatcher，所以会进入到if中，执行cb.call(this.vm, value, oldValue)，这里的cb就是我们定义的回调函数，它改变this指向到当前组件，同时将新的value和旧的value传入（这也就是我们能在方法中获取到新旧值的原因），然后执行这个回调函数。 经过以上分析，侦听属性watch的整体过程还是相对简单的。下面根据一个具体例子来说一下过程： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &#123;&#123; message &#125;&#125; &lt;button @click=\"changeMsg\"&gt;change&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; message: 'hello' &#125; &#125;, methods: &#123; changeMsg()&#123; this.message = 'world' &#125; &#125;, watch: &#123; message(newVal, oldVal)&#123; console.log(newVal) console.log(oldVal) &#125; &#125; &#125;&lt;/script&gt; 1、初始化的时候，先用Object.defineProperty转换message，之后会通过上述所讲的初始化一个message的userWatcher，而这里定义在watch中的回调函数将作为handler传入，也就是后面的cb 2、当点击按钮的时候，message发生了改变，会调用其中的set方法，从而走入到userWatcher中的update方法中 3、update最后进入到getAndInvoke中，首先会拿到新值，然后对比旧值，因为hello与world不相等，继续执行 4、因为这个watcher是一个userWatcher，所以会进入到内层的if中，执行cb.call(this.vm, value, oldValue) 5、此时的this.vm是当前的组件，value是world对应回调函数中的参数newVal，oldValue是hello对应回调函数中的参数oldVal，所以可以将两个值console出 扩展在定义侦听属性的时候，可以传入一些参数，deep、sync、immediate immediate从刚开始给出的源码中可以看出，在new一个userWatcher之后，有个条件判断options.immediate，如果为真，则执行cb.call(vm, watcher.value)，watcher.value即获取监听属性的值，所以，如果设置immediate为true，就是在初始化的时候执行一次，会马上获取到监听属性的值，对应刚才的例子，则是获取到hello sync在上面最后给的一段源码中的update方法中，可以找到sync的判断条件，会执行run方法，走之后的逻辑，其实设置了这个参数为true的时候，将不会走queueWatcher中，也就是说不会涉及到nextTick（nextTick是个异步的过程），最终会同步执行cb，所以只有在watch的值的变化到执行watcher的回调函数是一个同步过程的时候才会去设置该属性为 true deep设置deep: true是为了观察到深层的变化，可以在watcher中的get方法中看出，下面是get方法的源码： 1234567891011121314151617181920212223get () &#123; pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher \"$&#123;this.expression&#125;\"`) &#125; else &#123; throw e &#125; &#125; finally &#123; // \"touch\" every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value&#125; 当deep为true时，执行traverse(value)，其实traverse的内部则是进一步遍历，直到不能在遍历为止 所以，当要观察的属性是对象、数组等值时，则需要设置该属性，因为正常引用类型的对比是对比内存地址。但是，如果是观察的是基本类型的值，不要设置，因为深层遍历会耗性能，虽然Vue已经做了优化，但只是在做判断，还是会执行一些没必要的代码，所以还是不要设置的好。 总结以上就是有关于watch的所有内容，整个watch的过程相对来说并不复杂，但内部也有很多需要注意的地方，了解了内部的原理对正常的开发会有很大的帮助。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"}]},{"title":"简述Vue2.x中computed相互调用，以及watch中同一属性多次监听","date":"2018-10-16T12:51:08.000Z","path":"2018/10/16/vue2-computed-mutual-call-and-more-watch/","text":"平时在开发的时候，在需要做数据计算的时候，会用computed计算属性，但是在computed中的某一属性是否可以调用另一属性呢？在应用侦听属性watch的时候，如何对同一属性进行多次侦听呢？ computed相互调用通过上一篇文章的分析，可以了解到computed其中的内部实现原理，即： 在初始化的时候，创建订阅者Dep，并应用Object.defineProperty对computed中计算属性进行转换拦截，定义的方法作为该属性的get方法，同时在方法内部创建观察者computedWatcher。当被render方法调用的时候，订阅renderWatcher，放入自身的Dep中，而在computed中调用的其它数据，也会执行一样的操作。 从这就可以看出，computed的实现原理与data数据基本类似，都是应用了响应式原理的三个主要特性，Object.defineProperty、Dep、Watcher，所以在computed中也是可以相互调用的，就像调用data数据一样，其内部实现原理也是同样执行上面说的。 举例说明一下： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &#123;&#123; message &#125;&#125; &lt;p&gt;&#123;&#123; newMessage1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; newMessage2 &#125;&#125;&lt;/&gt; &lt;button @click=\"changeMessage\"&gt;change&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; message: 'hello' &#125; &#125;, computed: &#123; newMessage1()&#123; return this.message + ' world' &#125;, newMessage2()&#123; return this.newMessage1 + '!' &#125; &#125;, method: &#123; changeMessage()&#123; this.message = 'hi' &#125; &#125; &#125;&lt;/script&gt; 首次渲染的时候，页面上的显示分别为hello、hello world、hello world!，当点击按钮后，页面上的显示会变为hi，hi world，hi world! watch中同一属性多次监听正常开发时，当某一属性发生变化时，要执行某操作会用到watch，如果想执行多种操作的时候，该怎么办呢？其实看一下Vue的源码就能轻松知道。 先贴一下Vue的相关源码： 12345678910111213141516171819202122232425262728function initWatch (vm: Component, watch: Object) &#123; for (const key in watch) &#123; const handler = watch[key] if (Array.isArray(handler)) &#123; for (let i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]) &#125; &#125; else &#123; createWatcher(vm, key, handler) &#125; &#125;&#125;function createWatcher ( vm: Component, expOrFn: string | Function, handler: any, options?: Object) &#123; if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; if (typeof handler === 'string') &#123; handler = vm[handler] &#125; return vm.$watch(expOrFn, handler, options)&#125; 从上面的源码中可以看出，在定义watch的时候，不止能定义单一的侦听函数，还能定义数组，数组中的每个元素可以为对象，在对象内定义要执行的侦听函数。 还是举例说明一下： 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &#123;&#123; message &#125;&#125; &lt;button @click=\"changeMessage\"&gt;change&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; message: 'hello' &#125; &#125;, watch: &#123; message: [ &#123; handler()&#123; console.log('message is changed') &#125; &#125;, &#123; handler()&#123; console.log('new message output') &#125; &#125; ] &#125;, methods: &#123; changeMessage()&#123; this.message = 'world' &#125; &#125; &#125;&lt;/script&gt; 当点击按钮后，在控制台会输出message is changed，new message output。 这里要注意的是，在写数组中对象的时候，定义的方法的key值，必须为handler，这一点从源码中可以看出。当然在对象内部也可以定义deep等其它属性。如果只有一个对象的时候，也可以不用数组包围，直接定义，但同样的要用handler作为侦听函数的key值。 总结平时在实际开发中，以上的操作可能应用不会很多。但是在通过阅读源码之后就能了解到其底层的实现原理，以及一些其它的定义方式，这样不管开发还是学习都能有不断的提升。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"}]},{"title":"从渲染以及内在执行过程角度阐述Vue2.x中data与computed的原理","date":"2018-10-13T14:08:17.000Z","path":"2018/10/13/vue2-data-computed/","text":"网上已经有很多文章结合源码叙述了Vue框架中data与computed的实现原理，但大多都是在源代码的基础上进行讲解，对于没有仔细读过源码的同学来说，理解起来会有些费劲。这篇文章会从这两者的渲染以及内部执行过程来阐述内在原理。（注：不会过于分析源代码，想根据源码理解的，请阅读相关的文章） Object.definePopertyObject.defineProperty这个相信大家都知道，它是Vue实现响应式的核心方法，也是Vue不兼容ie8及以下浏览器的主要原因。在这个方法里可以定义get、set方法（类似Java），以此来取值和赋值。Vue在初始化的时候，会将普通对象中的数据，用这个方法进行转换。 WatcherWatcher即观察者，区别于Vue中的watch API，它是底层封装一个类。Vue中的任何操作都是基于数据的，每当render渲染、数据被访问等时候，都会创建Watcher，其主要作用就是观察数据的变化，并根据变化来进行及时的响应。 DepDep即订阅者，它也是底层封装的一个类。Vue在用Object.definePoperty方法转换普通对象数据的时候，都会创建Dep，其作用是，当某个操作运用了数据的时候，就会将这一操作的watcher存储其中，也就是所说的依赖收集。如果数据发生了改变，就会通知所有存过的watcher，让它们进行更新操作。 以上这三者，是Vue响应式的核心，理解它们对理解Vue至关重要。而Vue中的data和computed的实现，也都是应用了它们。 下面分别对data、computed\b的过程进行简要描述，可以理清它们的实现\b\b过程与\b响应式原理 data12345678910111213141516171819&lt;template&gt; &lt;div&gt; &#123;&#123; msg &#125;&#125; &lt;button @click=\"changeMsg\"&gt;change&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data()&#123; return &#123; msg: 'hello' &#125; &#125;, method&#123; changeMsg()&#123; this.msg = 'world' &#125; &#125;&#125; 根据这个例子，来说下当data被访问或更新的时候，\b其实现的过程： 1、当初始化的时候，应用Object.defineProperty\b将data中的数据进行转换，创建Dep订阅者，并设置get、set方法 2、组建创建模板template的时候，会执行render方法，并创建render\bWatcher观察者 3、在render方法访问data中的数据msg时，会执行get方法，在get方法中msg进行依赖收集，也就是将\brenderWatcher存入到Dep中。执行完\b收集的操作后，将数据返回给render方法，供render渲染。 4、当点击change按钮的时候，会改变msg数据，执行set方法进行数据更改。在set方法中，会让Dep通知所有\b存储的watcher进行更新。此时\b存储的是renderWatcher，而renderWatcher接受到通知后，会重新执行渲染方法来渲染组件。 computed其实computed与data类似，也会讲其中的属性应用Object.defineProperty\b进行转换，而定义在计算属性的函数，而这个函数会作为这一属性的get方法，举例说明一下： 123456789101112131415computed &#123; newMsg()&#123; return this.msg + 'world' &#125;&#125;或者computed &#123; newMsg: &#123; get()&#123; return this.msg + 'world' &#125; &#125;&#125; 在初始化的时候，会将用Object.defineProperty\b将newMsg进行转换，同时把上面定义函数作为newMsg的get方法，当然也会在get方法中设置对应的观察者watcher 下面再来根据例子来说明一下，当data中的数据进行访问和更新时，整体的实现过程： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &#123;&#123; msg &#125;&#125; &lt;p&gt;&#123;&#123; newMsg &#125;&#125;&lt;/p&gt; &lt;button @click=\"changeMsg\"&gt;change&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data()&#123; return &#123; msg: 'hello' &#125; &#125;, computed: &#123; newMsg()&#123; return this.msg + ' world' &#125; &#125;, method: &#123; changeMsg()&#123; this.msg = '你好' &#125; &#125;&#125; 初始化的时候，会将data和computed中的数据运用Object.defineProperty\b进行转换，\b都创建各自的Dep，\bdata中的数据会设置get、set方法，computed中的函数作为其属性的get方法。 组建创建模板template的时候，会执行render方法，并创建render\bWatcher观察者。 在render方法访问到data中的数据时，会执行msg的get方法，在get方法中msg进行依赖收集，将renderWatcher\b存入msg\b的Dep中。执行完操作后，将数据返回给render，供其渲染。 在render方法访问到computed中的newMsg时，会执行newMsg的get方法，在get方法中newMsg进行依赖收集，将renderWatcher存入newMsg的Dep中。 newMsg的get方法中，会访问data中的msg，执行msg的get方法，在msg的get方法中msg会进行依赖收集，将newMsgWatcher存入msg的Dep中，并将数据返回给newMsg newMsg拿到msg\b的数据后，进行字符串拼接，将结果返回\b给render方法供其渲染 点击change按钮的时候，会执行msg的set方法设置数据，并让Dep通知所有存储的watcher进行更新。此时的watcher有renderWatcher和newMsgWatcher，renderWatcher会重新渲染\btemplate中的msg，而newMsgWatcher会通知computed中的newMsg。 newMsg接收到通知后，会重新拼接字符串，并让其Dep通知所有存储的watcher进行更新。此时的watcher只有renderWatcher，renderWatcher会重新渲染template中的newMsg。 整体渲染过程结束。（Vue\b当然不会一个一个进行渲染，它在底层做了复杂的逻辑算法，提高整体的性能，此处单独\b说明是为了叙述清楚，） 通过以上的过程\b分析，可以明白Vue中的data、computed都是基于前面提到的三者实现的，其核心原理都是一样的，所以理解好这三点，就可以轻松理解Vue响应式的整个过程。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"}]},{"title":"分析React、Vue组件为什么必须只能有一个根元素","date":"2018-10-08T11:22:18.000Z","path":"2018/10/08/react-and-vue2-component-single-root/","text":"为什么平时在开发react或者vue组件写jsx或者template的时候，框架都要求必须只能有一个根元素？现在就来分析一下 其实，这个要求在react和vue中的原理是一样的，分别举例说明一下： React平时定义组件的时候我们都会这样写： 12345678910class App extends React.Component &#123; render()&#123; return ( &lt;div&gt; &lt;h1 className=\"title\"&gt;我是标题&lt;/h1&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 组件中的render函数中的jsx最终会被编译成React元素的形式： 12345678910class App extends React.Component &#123; render()&#123; return React.createElement( 'div', null, [React.createElement('h1', &#123; className: 'title' &#125;, '我是标题'), React.createElement('p', null, '我是内容')] ) &#125;&#125; Vuevue在定义组件template的时候，会是如下写法： 123456&lt;template&gt; &lt;div&gt; &lt;h1 class=\"title\"&gt;我是标题&lt;/h1&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 而vue的template模板最终也会被编译为render函数，即： 123456789101112131415161718render(createElement)&#123; return createElement( 'div', null, [createElement( 'h1', &#123; class: 'title' &#125;, '我是标题' ), createElement( 'p', null, '我是内容' )] )&#125; 通过这两个例子可以看出，不管是vue还是react，模板都将被编译为render函数，而函数的返回值只能是一个，所以如果不用单独的根节点包住，就会并列返回多个返回值，这在js中是不允许的。 除了这一点，还有一个主要是原因是，react和vue都将把模板的内容转换为对应的元素，最后建立起虚拟dom树，而树状结构只能有唯一的根节点，这样在后续的虚拟dom数据有变化时，可以检查到具体更改额位置。如果有多个根节点，则不能明确到底要在哪个树上查找更新。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"}]},{"title":"为什么定义组件的时候必须要导入React","date":"2018-10-06T06:36:13.000Z","path":"2018/10/06/why-compoments-must-import-react/","text":"在用react开发时，为什么要先导入React（即：import React from &#39;react&#39;）呢？但在组件内部并没有使用？ 可能有人会说在创建组件的时候，需要用到React中的Component组件，但完全可以用import { Component } from &#39;react&#39;这种方式 其实最主要的原因并不是上述所说的，根本原因是JSX 先写个例子，写一个非常简单的组件： 123456789import React, &#123; Component &#125; from 'react'class App extends Component &#123; render()&#123; return &lt;div&gt;这是App组件&lt;/div&gt; &#125;&#125;export default App 在编译时，组件内部的JSX会调用React.createElement方法创建React元素： 12345class App extends Component &#123; render()&#123; return React.createElement('div', null, '这是App组件') &#125;&#125; 所以，在定义组件时必须要导入React因为在编译JSX时，需要用到React.createElement方法，而JSX本质则是React创建元素的语法糖。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"}]},{"title":"Javascript面试题 —— setTimeout+promise经典面试题分析（弄懂Js执行机制Event Loop）","date":"2018-09-29T16:35:18.000Z","path":"2018/09/30/javascript-interview-run-mechanism/","text":"在网上看JS面试题的时候，经常会遇到以下这个题目，会问这段代码的执行结果： 12345678910111213141516171819console.log(1)setTimeout(() =&gt; &#123; console.log(2)&#125;, 0)new Promise((resolve, reject) =&gt; &#123; console.log(3) for(let i=0; i&lt;1000; i++)&#123; if(i === 999)&#123; resolve() &#125; &#125; console.log(4)&#125;).then(() =&gt; &#123; console.log(5)&#125;)console.log(6) 当然网上肯定也会有解答，但大多数都分析的不够彻底。现在就来彻底分析以下： 其实如果理解了在浏览器端JS的执行机制，就能很轻松的答对这道题目，而且再遇到类似的问题，也都不会害怕。 1、首先要记住一个核心概念：javascript是单线程语言，所谓单线程就是事情要一个一个顺序执行，如果前一个任务执行时间过长，后一个任务只能等待前一个任务执行完毕后，才可以执行举例说一下：夜间去火车站买票，因为客流量少，只有一个售票窗口，大家都在排队买票，第一位乘客直接说要一张6点北京到上海的硬座车票，售票员很快就能将票打印出，乘客拿着票开心走了；第二位乘客说要一张7点北京到广州的卧铺，售票员需要问要哪个位置的，乘客说要下铺，售票员知道后打印了车票，这就比第一位乘客花的时间多了；第三位乘客说要一张北京到西安的车票，售票员需要问时间、座位类型、卧铺位置等等的，明确之后才能打印车票，这花费的时间就更多了。后面的乘客必须要等到前面的乘客买完后才能去买，即使前一位花了好长时间。 2、javascript的事件循环浏览器如果都按着刚才例子的方式执行，当用户浏览到有图片的网站时，要等到图片加载完毕才能进行其它操作，就会损失很多用户。为了解决这个问题，就有了任务分类： 同步任务 异步任务 打开网站的时候，网页的渲染过程就是同步任务，而ajax数据获取、图片、视频等资源大加载慢的任务，就是异步任务。它们在执行的时候会有区别，分为以下几个过程： 同步任务进入到主线程中，马上执行 异步任务首先进入到事件表（Event Table）中，并注册回调函数 当异步的事件执行完毕后，Event Table会将其回调函数移送到事件队列中（Event Queue），等待执行 当主线程中的任务都执行完毕为空的时候，就会去Event Queue中读取对应的回调函数，并放入到主线程中执行 不断重复以上的过程，也就是事件循环（Event Loop） 注意点：setTimeout、setInterval平时都会说是过多长时间后执行，其实内在的原理是，遇到它们的时候，它们会进入事件表Event Table中，等过多长时间后，再将其回调函数移送到事件队列Event Queue中。还有就是，即使将时间设置为0，也不会存在完全的0ms，js最低时间为4ms 扩展：js引擎存在monitoring process进程，会持续检查主线程是否为空，如果为空，会马上去Event Queue中检查是否有等待被调用的函数 理解这两个概念之后，相信可以明白网上说的对题目的这段解释： 先输出1、3、4、6，因为这些任务都是同步执行的（new Promise是立即执行的，也是同步任务） 执行完毕之后再执行异步任务 但setTimeout和promise中的then都是异步执行的，应该先输出哪个呢？ 3、除了广义的同步任务与异步任务外，这里又引入了对任务更精细的定义： macro-task(宏任务)：包括script、setTimeout、setInterval等 micro-task(微任务)：包括Promise、ajax等 这两个不同的任务，会进入到不同的Event Queue，比如setTimeout和setInterval会进入到相同的Event Queue，但setTimeout和Promise则会进入到不同的Event Queue js的事件循环顺序是，每一次循环都是先执行宏任务，然后再执行微任务。即第一次执行完所有的宏任务，接着执行所有的微任务，第一次循环结束；第二次循环依然是先执行完所有的宏任务，接着执行所有的微任务。但是还有一个注意点，如果是宏任务，会新建一个任务队列，任务队列中的宏任务有多个来源；如果是微任务，则直接放入微任务队列。 所以，事件循环可以归纳为以下的步骤： 全局任务script属于宏任务，所以最先执行，也就相当执行所有的同步任务，执行完之后，开始执行微任务 微任务队列中的任务都执行完后，读取宏任务队列中拍在最前面的宏任务 执行宏任务过程中，遇到微任务，会将其加入到微任务队列 执行完宏任务之后，继续读取微任务执行。依此类推 现在就可以完整的理解这道面试题了，仔细分析一下： 整体代码都在script标签之内包裹着，作为宏任务进入到主线程中 遇到console.log(1)的时候，马上执行输出1 遇到setTimeout的时候，会将其回调函数注册，过4ms后移送到宏任务Event Queue中 遇到Promise，由于new Promise是立即执行的，这就输出了3、4， Promise属于微任务，所以把then函数放到微任务Event Queue中 遇到console.log(6)，又会马上执行，输出6 此时第一次循环的宏任务全部执行完毕，开始执行微任务，在微任务Event Queue中发现了console.log(5),输出5 由于第一次循环的宏任务与微任务全部执行完毕，开始进入第二次循环 第二次循环还是先执行宏任务，在宏任务Event Queue中发现了console.log(2)，输出2 现在已经没有其它任务了，整执行结束，所以最终结果是1、3、4、6、5、2 1、明白了javascript的执行机制，是不是做出这道题来就很简单了。再来看一道经典的题目： 1234567891011121314console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 其实和之前的题目很类似，只不过用了Promise.resolve方法，用过的同学应该知道，这是new Promise中resolve的语法糖。所以这道题和上一道题的分析过程一样，注意一点就是，题目中有两个then方法，这两个都要放到微任务Event Queue中。而在当前的循环中，不管是宏任务还是微任务，都是要执行Queue中的所有任务。记住了就能知道结果： 1234561、script start2、script end3、promise14、promise25、setTimeout 明白了javascript的执行机制，再遇到相似的题目，只要按着以上的逻辑逐行代码分析，就能很轻松的得到正确的答案。 2、接下来看一道宏微任务相互结合的题目： 123456789101112131415161718console.log(1)setTimeout(() =&gt; &#123; console.log(2) Promise.resolve().then(() =&gt; &#123; console.log(3) &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log(4)&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log(5)&#125;)console.log(6) 这道题里，别的地方和之前的题目没有什么差别，主要不同的地方是在第一个setTimeout，在其内部又有一个promise的then方法，所以这是宏任务与微任务结合的题目，记住上面加粗的那句话以及事件循环执行顺序，就可以判断出，当执行第一个setTimeout时，里面又有微任务，将其放入微任务队列，执行完这个宏任务，就会开始去读取微任务队列并执行，而不会先执行第二个setTimeout，因为这个宏任务会新建任务队列，所以要等微任务执行完之后，再开始执行第二个setTimeout，所以结果为1 6 5 2 3 4 如果把第一个setTimeout的等待时间改为2000，那结果则是1 6 5 4 2 3，别忘了是先取排在前面的宏任务 3、最后再看一道题目： 12345678910111213141516171819202122232425console.log(1)setTimeout(() =&gt; &#123; console.log(2)&#125;, 100)new Promise((resolve, reject) =&gt; &#123; console.log(3) resolve()&#125;).then(() =&gt; &#123; console.log(4) setTimeout(() =&gt; &#123; console.log(5) &#125;, 0)&#125;)$.ajax(&#123; type: 'GET', url: ajaxUrl, success: (data) =&gt; &#123; //40ms后拿到数据 console.log(6) &#125;&#125;)console.log(7) 分析： 所有代码都在script标签中，整体当做宏任务，移送到主线程中 遇到console.log(1)，先输出1 遇到setTimeout，会将其回调函数注册，过100ms后移送到宏任务Event Queue中 遇到Promise，立即执行new Promise里的任务，输出3 Promise的then放到微任务Event Queue中 遇到微任务ajax，放到微任务Event Queue中 遇到console.log(7)，输出7。此时第一轮的宏任务已经全部执行完毕，开始执行微任务 在微任务队列中，拿到then，先遇到console.log(4)，输出4，又遇到setTimeout，将其回调注册，过4ms后移送到宏任务Event Queue中 拿到到ajax，遇到console.log(6)，输出6。到此为止，第一轮已经全部执行完毕，开始执行下一轮 还是先执行宏任务，在宏任务队列中，遇到两个setTimeout，由于then中的setTimeout会先推入Event Queue中，所以会先输出5，之后再输出2 注意点：then中的setTimeout是0ms（也就是4ms）后放入宏任务Event Queue中，但ajax是40ms后放入微任务Event Queue中，虽然setTimeout快，但是由于ajax是微任务，而每次事件循环都是要执行完微任务再开始下一轮，所以即使ajax慢，也要等到执行完，才会执行下一轮宏任务的setTimeout 最后的最后，一定要记住以下几点： javascript是单线程语言 Event Loop是javascript的执行机制 分清楚宏任务与微任务，记住每次Event loop都是要执行当前所有的宏任务与微任务 上面加粗说明的事件循环执行过程 注意：以上只是针对在browser即浏览器中的js，而在node中的执行机制是不同的。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://yixirumeng.github.io/tags/javascript/"}]},{"title":"react-router4自定义prompt组件，以及在redux或mobx中应用","date":"2018-09-15T16:35:18.000Z","path":"2018/09/16/react-router4-prompt-custom-md/","text":"react-router4提供了prompt组件，用于在路由改变之前触发确认框，点击确认可以进行跳转，点取消可以取消跳转保持在当前路由内。它底层的实现应用了原生JS的confirm，弹出的效果也跟confirm一样，但在日常的开发中，这种confirm效果肯定不是我们想要的，但也无法通过CSS来修改，不过仔细阅读一下react-router4的官方文档，可以知道在根路由上有getUserConfirmation事件，在这个事件中就可以控制prompt。 在应用react-router4定义路由的时候，在根路由组件上定义一下getUserConfirmation方法，这个方法有两个参数，分别是message、callback，其中message是传递给prompt组件的message的值，而当执行callback(true)时，相当于点击确认按钮，执行callback(false)时，相当于点击取消按钮。 12345678&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125;&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;ComponentMain&#125;/&gt; &lt;Route path=\"/AAA\" component=&#123;ComponentA&#125;/&gt; &lt;Route path=\"/BBB\" component=&#123;ComponentB&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/CCC\" component=&#123;ComponentC&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt;&lt;/BrowserRouter&gt; 在定义getConfirmation函数的时候，要注意此函数返回一个自定义的组件，而这个组件不能加载到root的根div上，需要在index.html中再定义一个div，将自定义的组件挂载到这个div上，否则就会替换掉root上的所有内容。其主要原理是，只有在我们需要的时候，才会显示这个组件，不需要的时候，不要显示。 123456789101112131415161718192021222324252627282930313233343536373839getConfirmation = (message, callback) =&gt; &#123; class ConfirmComponent extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; visible: true &#125; &#125; confirmOnChange = () =&gt; &#123; this.setState(&#123; visible: false &#125;) callback(true) &#125; cancelOnChange = () =&gt; &#123; this.setState(&#123; visible: false &#125;) callback(false) &#125; render()&#123; const &#123;visible&#125; = this.state return ( &lt;div&gt; &lt;Modal title=&#123;message&#125; visible=&#123;visible&#125; onOk=&#123;this.confirmOnChange&#125; onCancel=&#123;this.cancelOnChange&#125;&gt; &lt;/Modal&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;ConfirmComponent /&gt;, document.getElementById(\"root1\") )&#125; 这里为了方便应用了antd的Modal组件，其实也可以自定义样式。以上的方法定义完之后，只要再需要的地方应用一下prompt组件，就可以直线跳转之前拦截。简单写一下代码： 1234567891011121314class ComponentA extends Component &#123; constructor(props)&#123; super(props) &#125; render()&#123; &lt;div&gt; &lt;Prompt message=\"确定跳转吗？\" when=&#123;urlChangeShowModal&#125;&gt; &lt;div&gt; ........ &lt;/div&gt; &lt;/div&gt; &#125;&#125; 通过props和state控制一下urlChangeShowModal的真假，就可以实现路由改变之前的确认提示。其实以上的内容在简书里也有类似的文章，但是在实际的开发中，会应用到状态管理，像redux、mobx等工具，那如何在应用这些工具的时候，再进行控制呢？ 正常在开发中我们会在入口文件index.js中，采用react-redux或者mobx-react中的Provider来使得在任意组件中都能拿到想要的数据，其实在我们刚才自定义的确认框组件中也是一样应用，不过有个注意点，确认框中用的store不能直接引入项目中的store，而是要使用与入口文件中一样的store，否则状态就会不统一，那边改变了，这边还时初始化的数据。这里我使用的是mobx，redux也是一样的道理 1234567891011入口文件index.jsexport const stores = &#123; store: new Store()&#125;ReactDOM.render( &lt;Provider &#123;...stores&#125;&gt; &lt;App/&gt; &lt;/Provider&gt;) 更改一下上面写的自定义的Prompt组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123;stores&#125; from '../index.js' getConfirmation = (message, callback) =&gt; &#123; @inject(['store']) @observer class ConfirmComponent extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; visible: true &#125; &#125; confirmOnChange = () =&gt; &#123; this.setState(&#123; visible: false &#125;) this.props.store.changeUrlChangeShowModal(false) callback(true) &#125; cancelOnChange = () =&gt; &#123; this.setState(&#123; visible: false &#125;) this.props.store.changeUrlChangeShowModal(false) callback(false) &#125; render()&#123; const &#123;visible&#125; = this.state return ( &lt;div&gt; &lt;Modal title=&#123;message&#125; visible=&#123;visible&#125; onOk=&#123;this.confirmOnChange&#125; onCancel=&#123;this.cancelOnChange&#125;&gt; &lt;/Modal&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Provider &#123;...stores&#125;&gt; &lt;ConfirmComponent /&gt; &lt;/Provider&gt;, document.getElementById(\"root1\") )&#125; 这样在ComponentA组件中，如果用mobx的changeUrlChangeShowModal方法来控制urlChangeShowModal的true或false，同样可以实现路由跳转确认提示。 以上就是自定义Prompt组件，以及在redux或者mobx中应用的所有内容。 在实际的开发中，还遇到了一个问题，就是应用了antd组件实现左侧菜单的时候，菜单传递了组件的url，但是当Prompt中的when为true的时候，点击当前页面的菜单，还是会弹出确认提示框，但此时路由的url和菜单的url是一样的，并未发生跳转，为什么还会执行Prompt提示呢？研究了好久，感觉应该是菜单上定义的url会替换当前的url，只是替换前后是一样的。 但这种效果并不是想要的，因为在当前的页面上，点击当当前页面的菜单，还会提示，不合理，所以需要进一步更改，但试了很多办法，都不能达到想要的效果，最后应用了一个暴力的解决方案：（还是应用上面的例子） 123451、用window.location.href获取当前的url2、如果url.includes(\"AAA\")为true的时候，让该url下的子菜单不设置路由跳转的参数，其它的菜单则设置3、如果为false的时候，这都设置 这样可以实现想要的效果，不过感觉这种方案并不完美，但目前还没想要其它办法，如果尝试到更好的办法会进一步补充。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"react","slug":"react","permalink":"http://yixirumeng.github.io/tags/react/"}]},{"title":"Promise then中拦截错误与catch的区别","date":"2018-08-18T09:56:52.000Z","path":"2018/08/18/promise-then-second-param-md/","text":"Promise中的then接收两个函数，第一个函数的参数为成功的结果，也就是resolve的值，第二个函数中的参数为失败的结果，也就是reject的值，同时如果失败了，也能从catch中获取到结果，都能获取错误信息，那两者有什么区别呢？ 其实简单一句话就是，catch不仅能获取到promise中的错误，同时也能获取到then第一个函数中的错误，而第二个函数拦截到的错误信息，只能是promise本身的错误代码简单解释一下 12345678910111213new Promise((resolve, reject) =&gt; &#123; let num = Math.random()*2 if(num &lt; 1)&#123; resolve('200 success') &#125;else&#123; reject('sorry timeout') &#125;&#125;).then((res) =&gt; &#123; console.log(\"成功了 \" + res) throw new Error('haha error')&#125;, (err) =&gt; &#123; console.log(\"失败了 \" + err)&#125;) 当num&lt;1时，会打印出“成功了 200 success”，当num&gt;1时，会打印出“失败了 sorry timeout”，如果这样写，无论什么时候，都不会打印出then第一个函数里throw出来的错误 如果把代码换成这样 12345678910111213new Promise((resolve, reject) =&gt; &#123; let num = Math.random()*2 if(num &lt; 1)&#123; resolve('200 success') &#125;else&#123; reject('sorry timeout') &#125;&#125;).then((res) =&gt; &#123; console.log(\"成功了 \" + res) throw new Error('haha error')&#125;).catch((err) =&gt; &#123; console.log(\"失败了 \" + err)&#125;) 当num&lt;1时，不仅能打印出“成功了 200 success”，还能够打印出“失败了 haha error”，当num&gt;1时，也能打印出“失败了 sorry timeout” 如果then中的第二个函数和catch同时写的话，又会打印出什么呢，也就是这样 123456789101112131415new Promise((resolve, reject) =&gt; &#123; let num = Math.random()*2 if(num &lt; 1)&#123; resolve('200 success') &#125;else&#123; reject('sorry timeout') &#125;&#125;).then((res) =&gt; &#123; console.log(\"成功了 \" + res) throw new Error('haha error')&#125;, (err1) =&gt; &#123; console.log(\"err1失败了 \" + err1)&#125;).catch((err2) =&gt; &#123; console.log(\"err2失败了 \" + err2)&#125;) 当num&gt;1时，只会打印出“err1失败了 sorry timeout”，当num&lt;1时，则会打印出“成功了 200 success”，以及“err2失败了 haha error” 当then的第二个函数与catch同时存在时，then的第二个函数会拦截到错误信息，而不会再走到catch中 平时多读一下Promise的官方文档，就能对Promise有更深层的理解，这里只是简单说了一下日常开发中所经历的一些小问题","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"promise","slug":"promise","permalink":"http://yixirumeng.github.io/tags/promise/"}]},{"title":"TCP的三次握手与四次分手","date":"2018-08-11T16:12:00.000Z","path":"2018/08/12/tcp/","text":"在TCP/IP协议中，TCP为提供可靠的连接服务，需要通过“三次握手”进行初始化，初始化后建立了真正的连接，客户端与服务端才能开始数据请求与发送。当传送完数据后，需要断开TCP连接，这就涉及到了“四次分手” 三次握手的过程：第一次握手：客户端向服务端发送请求建立连接 第二次握手：服务端接收到客户端发送来的请求，并向客户端发送同意与客户端建立连接 第三次握手：客户端接收到服务端发送来的请求，并向服务端发送同意与服务端建立连接 三次握手的作用主要作用是，防止已失效的连接突然又向服务端发送请求，产生错误。 具体到每次握手的作用是，第一次和第二次握手为了保证服务端能够接收到客户端的信息并做出正确的应答，第二次与第三次握手为了保证客户端能够接收到服务端的信息并做出正确的应答。 四次分手的过程第一次分手：客户端向服务端发送断开连接的请求 第二次分手：服务端接收到客户端发来的断开请求，并向客户端发送请求同意断开连接 第三次分手：服务端向客户端发送断开连接的请求 第四次分手：客户端收到服务端发送来的断开请求，并向服务端发送请求同意断开连接 四次分手的作用1、当客户端发送断开请求时，只是表达没有数据要发送了，告诉服务端数据已经全部发送完毕，但这个时候，仍然可以接收到服务端发来的数据 2、当服务端接收到断开请求时，表达已经知道客户端没有数据要发送了，并发送同意断开连接的请求，但服务端还是可以向客户端发送数据 3、当服务端发送断开连接的请求时，表示已经没有数据要发送了，并通知客户端 4、当客户端接收到断开连接的请求后，再告诉服务端已经知道服务端没有数据要发送了，同意断开连接 当然在每次握手与分手中，还有很多细节，这里只是简单说了一下大致的过程以及每个过程的含义和作用。","tags":[{"name":"extend","slug":"extend","permalink":"http://yixirumeng.github.io/tags/extend/"},{"name":"TCP连接","slug":"TCP连接","permalink":"http://yixirumeng.github.io/tags/TCP连接/"}]},{"title":"vue-cli区分开发、测试、生产环境","date":"2018-04-02T13:59:06.000Z","path":"2018/04/02/vue-cli-environment/","text":"vue-cli工具能够快速搭建出vue项目，但在日常开发中，会根据不同的环境应用不同的接口地址，大多分为开发环境、测试环境、生产环境，但vue-cli工具只配置了开发环境与生产环境，但测试环境下也需要打包出来放到服务器上，频繁更改接口地址会很麻烦，其实只要更改下webpack配置，就可以根据设置的命令生成不同环境的项目。 在build文件夹中创建build-test.js文件代码很简单，主要配置一个环境变量来区分测试与正式环境。 12process.env.type = '\"test\"' //注意必须是单双引号嵌套的形式require('./build') //引入自带的文件，执行编译代码 修改config文件夹下的prod.env.js文件配置好后就可以在应用process.env.type 1234module.exports = &#123; NODE_ENV: '\"production\"', type: process.env.type&#125; 在package.json文件中添加npm run test命令添加命令，执行build-test.js文件 123456\"scripts\": &#123; \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\", \"start\": \"npm run dev\", \"build\": \"node build/build.js\", \"test\": \"node build/build-test.js\"&#125; 在项目中根据代码判断环境1234567891011let ajaxUrlif(process.env.NODE_ENV === 'development')&#123; ajaxUrl = 开发环境的公告接口地址&#125;else&#123; if(process.env.type === 'test)&#123; ajaxUrl = 测试环境的公告接口地址 &#125;else&#123; ajaxUrl = 生产环境的公告接口地址 &#125;&#125; 不同环境执行的命令：开发环境启动项目：npm run dev 测试环境打包项目：npm run test 生产环境打包项目：npm run build","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"}]},{"title":"JS判断用户是否在浏览当前页面","date":"2018-03-03T04:44:52.000Z","path":"2018/03/03/browser-tab-change/","text":"之前在浏览某网站的时候发现，当正在浏览这个网站的页面是，浏览器Tab的title是一些文字，当切换Tab切换到别的页面的时候，title内容变成的另一些文字，这个效果感觉不错，能够吸引用户。想实现这一效果，需要用JS来判断更改title内容。 这里需要用到document.hidden这一API来判断页面是否可见，它的值返回的类型为boolean，当为true的时候，表示页面不可见，当为false的时候，表示页面可见。 搜索这一API知道它的用法： 1234document.addEventListener(\"visibilitychange\", function() &#123; console.log( document.hidden ); // 想要实现效果的代码&#125;); 但这一API有兼容性问题，它的兼容性为：IE10+，Firefox10+，Chrome14+，Opera12.1+，Safari7.1+，所以在代码中要做兼容性处理 兼容性写法示例： HTML： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;欢迎浏览&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var hiddenProperty = 'hidden' in document ? 'hidden' : 'webkitHidden' in document ? 'webkitHidden' : 'mozHidden' in document ? 'mozHidden' : null; var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, 'visibilitychange'); var onVisibilityChange = function()&#123; var title = document.querySelector('title'); if(!document[hiddenProperty])&#123; title.innerHTML = '欢迎浏览' &#125;else&#123; title.innerHTML = '记得再来' &#125; &#125; document.addEventListener(visibilityChangeEvent, onVisibilityChange) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当浏览此页面的时候，标题显示为“欢迎浏览”，当离开此页面的时候，标题显示为“记得再来”。即使在不兼容这一API的浏览器中打开，标题总是显示为“欢迎浏览”，也不会有很大的影响。 同时也可以根据这一API来做更多想要的效果。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://yixirumeng.github.io/tags/javascript/"},{"name":"browser","slug":"browser","permalink":"http://yixirumeng.github.io/tags/browser/"}]},{"title":"实现移动端页面滚动加载更多","date":"2018-03-03T04:44:31.000Z","path":"2018/03/03/scroll-load/","text":"PC页面用分页，移动端页面滚动加载更多数据在日常的开发中经常会用到，而JS实现起来也很简单。下面就来说下移动滚动加载更多的解决方案 先说下移动端滚动加载更多数据的原理：其请求数据的原理与PC端分页是一样的，改变页码，发送请求，再将数据渲染到页面上。 而移动页面发送请求的位置要根据滚动的位置来计算，当滚动的高度+屏幕可见高度&gt;页面的高度时，发送请求，同时将数据拿到，追加的页面上 这里也有要注意的地方，需要设置一个开关来控制是否请求数据，否则会不停发送请求，还有要判断是否加载完毕更多数据，如果加载完则不要继续请求 代码实现12345678910111213141516171819202122232425var sw = true (设置开关控制是否发送请求)window.onscroll = function()&#123; (获取滚动的高度，这里写的两种方法是为浏览器做兼容处理) var scrollH = document.documentElement.scrollTop || document.body.scrollTop (获取可视高度，如果只是在某个区域，可以自行获取) var screenH = document.documentElement.clientHeight (获取整个页面高度) var bodyH = document.body.clientHeight (判断开关是否为true，判断滚动高度+可见高度是否&gt;页面高度，判断是否加载完毕) if(sw &amp;&amp; (scrollH + screenH &gt; bodyH) &amp;&amp; currentPage &lt; totalPage)&#123; sw = false (将开关关闭) currentPage +=1 (设置请求下一部分数据的参数) ajaxFn() (发送请求的方法) &#125;&#125;在发送请求的方法中，获取完数据后，设置开关为truefunction ajaxFn()&#123; /*ajax方法*/ sw = true&#125; 以上为整体的原理，其它的一些效果，则根据项目的需要再进行修改。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"mobile","slug":"mobile","permalink":"http://yixirumeng.github.io/tags/mobile/"},{"name":"scroll","slug":"scroll","permalink":"http://yixirumeng.github.io/tags/scroll/"}]},{"title":"HTML5不重新加载改变url","date":"2018-01-13T05:01:01.000Z","path":"2018/01/13/not-load-change-url/","text":"有时候想要实现无刷新改变url，尤其是在改变url后的参数时会用到。如果直接在js中修改url总是会重新加载页面，不能满足需求，而HTML5 History新增的两个api分别是pushState和replaceState可以很轻松解决这个问题。 先来介绍一下这两个API：1234567window.history.pushState(data, title, url)window.history.replaceState(data, title, url)参数说明：data：提供state data，在用户点击后退，触发window.onpopstate时提供此对象。(object类型)title：重写页面标题，但目前浏览器都会忽略此参数。(string类型)url：重写url，只会更改url部分的内容，并不能更改协议、主机名、端口、IP等内容。(string类型) 有了这两个方法，改变url就会很简单，只需设置data的值为空{}、title的值为空””、url的值为新的url就可以实现。 具体实现方法：假设当前的url为http://www.example.com?param=1，要实现不刷新页面更改参数param的值为2。(只写简单代码) html: 123456789&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"btn\"&gt;更改url&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; js: 123456var btn = document.getElementById(\"btn\");btn.onclick = function()&#123; var url = window.location.origin; var newUrl = url + '?param=2'; window.history.pushState(&#123;&#125;, \"\", newUrl);&#125; 当点击“更改url”这个按钮后，页面的url就会更改为www.example.com?param=2，并且不会刷新页面。 这里只给出了很简单方法，其它更改的原理都相同，只不过是对新的url做一些处理。 另附window的location对象的属性及方法以http://www.example.com:8080/test/test.html?param=1#part2为例 1、window.location.hash 获取url的锚部分返回：#part2 2、window.location.host 获取url的主机名及端口号返回：www.example.com:8080 3、window.location.hostname 获取url的主机名返回：www.example.com 4、window.location.pathname 获取url的路径部分返回：/test/test.html 5、window.location.port 获取url的端口号返回：8080（注意这里8080的类型是string，不是number） 6、window.location.search 获取url的参数部分返回：?param=1 7、window.location.origin 获取主机名及端口号及路径部分返回：http://www.example.com:8080/test/test.html 8、window.location.protocol 获取url的协议返回：http: 9、window.location.href 获取整个url地址返回：http://www.example.com:8080/test/test.html?param=1#part2 10、window.location.assign(“newUrl”) 加载一个新的地址链接跳转到newUrl，可以后退到之前的url 11、window.location.reload() 重新加载当前页面该方法内的参数默认为false，如果设置为true，会绕过缓存，重新加载整个页面 12、window.location.replace(“newUrl”) 用新的newUrl替换当前的url无法后退到之前的url","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://yixirumeng.github.io/tags/javascript/"},{"name":"Html5","slug":"Html5","permalink":"http://yixirumeng.github.io/tags/Html5/"}]},{"title":"原生Javascript封装ajax","date":"2017-12-31T07:55:26.000Z","path":"2017/12/31/javascript-ajax/","text":"ajax对于前端来说并不陌生，在与后端进行交互的时候基本上都会用到。平时在使用的时候，大多数的前端er会采用jquery或者其它框架已经封装好的ajax请求，直接调用，但是如果在简单项目中，只需用到ajax，这样引入jquery显得有些过重，所以用原生JS封装好ajax函数直接调用，会方便许多。 用原生JS封装ajax并不是很困难，只要清楚其中每一步的原理和操作，就能轻松写出来。（这里只做出简要的说明，并没有写出完整的逻辑判断） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152opt为ajax传递的参数，其值有以下几个： 1、* @param &#123;string&#125;opt.type http连接的方式，包括POST和GET两种方式 2、* @param &#123;string&#125;opt.url 发送请求的url 3、* @param &#123;boolean&#125;opt.async 是否为异步请求，true为异步，false为同步 4、* @param &#123;object&#125;opt.data 发送的参数，格式为对象类型 5、* @param &#123;function&#125;opt.success ajax发送并接收成功调用的回调函数 function ajax(opt)&#123; //对所传参数进行判断 opt = opt || &#123;&#125;; opt.method = opt.method.toUpperCase() || 'POST'; opt.url = opt.url || ''; if(typeof(opt.async) == 'undefined')&#123; opt.async = true; &#125; opt.data = opt.data || null; //创建ajax对象 var xmlHttp = null; if(XMLHttpRequest)&#123; xmlHttp = new XMLHttpRquest(); &#125;else&#123; //兼容ie6 xmlHttp = new ActiveXObject('Microsoft.XMLHttp'); &#125; //对传递的data参数进行格式化 var params = []; for(var key in opt.data)&#123; params.push(key + '=' + opt.data[key]); &#125; var postData = params.join('&amp;'); //判断请求方式，连接服务器，发送请求方式、链接、是否异步、参数 if(opt.method === 'POST')&#123; xmlHttp.open(opt.method, opt.url, opt.async); xmlHttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8'); xmlHttp.send(postData); &#125;else if(opt.method === 'GET')&#123; xmlHttp.open(opt.method, opt.url + '?' + postData, opt.async); xmlHttp.send(null); &#125; //判断是否请求成功，如果成功，接收返回值 xmlHttp.onreadyStateChange = function()&#123; if(xmlHttp.readystate == 4 &amp;&amp; xmlHttp.status == 200)&#123; var response = JSON.parse(responseText); success(response); &#125; &#125;&#125; 这样引入这个JS库，并在页面中调用封装好的ajax，并传递相应的参数，就可以像应用jquery的ajax方法一样与后台进行交互了。 在去面试的时候，很多面试官会要求手写ajax，只要理清思路，一步接一步下来，很轻松就能写出。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"http://yixirumeng.github.io/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://yixirumeng.github.io/tags/ajax/"}]},{"title":"轻松解决鼠标移入事件多次触发","date":"2017-12-09T07:07:06.000Z","path":"2017/12/09/hover-event/","text":"在做鼠标移入触发事件时，有时会遇到事件多次触发，想尽办法，但最终的效果都不是很好。其实只要几行代码，就可以轻松解决。 为了方便大多数的前端er学习，下面以jquery来说明，原生js和其他框架的道理一样的。 正常调用jqery的hover方法 1234567$(function()&#123; $(\"selector\").hover(function()&#123; //鼠标移入执行的代码 &#125;, function()&#123; //鼠标移出执行的代码 &#125;)&#125;) 这样偶尔会出现移入的事件多次触发。 解决方法1234567891011$(function()&#123; var timer; $(\"selector\").hover(function()&#123; timer = setTimeout(function()&#123; //鼠标移入执行的代码 &#125;, 200) &#125;, function()&#123; clearTimeout(timer); //鼠标移出执行的代码 &#125;)&#125;) 200的数值可以随意设置，只要设置小一点，基本上看不出延迟，但也不要过小。 代码很容易看懂，就是在鼠标移入之前加了短暂的延迟，这样就能轻松避免鼠标移入多次执行事件，以及过快重复移入鼠标导致上一事件没执行完，下一事件又开始了。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"JS","slug":"JS","permalink":"http://yixirumeng.github.io/tags/JS/"}]},{"title":"CSS border制作三角形详解","date":"2017-12-02T11:01:17.000Z","path":"2017/12/02/border-triangle/","text":"前端工程师在做页面遇到三角形的时候，以前都是用图片来代替，后在网上出现了用CSS样式就可以实现，这也受到了很多人的青睐，但具体为何如此设置样式就可以呈现这种效果，很多同学都模棱两可。现在就通过例子来揭晓。 新建一个html，为了简单，只写了一个div，同时增加些样式。 html:1&lt;div class=\"demo\"&gt;&lt;/div&gt; css:123456789.demo&#123; width: 100px; height: 100px; border-top: 25px solid blue; border-bottom: 25px solid yellow; border-left: 25px solid green; border-right: 25px solid red; margin: 100px auto;&#125; 此时的效果是： 可以看到，边框是以梯形的方式呈现出来的。 当把div的宽度、高度都缩小到0的时候，此时的效果是： 四个方向的边框都是以三角形的方式呈现的。 现在更改一下css，让相邻的两个方向的边框颜色呈现默认颜色transparent：12345678.demo&#123; width: 0; height: 0; border-top: 25px solid blue; border-bottom: 25px solid transparent; border-left: 25px solid transparent; margin: 100px auto;&#125; 现在的效果为： 此时三角形的宽度为50px。 这也就很好理解为什么在网上查到的css样式可以轻松实现出三角形的效果了。 总结用css实现三角形可以通过以下步骤来实现：1、设置元素的宽度、高度都为0。2、根据三角形箭头朝向、颜色的需要，来设置border值。3、为三角形箭头朝向的反方向、以及相邻两个方向设置同样的长度，并为反方向设置需要呈现的颜色，相邻两个方向的颜色设置为transparent。（此为等边三角形，想要其它三角形，可以调整长度）4、border设置的长度为需要长度的一半。用这种方法，并配合before、after等伪元素，可以轻松实现出很多效果，不用再辛苦切图片调整位置了。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://yixirumeng.github.io/tags/css/"},{"name":"border","slug":"border","permalink":"http://yixirumeng.github.io/tags/border/"}]},{"title":"Vue组件开发心得","date":"2017-11-26T03:56:17.000Z","path":"2017/11/26/vue-components-develop/","text":"不谈技术、只谈心得。多思考、多查资料，Vue可复用组件并不难写。 从vue刚开源没多长时间，就开始关注，应用到大大小小项目中也已经接近两年，感觉这个框架真的越用越好用，轻量是一方面，重要的是很容易上手，即使遇到不懂得地方，查一下官方文档，就能马上解决。 在做实际的项目中，经常会有很多相似的地方，比如轮播图、跑马灯、弹出框等，之前为了快速开发完成项目进度，一直都在使用别人造好的轮子。其实自己也很想封装出一套自己的vue组件，不仅可以更加方便开发，也可以加深一下对vue的理解。 在开发之前思考了很多，把能想到的地方都尽量想到，并分析该怎样做出复用性很强的组件。 拿轮播图组件来简单说一下：看过github上大神写的源码，很多应用了slot（不知道的查一下官方文档，说的很详细）来控制组件内部的元素，感觉确实很方便。 其实除了这种方法，还可以通过数据传递，并配合vue已经存在的属性，共同来完成组件。在做轮播图组件的时候便应用了这种方法，而且也很简单。 平时做的轮播图，大多都是左右移动、淡入淡出的效果。在vue文档“过渡&amp;动画”这一块儿，对过渡、动画做出了详细的介绍，只要应用enter、enter-active、leave、leave-active这几个属性，并配合css就可以轻松实现，这样做轮播图组件便简单许多。而内部元素通过data数据进行传递，不仅易于复用，还可以轻松做到与后台的交互。 建议在开发时更多用slot方法，而对于用数据传递的方式能够更便于使用者使用的组件，选择这种方法会更好。 API设置对于设置组件参数这块，想的比较全面，把能控制的地方全部设置了参数，包括对样式的控制。网上大多组件都是传递参数改变状态，并没让使用者对样式做出调整，这样在使用时，可能还需要进行源代码修改，感觉不是很方便。 把一个组件做好后，一定要做的是写demo，尽量把内容写的全面，包括使用方式、API、不同的效果，让使用者能轻易看懂，因为使用者使用这个组件当然是为了要方便开发，如果看文档demo都很费劲，那为何不自己去写一个呢。 记得开源代码写好后，尽量还是开源放到github上，这样就会有很多大神来帮助完善，前期可能不会，但是不要气馁，坚持下去，总会有人发现你的。 总结组件的开发并未有想象中那么难，只要理清思路，把想要呈现的效果一步一步写好，把该做活的地方做出来就可以了。当然也会遇到坑，不要着急，多查资料，查文档，google，百度，都会解决，因为很多坑都有大神为你填好了。 这篇没有谈技术，只是说出一些自己的心得，其中也有很多不足之处，还需要继续学习，后续会给出所做的组件github地址。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"},{"name":"component","slug":"component","permalink":"http://yixirumeng.github.io/tags/component/"}]},{"title":"图片与文字上下对齐","date":"2017-11-09T14:10:35.000Z","path":"2017/11/09/image-words-alignment/","text":"简单几行代码，轻松实现 在浏览网站，尤其是移动端电商网站的时候，经常会看到如下图片与文字对齐的情况 平时开发类似的页面时，可以用简单的img、div、span、a等标签进行布局，再通过调整CSS样式，可以达到这种效果。 其实在html5的新标签中，有专门为实现这种效果的标签，相信很多人都用过，那就是dl、dt、dd，而且用起来非常简单。123456&lt;div style=\"width:100px; margin:100px auto; text-align:center; font-size:14px;\"&gt; &lt;dl&gt; &lt;dt&gt;&lt;img src=\"图片路径\"&gt;&lt;/dt&gt; &lt;dd&gt;风控短信&lt;dd&gt; &lt;/dl&gt;&lt;/div&gt; 呈现的效果： 简单的通过几行代码就可以轻松实现，再也不用辛苦的调各种样式啦。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://yixirumeng.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://yixirumeng.github.io/tags/html/"}]},{"title":"同一链接，每次无缓存加载","date":"2017-10-31T13:20:56.000Z","path":"2017/10/31/nocache-loading/","text":"如何在每次访问同一链接时，加载到的页面都是没有缓存效果呢？简单一步帮你解决。 缓存对于web开发者来说并不陌生（不知道的可以百度一下），平时在开发的过程中，为了能够看到没有缓存的效果，大家一般都采用无痕模式的浏览器，这样按F5之后，显示的就是没有缓存的效果，或者直接按Ctrl + F5，也能达到同样的效果。 但是对于普通用户来说，相信有一大部分用户都不清楚缓存的概念，即使知道的，可能更多是知道在浏览器设置中选择一下清理浏览器缓存，但具体干了什么，还是不明白。 如何让用户访问域名之后，每次访问的都是没有缓存的效果呢？ 其实也很简单，只要在url的后面增加一个参数（参数名随意），而参数的值是一个随机数（Math.random()）就可以了，随机数的位数可以自己定义，正常3到4位的随机数就足够了，会用JS的应该对这块不会陌生。这样既不会影响用户的使用，同时也使得用户每次访问的都是没有缓存的页面，是不是很简单。当然，这样也有很大的弊端，那就是每次用户都要重新加载所有的资源，包括页面中引用的CSS、JS、图片、字体等等，影响加载速度。是否可以牺牲一些加载速度，达到每次都是最新的效果，还是要视情况而定。","tags":[{"name":"extend","slug":"extend","permalink":"http://yixirumeng.github.io/tags/extend/"},{"name":"无缓存加载","slug":"无缓存加载","permalink":"http://yixirumeng.github.io/tags/无缓存加载/"}]},{"title":"JS事件冒泡与捕获，以及阻止事件冒泡","date":"2017-10-31T13:17:22.000Z","path":"2017/10/31/propagation-capture/","text":"JS事件的冒泡与捕获在平时的开发中时常会遇到，以下用简单的叙述以及案例详细解释冒泡与捕获。同时给出阻止事件冒泡的方法。 平时在写JS时，可能会在父子元素上都增加事件，这样就产生了事件的冒泡与捕获。 冒泡：事件的冒泡简单说，是事件从内向外依次执行捕获：事件的捕获简单说，是事件从外向内依次执行在HTML的DOM操作中，为元素增加事件的方法是addEventListener，这个方法的第三个参数是一个Boolean值，当为false时，指定事件在冒泡阶段执行；当为true时，在捕获阶段执行，默认值为false。 以下通过实例简单说明一下（自己也可以仿照一下代码试一下，给一些样式效果会更加明显）： HTML:1234567891011121314 &lt;div id=\"parent\"&gt; 父元素 &lt;div id=\"child\"&gt;子元素&lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.getElementById(\"parent\").addEventListener(\"click\", function()&#123; alert(\"我是父元素\");&#125;, false); document.getElementById(\"child\").addEventListener(\"click\", function()&#123; alert(\"我是子元素\");&#125;, false); &lt;/script&gt; 当点击“子元素”时，会依次弹出“我是子元素”、“我是父元素”；如果将两个参数false都改为true后，点击“子元素”后，会依次弹出“我是父元素”，“我是子元素”。如果将其中的一个设置为true，另一个为false，那么将根据父元素设置的值来判断。如果父元素设置为true，将在捕获阶段执行，反之，则在冒泡阶段执行。其实事件的捕获与时间的冒泡并不是很难理解，但是在实际应用中，我们只希望事件发生在目标元素上，这就需要阻止事件的冒泡，以此来达到我们需要的效果。阻止冒泡的方式有以下几种： 原生JS方法123456789101112131415function stopPropagation(e)&#123; e = e || window.event; if(e.stopPropagation)&#123; //W3C阻止冒泡方法 e.stopPropagation(); &#125;else&#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125;&#125;也可以简写：function stopPropagation(e)&#123; e = e || window.event; e.stopPropagation?e.stopPropagation():e.cancelBubble=true;&#125; 将此方法放入之前的代码中，并在addEventListener方法中调用，就会阻止事件冒泡。 12345678910 &lt;script&gt; document.getElementById(\"parent\").addEventListener(\"click\", function()&#123; alert(\"我是父元素\");&#125;, false); document.getElementById(\"child\").addEventListener(\"click\", function(e)&#123; alert(\"我是子元素\"); stopPropagation(e);&#125;, false); &lt;/script&gt; 此时点击“子元素”时，将只弹出“我是子元素”。 jquery方法：直接在事件内部调用e.stopPropagation()方法，就可以阻止事件冒泡，jquery已经做好了IE兼容性处理，这里就不需要写IE的方法。 虽然jquery用起来比较简单，但是还是应该了解原生JS的使用。在不同的环境下，应用不同的方法，可以使得开发更有效率。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"JS","slug":"JS","permalink":"http://yixirumeng.github.io/tags/JS/"}]},{"title":"CSS水平垂直居中方法总结","date":"2017-10-14T08:04:10.000Z","path":"2017/10/14/css-horizontal-vertical-center/","text":"平时在做项目的时候，会遇到让元素在水平方向和垂直方向同时居中的情况，典型的例子就是弹出框（点击某个按钮，出现弹出框）。要实现这个需求，用css就可以完全控制，非常方便。 方法一这个方法是同事告诉我的，用的是table布局，也就display:table，相对来说是种旧的方式。 HTML:1234567&lt;div class=\"fixBox\"&gt; （fixBox是为了实现弹出框悬浮） &lt;div class=\"box1\"&gt; &lt;div class=\"box2\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS:123456789101112131415161718192021.fixBox&#123; position:fixed; top:0; left:0; bottom:0; right:0;&#125;.box1&#123; display:table; width:100%;&#125;.box2&#123; display:table-cell; vertical-align:middle;&#125;.box&#123; margin:0 auto;&#125; 这样可以让box元素居中，但是比较复杂，要套很多层标签，显得有些复杂。（不推荐使用） 方法二采用定位的方式，也就是position:absolute HTML: 1&lt;div class=\"box\"&gt;&lt;/div&gt; CSS: 123456789.box&#123; width:400px; height:400px; position:absolute; 让元素绝对定位 left:50%; 设置定位的位置距离左、上都为50% top:50%; margin-left:-100px; 设置元素的左外边距、上外边距都为宽高的负1/2 margin-top:-200px;&#125; 这种方法兼容性好，但是有个前提是必须要知道水平垂直元素的宽高。 方法三方法三跟方法二相类似，需要变换的只是不需要设置外边距，而是使用CSS3的transform 将margin都去掉，换成transform:translate(-50%,-50%),设置元素相对于自身偏移负50%，也就是自身尺寸的一半 这种方法因为使用CSS3的样式，所以兼容性不好，但是用起来很方便。 方法四方法四跟方法二也很类似，同样使用绝对定位，也需要用到margin值，只不过需要改变一下位置距离的值。 HTML: 1&lt;div class=\"box\"&gt;&lt;/div&gt; CSS: 12345678910.box&#123; width:400px; height:400px; position:absolute; top:0; left:0; bottom:0; right:0; margin:auto;&#125; 如果想兼容低版本的浏览器，可以采用方法四，因为不需要用到CSS3的样式，同时对于元素的宽高也不是必须要知道的。 每种方法都有自身的优缺点，在平时的开发中，根据实际情况以及需求来决定具体应用哪一种方法。","tags":[{"name":"web","slug":"web","permalink":"http://yixirumeng.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"http://yixirumeng.github.io/tags/css/"}]},{"title":"Vue非父子组件之间的通信（不应用Vuex）","date":"2017-10-04T09:53:36.000Z","path":"2017/10/04/vue-$on/","text":"在做Vue父子组件间的通信时，更多的方法是采用Vuex这个状态管理管理工具，相对来说比较方便。但是在读官方文档时，会看到文档采用$on、$emit来实现通信效果，但在不用Vuex的情况下，到底如何应用这两个API呢？ Vue的文档对非父子组件通信的说明是采用创建一个空的Vue实例作为中介，然后应用$emit、$on两个API来达到信息传递的效果 现在用Vue开发，基本上都会采用webpack搭建，使用官方提供的Vue-Cli脚手架工具，但是这里面的的问题是，在什么位置创建这个空的Vue实例呢？尝试过很多方法，也试过在vue的组件内部分别创建，运行后不起作用，仔细思考一下，这个实例也只是对该组件起作用，并不会影响到其它的组件。 再看一下官网的API文档，看到了有$root这个方法，可以访问到根实例，这样就可以在根实例中定义一个空的Vue实例供组件调用。而根实例当然就是入口文件，用脚手架的话就是main.js这个文件。具体的方法为：1234567891011new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;, data()&#123; return &#123; Bus: new Vue() &#125; &#125;&#125;) 将Bus定义在data中，任何组件都可以访问到。现在就可以定义两个组件来试验一下(随便写的两个组件，记得配置路由，具体代码就不贴出来了)： 组件A:12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;button @click=\"increment\"&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return &#123; count: 0, count1: '你好' &#125; &#125;, methods:&#123; increment()&#123; this.count++; this.$root.Bus.$emit('increment', this.count1); &#125; &#125; &#125;&lt;/script&gt; 组件B:1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return &#123; msg: '晚安' &#125; &#125;, created()&#123; this.$root.Bus.$on('increment', function(msg1)&#123; console.log(msg1) &#125;) &#125; &#125;&lt;/script&gt; 组件A是一个按钮，定义了点击事件，点击后可以让数字加1；组件B只是简单的展示。在组件A上用$emit触发当前实例上的increment事件，同时将count1作为参数传递出去，组件B应用$on监听increment事件，同时获得所传的参数，并在控制台上打印出来。当点击组件A的按钮后，就可以在组件B的控制台上看到了“晚安”两个字，这样也就按着官网的方法实现了非父子组件间的通信。 其实这并不是推荐方式，最好还是使用官方推出的Vuex状态管理工具，所有组件的状态都能提取出来，更加方便管理。这里介绍的方法只是想应用官方文档说明的方式来做出一个具体的实例。","tags":[{"name":"framework","slug":"framework","permalink":"http://yixirumeng.github.io/tags/framework/"},{"name":"vue","slug":"vue","permalink":"http://yixirumeng.github.io/tags/vue/"}]}]